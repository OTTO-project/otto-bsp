From fbfcfec357143ca47f7ff0759c32c8293f6b796a Mon Sep 17 00:00:00 2001
From: topisani <topisani@hamsterpoison.com>
Date: Fri, 31 Jan 2020 22:56:54 +0100
Subject: [PATCH] google patches

---
 include/dbus-c++/connection.h            | 850 ++++++++++++-----------
 include/dbus-c++/dbus.h                  |   1 -
 include/dbus-c++/debug.h                 |   3 +-
 include/dbus-c++/dispatcher.h            | 376 +++++-----
 include/dbus-c++/ecore-integration.h     |  62 +-
 include/dbus-c++/error.h                 | 225 +++---
 include/dbus-c++/eventloop-integration.h |  64 +-
 include/dbus-c++/eventloop.h             | 196 ++----
 include/dbus-c++/glib-integration.h      |  72 +-
 include/dbus-c++/interface.h             | 131 ++--
 include/dbus-c++/introspection.h         |  39 +-
 include/dbus-c++/message.h               | 250 ++++---
 include/dbus-c++/object.h                | 169 +++--
 include/dbus-c++/pendingcall.h           | 188 ++---
 include/dbus-c++/property.h              |  64 +-
 include/dbus-c++/refptr_impl.h           |   9 +-
 include/dbus-c++/server.h                |  25 +-
 include/dbus-c++/types.h                 | 708 ++++++++-----------
 include/dbus-c++/util.h                  | 362 +++++-----
 src/Makefile.am                          | 108 ++-
 src/connection.cpp                       | 487 +++++++------
 src/connection_p.h                       |  35 +-
 src/debug.cpp                            |  24 +-
 src/dispatcher.cpp                       | 303 ++++----
 src/dispatcher_p.h                       |  15 +-
 src/ecore-integration.cpp                | 213 ++++++
 src/error.cpp                            |  23 +-
 src/eventloop-integration.cpp            | 191 ++---
 src/eventloop.cpp                        | 295 ++++----
 src/glib-integration.cpp                 | 314 +++++++++
 src/interface.cpp                        | 178 +++--
 src/internalerror.h                      |  59 +-
 src/introspection.cpp                    | 211 +++---
 src/message.cpp                          | 487 +++++++------
 src/message_p.h                          |  18 +-
 src/object.cpp                           | 518 ++++++++------
 src/pendingcall.cpp                      | 104 +--
 src/pendingcall_p.h                      |  17 +-
 src/property.cpp                         | 181 +++--
 src/server.cpp                           |  84 +--
 src/server_p.h                           |  17 +-
 src/types.cpp                            |  61 +-
 42 files changed, 4202 insertions(+), 3535 deletions(-)
 create mode 100644 src/ecore-integration.cpp
 create mode 100644 src/glib-integration.cpp

diff --git a/include/dbus-c++/connection.h b/include/dbus-c++/connection.h
index 9dc921b..e3df707 100644
--- a/include/dbus-c++/connection.h
+++ b/include/dbus-c++/connection.h
@@ -33,12 +33,11 @@
 #include "message.h"
 #include "pendingcall.h"
 
-namespace DBus
-{
+namespace DBus {
 
 class Connection;
 
-typedef Slot<bool, const Message &> MessageSlot;
+typedef Slot<bool, const Message&> MessageSlot;
 
 typedef std::list<Connection>	ConnectionList;
 
@@ -49,419 +48,452 @@ class DXXAPI Connection
 {
 public:
 
-  static Connection SystemBus();
-
-  static Connection SessionBus();
-
-  static Connection ActivationBus();
-
-  struct Private;
-
-  typedef std::list<Private *> PrivatePList;
-
-  Connection(Private *);
-
-  Connection(const char *address, bool priv = true);
-
-  Connection(const Connection &c);
-
-  virtual ~Connection();
-
-  Dispatcher *setup(Dispatcher *);
-
-  bool operator == (const Connection &) const;
-
-  /*!
-   * \brief Adds a match rule to match messages going through the message bus.
-   *
-   * The "rule" argument is the string form of a match rule.
-   *
-   * If you pass NULL for the error, this function will not block; the match
-   * thus won't be added until you flush the connection, and if there's an error
-   * adding the match (only possible error is lack of resources in the bus), you
-   * won't find out about it.
-   *
-   * Normal API conventions would have the function return a boolean value
-   * indicating whether the error was set, but that would require blocking always
-   * to determine the return value.
-   *
-   * The AddMatch method is fully documented in the D-Bus specification. For
-   * quick reference, the format of the match rules is discussed here, but the
-   * specification is the canonical version of this information.
-   *
-   * Rules are specified as a string of comma separated key/value pairs. An
-   * example is "type='signal',sender='org.freedesktop.DBus',
-   * interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'"
-   *
-   * Possible keys you can match on are type, sender, interface, member, path,
-   * destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.).
-   * Omitting a key from the rule indicates a wildcard match. For instance omitting
-   * the member from a match rule but adding a sender would let all messages from
-   * that sender through regardless of the member.
-   *
-   * Matches are inclusive not exclusive so as long as one rule matches the
-   * message will get through. It is important to note this because every time a
-   * essage is received the application will be paged into memory to process it.
-   * This can cause performance problems such as draining batteries on embedded platforms.
-   *
-   * If you match message args ('arg0', 'arg1', and so forth) only string arguments
-   * will match. That is, arg0='5' means match the string "5" not the integer 5.
-   *
-   * Currently there is no way to match against non-string arguments.
-   *
-   * Matching on interface is tricky because method call messages only optionally
-   * specify the interface. If a message omits the interface, then it will NOT
-   * match if the rule specifies an interface name. This means match rules on
-   * method calls should not usually give an interface.
-   *
-   * However, signal messages are required to include the interface so when
-   * matching signals usually you should specify the interface in the match rule.
-   *
-   * For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER.
-   *
-   * Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes.
-   *
-   * Both of these maximums are much higher than you're likely to need, they only
-   * exist because the D-Bus bus daemon has fixed limits on all resource usage.
-   *
-   * \param rule Textual form of match rule.
-   * \throw Error
-   */
-  void add_match(const char *rule);
-
-  /*!
-   * \brief Removes a previously-added match rule "by value" (the most
-   *        recently-added identical rule gets removed).
-   *
-   * The "rule" argument is the string form of a match rule.
-   *
-   * The bus compares match rules semantically, not textually, so whitespace and
-   * ordering don't have to be identical to the rule you passed to add_match().
-   *
-   * \param rule Textual form of match rule.
-   * \throw Error
-   */
-  void remove_match(const char *rule, bool		throw_on_error);
-
-  /*!
-   * \brief Adds a message filter.
-   *
-   * Filters are handlers that are run on all incoming messages, prior to the
-   * objects registered with ObjectAdaptor::register_obj(). Filters are
-   * run in the order that they were added. The same handler can be added as a
-   * filter more than once, in which case it will be run more than once. Filters
-   * added during a filter callback won't be run on the message being processed.
-   *
-   * \param s The MessageSlot to add.
-   */
-  bool add_filter(MessageSlot &s);
-
-  /*!
-   * \brief Removes a previously-added message filter.
-   *
-   * It is a programming error to call this function for a handler that has not
-   * been added as a filter. If the given handler was added more than once, only
-   * one instance of it will be removed (the most recently-added instance).
-   *
-   * \param s The MessageSlot to remove.
-   */
-  void remove_filter(MessageSlot &s);
-
-  /*!
-   * \brief Sets the unique name of the connection, as assigned by the message bus.
-   *
-   * Can only be used if you registered with the bus manually (i.e. if you did
-   * not call register_bus()). Can only be called once per connection. After
-   * the unique name is set, you can get it with unique_name(void).
-   *
-   * The only reason to use this function is to re-implement the equivalent of
-   * register_bus() yourself. One (probably unusual) reason to do that might
-   * be to do the bus registration call asynchronously instead of synchronously.
-   *
-   * \note Just use dbus_bus_get() or dbus_bus_get_private(), or worst case
-   *       register_bus(), instead of messing with this function. There's
-   *       really no point creating pain for yourself by doing things manually.
-   *       (Not sure if this is yet wrapped.)
-   *
-   * It's hard to use this function safely on shared connections (created by
-   * Connection()) in a multithreaded application, because only one
-   * registration attempt can be sent to the bus. If two threads are both
-   * sending the registration message, there is no mechanism in libdbus itself
-   * to avoid sending it twice.
-   *
-   * Thus, you need a way to coordinate which thread sends the registration
-   * attempt; which also means you know which thread will call
-   * unique_name(const char*). If you don't know about all threads in the app
-   * (for example, if some libraries you're using might start libdbus-using
-   * threads), then you need to avoid using this function on shared connections.
-   *
-   * \param n The unique name.
-   */
-  bool unique_name(const char *n);
-
-  /*!
-   * \brief Gets the unique name of the connection as assigned by the message bus.
-   *
-   * Only possible after the connection has been registered with the message bus.
-   * All connections returned by dbus_bus_get() or dbus_bus_get_private() have
-   * been successfully registered. (Not sure if this is yet wrapped.)
-   *
-   * The name remains valid until the connection is freed, and should not be
-   * freed by the caller.
-   *
-   * Other than dbus_bus_get(), there are two ways to set the unique name; one
-   * is register_bus(), the other is unique_name(const char*). You are
-   * responsible for calling unique_name(const char*) if you register by hand
-   * instead of using register_bus().
-   */
-  const char *unique_name() const;
-
-  /*!
-   * \brief Registers a connection with the bus.
-   *
-   * This must be the first thing an application does when connecting to the
-   * message bus. If registration succeeds, the unique name will be set, and
-   * can be obtained using unique_name(void).
-   *
-   * This function will block until registration is complete.
-   *
-   * If the connection has already registered with the bus (determined by
-   * checking whether unique_name(void) returns a non-NULL value),
-   * then this function does nothing.
-   *
-   * If you use dbus_bus_get() or dbus_bus_get_private() this function will be
-   * called for you.  (Not sure if this is yet wrapped.)
-   *
-   * \note Just use dbus_bus_get() or dbus_bus_get_private() instead of
-   * register_bus() and save yourself some pain. Using register_bus()
-   * manually is only useful if you have your own custom message bus not found
-   * in DBusBusType.
-   *
-   * If you open a bus connection by the contructor of Connection() you will have to register_bus()
-   * yourself, or make the appropriate registration method calls yourself. If
-   * you send the method calls yourself, call unique_name(const char*) with
-   * the unique bus name you get from the bus.
-   *
-   * For shared connections (created with dbus_connection_open()) in a
-   * multithreaded application, you can't really make the registration calls
-   * yourself, because you don't know whether some other thread is also
-   * registering, and the bus will kick you off if you send two registration
-   * messages. (TODO: how is this done in the wrapper?)
-   *
-   * If you use register_bus() however, there is a lock that keeps both
-   * apps from registering at the same time.
-   *
-   * The rule in a multithreaded app, then, is that register_bus() must be
-   * used to register, or you need to have your own locks that all threads in
-   * the app will respect.
-   *
-   * In a single-threaded application you can register by hand instead of using
-   * register_bus(), as long as you check unique_name(void) to
-   * see if a unique name has already been stored by another thread before you
-   * send the registration messages.
-   */
-  bool register_bus();
-
-  /*!
-   * \brief Gets whether the connection is currently open.
-   *
-   * A connection may become disconnected when the remote application closes its
-   * end, or exits; a connection may also be disconnected with disconnect().
-   *
-   * There are not separate states for "closed" and "disconnected," the two
-   * terms are synonymous.
-   *
-   * \return true If the connection is still alive.
-   */
-  bool connected() const;
-
-  /*!
-   * \brief Closes a private connection, so no further data can be sent or received.
-   *
-   * This disconnects the transport (such as a socket) underlying the connection.
-   *
-   * Attempts to send messages after closing a connection are safe, but will
-   * result in error replies generated locally in libdbus.
-   *
-   * This function does not affect the connection's reference count. It's safe
-   * to close a connection more than once; all calls after the first do nothing.
-   * It's impossible to "reopen" a connection, a new connection must be created.
-   * This function may result in a call to the DBusDispatchStatusFunction set
-   * with Private::init(), as the disconnect
-   * message it generates needs to be dispatched.
-   *
-   * If a connection is dropped by the remote application, it will close itself.
-   *
-   * You must close a connection prior to releasing the last reference to the
-   * connection.
-   *
-   * You may not close a shared connection. Connections created with
-   * dbus_connection_open() or dbus_bus_get() are shared. These connections are
-   * owned by libdbus, and applications should only unref them, never close them.
-   * Applications can know it is safe to unref these connections because libdbus
-   * will be holding a reference as long as the connection is open. Thus, either
-   * the connection is closed and it is OK to drop the last reference, or the
-   * connection is open and the app knows it does not have the last reference.
-   *
-   * Connections created with dbus_connection_open_private() or
-   * dbus_bus_get_private() are not kept track of or referenced by libdbus.
-   * The creator of these connections is responsible for calling
-   * dbus_connection_close() prior to releasing the last reference, if the
-   * connection is not already disconnected.
-   *
-   * \todo dbus_connection_disconnect() was removed in dbus 0.9x. Maybe this
-   *       function should be renamed to close().
-   */
-  void disconnect();
-
-  /*!
-   * \brief Set whether _exit() should be called when the connection receives a
-   *        disconnect signal.
-   *
-   * The call to _exit() comes after any handlers for the disconnect signal run;
-   * handlers can cancel the exit by calling this function.
-   *
-   * By default, exit_on_disconnect is false; but for message bus connections
-   * returned from dbus_bus_get() it will be toggled on by default.
-   *
-   * \param exit true If _exit() should be called after a disconnect signal.
-   */
-  void exit_on_disconnect(bool exit);
-
-  /*!
-   * \brief Blocks until the outgoing message queue is empty.
-   */
-  void flush();
-
-  /*!
-   * \brief Adds a message to the outgoing message queue.
-   *
-   * Does not block to write the message to the network; that happens
-   * asynchronously. To force the message to be written, call
-   * dbus_connection_flush(). Because this only queues the message, the only
-   * reason it can fail is lack of memory. Even if the connection is disconnected,
-   * no error will be returned.
-   *
-   * If the function fails due to lack of memory, it returns FALSE. The function
-   * will never fail for other reasons; even if the connection is disconnected,
-   * you can queue an outgoing message, though obviously it won't be sent.
-   *
-   * The message serial is used by the remote application to send a reply; see
-   * Message::serial() or the D-Bus specification.
-   *
-   * \param msg The Message to write.
-   * \param serial Return location for message serial, or NULL if you don't care.
-   * \return true On success.
-   */
-  bool send(const Message &msg, unsigned int *serial = NULL);
-
-  /*!
-   * \brief Sends a message and blocks a certain time period while waiting for a reply.
-   *
-   * This function does not reenter the main loop, i.e. messages other than the
-   * reply are queued up but not processed. This function is used to invoke
-   * method calls on a remote object.
-   *
-   * If a normal reply is received, it is returned, and removed from the
-   * incoming message queue. If it is not received, NULL is returned and the
-   * error is set to DBUS_ERROR_NO_REPLY. If an error reply is received, it is
-   * converted to a DBusError and returned as an error, then the reply message
-   * is deleted and NULL is returned. If something else goes wrong, result is
-   * set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED.
-   *
-   * \warning While this function blocks the calling thread will not be
-   *          processing the incoming message queue. This means you can end up
-   *          deadlocked if the application you're talking to needs you to reply
-   *          to a method. To solve this, either avoid the situation, block in a
-   *          separate thread from the main connection-dispatching thread, or
-   *          use PendingCall to avoid blocking.
-   *
-   * \param msg The Message to write.
-   * \param timeout Timeout in milliseconds (omit for default).
-   * \throw Error
-   */
-  Message send_blocking(Message &msg, int timeout = -1);
-
-  /*!
-   * \brief Queues a message to send, as with send(), but also
-   *        returns a DBusPendingCall used to receive a reply to the message.
-   *
-   * If no reply is received in the given timeout_milliseconds, this function
-   * expires the pending reply and generates a synthetic error reply (generated
-   * in-process, not by the remote application) indicating that a timeout occurred.
-   *
-   * A PendingCall will see a reply message before any filters or registered
-   * object path handlers. See Connection::Private::do_dispatch() in dbus documentation
-   * for details on when handlers are run. (here: Connection::Private::do_dispatch())
-   *
-   * A PendingCall will always see exactly one reply message, unless it's
-   * cancelled with PendingCall::cancel().
-   *
-   * If -1 is passed for the timeout, a sane default timeout is used. -1 is
-   * typically the best value for the timeout for this reason, unless you want
-   * a very short or very long timeout. There is no way to avoid a timeout
-   * entirely, other than passing INT_MAX for the timeout to mean "very long
-   * timeout." libdbus clamps an INT_MAX timeout down to a few hours timeout though.
-   *
-   * \param msg The Message to write.
-   * \param timeout Timeout in milliseconds (omit for default).
-   * \throw ErrorNoMemory
-   */
-  PendingCall send_async(Message &msg, int timeout = -1);
-
-  void request_name(const char *name, int flags = 0);
-
-  unsigned long sender_unix_uid(const char *sender);
-
-  /*!
-   * \brief Asks the bus whether a certain name has an owner.
-   *
-   * Using this can easily result in a race condition, since an owner can appear
-   * or disappear after you call this.
-   *
-   * If you want to request a name, just request it; if you want to avoid
-   * replacing a current owner, don't specify DBUS_NAME_FLAG_REPLACE_EXISTING
-   * and you will get an error if there's already an owner.
-   *
-   * \param name The name.
-   * \throw Error
-   */
-  bool has_name(const char *name);
-
-  /*!
-   * \brief Starts a service that will request ownership of the given name.
-   *
-   * The returned result will be one of be one of DBUS_START_REPLY_SUCCESS or
-   * DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you don't
-   * care about the result.
-   *
-   * The flags parameter is for future expansion, currently you should specify 0.
-   *
-   * It's often easier to avoid explicitly starting services, and just send a
-   * method call to the service's bus name instead. Method calls start a service
-   * to handle them by default unless you call dbus_message_set_auto_start() to
-   * disable this behavior.
-   *
-   * \todo dbus_message_set_auto_start() not yet wrapped!
-   */
-  bool start_service(const char *name, unsigned long flags);
-
-  const std::vector<std::string>& names();
-
-  void set_timeout(int timeout);
-
-  int get_timeout();
+	static Connection SystemBus();
+
+	static Connection SessionBus();
+
+	static Connection ActivationBus();
+
+	struct Private;
+
+	typedef std::list<Private*> PrivatePList;
+
+	Connection( Private* );
+
+	Connection( const char* address, bool priv = true );
+
+	Connection( const Connection& c );
+
+	virtual ~Connection();
+
+	Dispatcher* setup( Dispatcher* );
+
+	bool operator == ( const Connection& ) const;
+
+	/*!
+	 * \brief Adds a match rule to match messages going through the message bus.
+	 *
+	 * The "rule" argument is the string form of a match rule.
+	 *
+	 * If you pass NULL for the error, this function will not block; the match 
+	 * thus won't be added until you flush the connection, and if there's an error 
+	 * adding the match (only possible error is lack of resources in the bus), you
+	 * won't find out about it.
+	 *
+	 * Normal API conventions would have the function return a boolean value 
+	 * indicating whether the error was set, but that would require blocking always 
+	 * to determine the return value.
+	 *
+	 * The AddMatch method is fully documented in the D-Bus specification. For 
+	 * quick reference, the format of the match rules is discussed here, but the 
+	 * specification is the canonical version of this information.
+	 *
+	 * Rules are specified as a string of comma separated key/value pairs. An 
+	 * example is "type='signal',sender='org.freedesktop.DBus', 
+	 * interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'"
+	 *
+	 * Possible keys you can match on are type, sender, interface, member, path, 
+	 * destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). 
+	 * Omitting a key from the rule indicates a wildcard match. For instance omitting 
+	 * the member from a match rule but adding a sender would let all messages from
+	 * that sender through regardless of the member.
+	 *
+	 * Matches are inclusive not exclusive so as long as one rule matches the
+	 * message will get through. It is important to note this because every time a
+	 * essage is received the application will be paged into memory to process it.
+	 * This can cause performance problems such as draining batteries on embedded platforms.
+	 *
+	 * If you match message args ('arg0', 'arg1', and so forth) only string arguments 
+	 * will match. That is, arg0='5' means match the string "5" not the integer 5.
+	 *
+	 * Currently there is no way to match against non-string arguments.
+	 *
+	 * Matching on interface is tricky because method call messages only optionally
+	 * specify the interface. If a message omits the interface, then it will NOT
+	 * match if the rule specifies an interface name. This means match rules on 
+	 * method calls should not usually give an interface.
+	 *
+	 * However, signal messages are required to include the interface so when 
+	 * matching signals usually you should specify the interface in the match rule.
+	 *
+	 * For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER.
+	 *
+	 * Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes.
+	 *
+	 * Both of these maximums are much higher than you're likely to need, they only 
+	 * exist because the D-Bus bus daemon has fixed limits on all resource usage.
+	 *
+	 * \param rule Textual form of match rule.
+	 * \throw Error
+	 */
+	void add_match( const char* rule );
+
+	/*!
+	 * \brief Removes a previously-added match rule "by value" (the most 
+	 *        recently-added identical rule gets removed).
+	 *
+	 * The "rule" argument is the string form of a match rule.
+	 *
+	 * The bus compares match rules semantically, not textually, so whitespace and 
+	 * ordering don't have to be identical to the rule you passed to add_match().
+	 *
+	 * \param rule Textual form of match rule.
+	 * \throw Error
+	 */
+	void remove_match( const char* rule );
+
+	/*!
+	 * \brief Adds a message filter.
+	 *
+	 * Filters are handlers that are run on all incoming messages, prior to the 
+	 * objects registered with ObjectAdaptor::register_obj(). Filters are
+	 * run in the order that they were added. The same handler can be added as a 
+	 * filter more than once, in which case it will be run more than once. Filters 
+	 * added during a filter callback won't be run on the message being processed.
+	 *
+	 * \param s The MessageSlot to add.
+	 */
+	bool add_filter( MessageSlot& s);
+
+	/*!
+	 * \brief Removes a previously-added message filter.
+	 *
+	 * It is a programming error to call this function for a handler that has not 
+	 * been added as a filter. If the given handler was added more than once, only 
+	 * one instance of it will be removed (the most recently-added instance).
+	 *
+	 * \param s The MessageSlot to remove.
+	 */
+	void remove_filter( MessageSlot& s);
+
+	/*!
+	 * \brief Sets the unique name of the connection, as assigned by the message bus.
+	 *
+	 * Can only be used if you registered with the bus manually (i.e. if you did 
+	 * not call register_bus()). Can only be called once per connection. After 
+	 * the unique name is set, you can get it with unique_name(void).
+	 *
+	 * The only reason to use this function is to re-implement the equivalent of 
+	 * register_bus() yourself. One (probably unusual) reason to do that might 
+	 * be to do the bus registration call asynchronously instead of synchronously.
+	 *
+	 * \note Just use dbus_bus_get() or dbus_bus_get_private(), or worst case 
+	 *       register_bus(), instead of messing with this function. There's 
+	 *       really no point creating pain for yourself by doing things manually.
+	 *       (Not sure if this is yet wrapped.)
+	 * 
+	 * It's hard to use this function safely on shared connections (created by 
+	 * Connection()) in a multithreaded application, because only one 
+	 * registration attempt can be sent to the bus. If two threads are both 
+	 * sending the registration message, there is no mechanism in libdbus itself 
+	 * to avoid sending it twice.
+	 *
+	 * Thus, you need a way to coordinate which thread sends the registration 
+	 * attempt; which also means you know which thread will call 
+	 * unique_name(const char*). If you don't know about all threads in the app 
+	 * (for example, if some libraries you're using might start libdbus-using 
+	 * threads), then you need to avoid using this function on shared connections.
+	 *
+	 * \param n The unique name.
+	 */
+	bool unique_name( const char* n );
+
+	/*!
+	 * \brief Gets the unique name of the connection as assigned by the message bus.
+	 *
+	 * Only possible after the connection has been registered with the message bus. 
+	 * All connections returned by dbus_bus_get() or dbus_bus_get_private() have 
+	 * been successfully registered. (Not sure if this is yet wrapped.)
+	 *
+	 * The name remains valid until the connection is freed, and should not be
+	 * freed by the caller.
+	 *
+	 * Other than dbus_bus_get(), there are two ways to set the unique name; one 
+	 * is register_bus(), the other is unique_name(const char*). You are 
+	 * responsible for calling unique_name(const char*) if you register by hand 
+	 * instead of using register_bus().
+	 */
+	const char* unique_name() const;
+
+	/*!
+	 * \brief Registers a connection with the bus.
+	 *
+	 * This must be the first thing an application does when connecting to the 
+	 * message bus. If registration succeeds, the unique name will be set, and 
+	 * can be obtained using unique_name(void).
+	 *
+	 * This function will block until registration is complete.
+	 *
+	 * If the connection has already registered with the bus (determined by 
+	 * checking whether unique_name(void) returns a non-NULL value), 
+	 * then this function does nothing.
+	 *
+	 * If you use dbus_bus_get() or dbus_bus_get_private() this function will be 
+	 * called for you.  (Not sure if this is yet wrapped.)
+	 *
+	 * \note Just use dbus_bus_get() or dbus_bus_get_private() instead of 
+	 * register_bus() and save yourself some pain. Using register_bus()
+	 * manually is only useful if you have your own custom message bus not found 
+	 * in DBusBusType.
+	 *
+	 * If you open a bus connection by the contructor of Connection() you will have to register_bus() 
+	 * yourself, or make the appropriate registration method calls yourself. If 
+	 * you send the method calls yourself, call unique_name(const char*) with 
+	 * the unique bus name you get from the bus.
+	 *
+	 * For shared connections (created with dbus_connection_open()) in a 
+	 * multithreaded application, you can't really make the registration calls 
+	 * yourself, because you don't know whether some other thread is also 
+	 * registering, and the bus will kick you off if you send two registration
+	 * messages. (TODO: how is this done in the wrapper?)
+	 *
+	 * If you use register_bus() however, there is a lock that keeps both
+	 * apps from registering at the same time.
+	 *
+	 * The rule in a multithreaded app, then, is that register_bus() must be 
+	 * used to register, or you need to have your own locks that all threads in 
+	 * the app will respect.
+	 *
+	 * In a single-threaded application you can register by hand instead of using 
+	 * register_bus(), as long as you check unique_name(void) to 
+	 * see if a unique name has already been stored by another thread before you 
+	 * send the registration messages.
+	 */
+	bool register_bus();
+
+	/*!
+	 * \brief Gets whether the connection is currently open.
+	 *
+	 * A connection may become disconnected when the remote application closes its 
+	 * end, or exits; a connection may also be disconnected with disconnect().
+	 *
+	 * There are not separate states for "closed" and "disconnected," the two 
+	 * terms are synonymous.
+	 *
+	 * \return true If the connection is still alive. 
+	 */
+	bool connected() const;
+
+	/*!
+	 * \brief Closes a private connection, so no further data can be sent or received.
+	 *
+	 * This disconnects the transport (such as a socket) underlying the connection.
+	 *
+	 * Attempts to send messages after closing a connection are safe, but will
+	 * result in error replies generated locally in libdbus.
+	 *
+	 * This function does not affect the connection's reference count. It's safe 
+	 * to close a connection more than once; all calls after the first do nothing.
+	 * It's impossible to "reopen" a connection, a new connection must be created. 
+	 * This function may result in a call to the DBusDispatchStatusFunction set 
+	 * with Private::init(), as the disconnect 
+	 * message it generates needs to be dispatched.
+	 *
+	 * If a connection is dropped by the remote application, it will close itself.
+	 *
+	 * You must close a connection prior to releasing the last reference to the 
+	 * connection. 
+	 *
+	 * You may not close a shared connection. Connections created with 
+	 * dbus_connection_open() or dbus_bus_get() are shared. These connections are 
+	 * owned by libdbus, and applications should only unref them, never close them. 
+	 * Applications can know it is safe to unref these connections because libdbus 
+	 * will be holding a reference as long as the connection is open. Thus, either
+	 * the connection is closed and it is OK to drop the last reference, or the 
+	 * connection is open and the app knows it does not have the last reference.
+	 *
+	 * Connections created with dbus_connection_open_private() or 
+	 * dbus_bus_get_private() are not kept track of or referenced by libdbus. 
+	 * The creator of these connections is responsible for calling
+	 * dbus_connection_close() prior to releasing the last reference, if the 
+	 * connection is not already disconnected.
+	 *
+	 * \todo dbus_connection_disconnect() was removed in dbus 0.9x. Maybe this 
+	 *       function should be renamed to close().
+	 */
+	void disconnect();
+
+	/*!
+	 * \brief Set whether _exit() should be called when the connection receives a
+	 *        disconnect signal.
+	 *
+	 * The call to _exit() comes after any handlers for the disconnect signal run; 
+	 * handlers can cancel the exit by calling this function.
+	 *
+	 * By default, exit_on_disconnect is false; but for message bus connections 
+	 * returned from dbus_bus_get() it will be toggled on by default.
+	 *
+	 * \param exit true If _exit() should be called after a disconnect signal.
+	 */
+	void exit_on_disconnect( bool exit );
+
+	/*!
+	 * \brief Blocks until the outgoing message queue is empty.
+	 */
+	void flush();
+
+	/*!
+	 * \brief Adds a message to the outgoing message queue.
+	 *
+	 * Does not block to write the message to the network; that happens 
+	 * asynchronously. To force the message to be written, call 
+	 * dbus_connection_flush(). Because this only queues the message, the only 
+	 * reason it can fail is lack of memory. Even if the connection is disconnected, 
+	 * no error will be returned.
+	 *
+	 * If the function fails due to lack of memory, it returns FALSE. The function 
+	 * will never fail for other reasons; even if the connection is disconnected, 
+	 * you can queue an outgoing message, though obviously it won't be sent.
+	 *
+	 * The message serial is used by the remote application to send a reply; see 
+	 * Message::serial() or the D-Bus specification.
+	 *
+	 * \param msg The Message to write.
+	 * \param serial Return location for message serial, or NULL if you don't care.
+	 * \return true On success.
+	 */
+	bool send( const Message& msg, unsigned int* serial = NULL );
+
+	/*!
+	 * \brief Sends a message and blocks a certain time period while waiting for a reply.
+	 *
+	 * This function does not reenter the main loop, i.e. messages other than the 
+	 * reply are queued up but not processed. This function is used to invoke 
+	 * method calls on a remote object.
+	 *
+	 * If a normal reply is received, it is returned, and removed from the 
+	 * incoming message queue. If it is not received, NULL is returned and the 
+	 * error is set to DBUS_ERROR_NO_REPLY. If an error reply is received, it is 
+	 * converted to a DBusError and returned as an error, then the reply message 
+	 * is deleted and NULL is returned. If something else goes wrong, result is
+	 * set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED.
+	 * 
+	 * \warning While this function blocks the calling thread will not be 
+	 *          processing the incoming message queue. This means you can end up 
+	 *          deadlocked if the application you're talking to needs you to reply
+	 *          to a method. To solve this, either avoid the situation, block in a 
+	 *          separate thread from the main connection-dispatching thread, or
+	 *          use PendingCall to avoid blocking.
+	 *
+	 * \param msg The Message to write.
+	 * \param timeout Timeout in milliseconds (omit for default).
+	 * \return The reply Message, which may be an ErrorMessage.
+	 * \throw Error
+	 */
+	Message send_blocking( Message& msg, int timeout = -1);
+    
+	/*!
+	 * \brief Queues a message to send, as with send(), but also 
+	 *        returns a DBus::PendingCall used to receive a reply to the message.
+	 *
+	 * If no reply is received in the given timeout_milliseconds, this function 
+	 * expires the pending reply and generates a synthetic error reply (generated 
+	 * in-process, not by the remote application) indicating that a timeout occurred.
+	 *
+	 * A PendingCall will see a reply message before any filters or registered
+	 * object path handlers. See Connection::Private::do_dispatch() in dbus documentation
+	 * for details on when handlers are run. (here: Connection::Private::do_dispatch())
+	 *
+	 * A PendingCall will always see exactly one reply message, unless it's 
+	 * cancelled with PendingCall::cancel().
+	 *
+	 * If -1 is passed for the timeout, a sane default timeout is used. -1 is 
+	 * typically the best value for the timeout for this reason, unless you want 
+	 * a very short or very long timeout. There is no way to avoid a timeout
+	 * entirely, other than passing INT_MAX for the timeout to mean "very long 
+	 * timeout." libdbus clamps an INT_MAX timeout down to a few hours timeout though.
+	 *
+	 * \param msg The Message to write.
+	 * \param timeout Timeout in milliseconds (omit for default).
+	 * \return The PendingCall. The PendingCall::reply_handler() method can be used to
+	 * set a callback to be invoked when the reply is received. The pending
+	 * call is owned by the application's ObjectProxy class. Once
+	 * the handler is done with the PendingCall, it should dispose of it by
+	 * calling InterfaceProxy::remove_pending_call(). The pending
+	 * call is <em>not</em> cancelled when the PendingCall object is deleted.
+	 * Instead, the PendingCall::cancel() method must be used.
+	 * \throw ErrorNoMemory
+	 */
+	PendingCall *send_async(Message& msg, int timeout = -1);
+
+        /*!
+         *\brief Request a name from DBus.
+         *
+         * Request ownership of a name. The name and flags are passed
+         * on to the lower-layer.
+         *
+         * Unless you are doing something unusual, you should use
+         * acquire_name instead of this method.
+         *
+         * \param name The name to request ownership of.
+         * \param flags Flags to be passed to dbus_bus_request_name.
+         */
+	void request_name( const char* name, int flags = 0 )
+	    __attribute__((__deprecated__));
+
+        /*!
+         *\brief Acquire a name from DBus.
+         *
+         * Request ownership of a name. Return true if the name was
+         * acquired, and false otherwise.
+         *
+         * \return True if the name was acquired, and false otherwise.
+         */
+	bool acquire_name( const char* name )
+	    __attribute__((__warn_unused_result__));
+
+	unsigned long sender_unix_uid(const char *sender);
+
+	/*!
+	 * \brief Asks the bus whether a certain name has an owner.
+	 *
+	 * Using this can easily result in a race condition, since an owner can appear 
+	 * or disappear after you call this.
+	 *
+	 * If you want to request a name, just request it; if you want to avoid 
+	 * replacing a current owner, don't specify DBUS_NAME_FLAG_REPLACE_EXISTING 
+	 * and you will get an error if there's already an owner.
+	 * 
+	 * \param name The name.
+	 * \throw Error
+	 */
+	bool has_name( const char* name );
+
+	/*!
+	 * \brief Starts a service that will request ownership of the given name.
+	 *
+	 * The returned result will be one of be one of DBUS_START_REPLY_SUCCESS or 
+	 * DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you don't 
+	 * care about the result.
+	 * 
+	 * The flags parameter is for future expansion, currently you should specify 0.
+	 *
+	 * It's often easier to avoid explicitly starting services, and just send a 
+	 * method call to the service's bus name instead. Method calls start a service
+	 * to handle them by default unless you call dbus_message_set_auto_start() to 
+	 * disable this behavior.
+	 *
+	 * \todo dbus_message_set_auto_start() not yet wrapped!
+	 */
+	bool start_service( const char* name, unsigned long flags );
+
+	const std::vector<std::string>& names();
+	
+	void set_timeout(int timeout);
+	
+	int get_timeout();
 
 private:
 
-  DXXAPILOCAL void init();
+	DXXAPILOCAL void init();
+	DXXAPILOCAL int _request_name( const char* name, int flags );
 
 private:
 
-  RefPtrI<Private> _pvt;
-  int _timeout;
+	RefPtrI<Private> _pvt;
+	int _timeout;
 
-  friend class ObjectAdaptor; // needed in order to register object paths for a connection
+friend class ObjectAdaptor; // needed in order to register object paths for a connection
 };
 
 } /* namespace DBus */
diff --git a/include/dbus-c++/dbus.h b/include/dbus-c++/dbus.h
index 80893cb..7dfc164 100644
--- a/include/dbus-c++/dbus.h
+++ b/include/dbus-c++/dbus.h
@@ -41,6 +41,5 @@
 #include "eventloop.h"
 #include "eventloop-integration.h"
 #include "introspection.h"
-#include "pipe.h"
 
 #endif//__DBUSXX_DBUS_H
diff --git a/include/dbus-c++/debug.h b/include/dbus-c++/debug.h
index 3a79b19..e66c79b 100644
--- a/include/dbus-c++/debug.h
+++ b/include/dbus-c++/debug.h
@@ -27,8 +27,7 @@
 
 #include "api.h"
 
-namespace DBus
-{
+namespace DBus {
 
 typedef void (*LogFunction)(const char *format, ...);
 
diff --git a/include/dbus-c++/dispatcher.h b/include/dbus-c++/dispatcher.h
index b5b5536..1b2b1d2 100644
--- a/include/dbus-c++/dispatcher.h
+++ b/include/dbus-c++/dispatcher.h
@@ -29,158 +29,156 @@
 #include "connection.h"
 #include "eventloop.h"
 
-namespace DBus
-{
+namespace DBus {
 
 class DXXAPI Timeout
 {
 public:
 
-  class Internal;
-
-  Timeout(Internal *i);
-
-  virtual ~Timeout() {}
-
-  /*!
-   * \brief Gets the timeout interval.
-   *
-   * The handle() should be called each time this interval elapses,
-   * starting after it elapses once.
-   *
-   * The interval may change during the life of the timeout; if so, the timeout
-   * will be disabled and re-enabled (calling the "timeout toggled function") to
-   * notify you of the change.
-   *
-   * return The interval in miliseconds.
-   */
-  int interval() const;
-
-  bool enabled() const;
-
-  /*!
-   * \brief Calls the timeout handler for this timeout.
-   *
-   * This function should be called when the timeout occurs.
-   *
-   * If this function returns FALSE, then there wasn't enough memory to handle
-   * the timeout. Typically just letting the timeout fire again next time it
-   * naturally times out is an adequate response to that problem, but you could
-   * try to do more if you wanted.
-   *
-   * return false If there wasn't enough memory.
-   */
-  bool handle();
-
-  virtual void toggle() = 0;
+	class Internal;
+
+	Timeout(Internal *i);
+
+	virtual ~Timeout(){}
+
+	/*!
+	 * \brief Gets the timeout interval.
+	 *
+	 * The dbus_timeout_handle() should be called each time this interval elapses, 
+	 * starting after it elapses once.
+	 *
+	 * The interval may change during the life of the timeout; if so, the timeout 
+	 * will be disabled and re-enabled (calling the "timeout toggled function") to 
+	 * notify you of the change.
+	 *
+	 * return The interval in miliseconds.
+	 */
+	int interval() const;
+
+	bool enabled() const;
+
+	/*!
+	 * \brief Calls the timeout handler for this timeout.
+	 *
+	 * This function should be called when the timeout occurs.
+	 *
+	 * If this function returns FALSE, then there wasn't enough memory to handle 
+	 * the timeout. Typically just letting the timeout fire again next time it 
+	 * naturally times out is an adequate response to that problem, but you could
+	 * try to do more if you wanted.
+	 *
+	 * return false If there wasn't enough memory.
+	 */
+	bool handle();
+
+	virtual void toggle() = 0;
 
 private:
 
-  DXXAPILOCAL Timeout(const Timeout &);
+	DXXAPILOCAL Timeout(const Timeout &);
 
 private:
 
-  Internal *_int;
+	Internal *_int;
 };
 
 class DXXAPI Watch
 {
 public:
 
-  class Internal;
-
-  Watch(Internal *i);
-
-  virtual ~Watch() {}
-
-  /*!
-   * \brief A main loop could poll this descriptor to integrate dbus-c++.
-   *
-   * This function calls dbus_watch_get_socket() on win32 and
-   * dbus_watch_get_unix_fd() on all other systems. (see dbus documentation)
-   *
-   * @return The file descriptor.
-   */
-  int descriptor() const;
-
-  /*!
-   * \brief Gets flags from DBusWatchFlags indicating what conditions should be
-   *        monitored on the file descriptor.
-   *
-   * The flags returned will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE,
-   * never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include
-   * a watch for hangups, errors, and other exceptional conditions.
-   *
-   * @return The conditions to watch.
-   */
-  int flags() const;
-
-  bool enabled() const;
-
-  /*!
-   * \brief Called to notify the D-Bus library when a previously-added watch
-   *        is ready for reading or writing, or has an exception such as a hangup.
-   *
-   * If this function returns FALSE, then the file descriptor may still be
-   * ready for reading or writing, but more memory is needed in order to do the
-   * reading or writing. If you ignore the FALSE return, your application may
-   * spin in a busy loop on the file descriptor until memory becomes available,
-   * but nothing more catastrophic should happen.
-   *
-   * dbus_watch_handle() cannot be called during the DBusAddWatchFunction, as the
-   * connection will not be ready to handle that watch yet.
-   *
-   * It is not allowed to reference a DBusWatch after it has been passed to remove_function.
-   *
-   * @param flags The poll condition using DBusWatchFlags values.
-   * @return false If there wasn't enough memory.
-   */
-  bool handle(int flags);
-
-  virtual void toggle() = 0;
+	class Internal;
+
+	Watch(Internal *i);
+
+	virtual ~Watch(){}
+
+	/*!
+	 * \brief A main loop could poll this descriptor to integrate dbus-c++.
+	 *
+	 * This function calls dbus_watch_get_socket() on win32 and 
+	 * dbus_watch_get_unix_fd() on all other systems. (see dbus documentation)
+	 *
+	 * @return The file descriptor.
+	 */
+	int descriptor() const;
+
+	/*!
+	 * \brief Gets flags from DBusWatchFlags indicating what conditions should be 
+	 *        monitored on the file descriptor.
+	 *
+	 * The flags returned will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, 
+	 * never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include 
+	 * a watch for hangups, errors, and other exceptional conditions.
+	 *
+	 * @return The conditions to watch.
+	 */
+	int flags() const;
+
+	bool enabled() const;
+
+	/*! 
+	 * \brief Called to notify the D-Bus library when a previously-added watch 
+	 *        is ready for reading or writing, or has an exception such as a hangup.
+	 *
+	 * If this function returns FALSE, then the file descriptor may still be 
+	 * ready for reading or writing, but more memory is needed in order to do the 
+	 * reading or writing. If you ignore the FALSE return, your application may 
+	 * spin in a busy loop on the file descriptor until memory becomes available, 
+	 * but nothing more catastrophic should happen.
+	 *
+	 * dbus_watch_handle() cannot be called during the DBusAddWatchFunction, as the 
+	 * connection will not be ready to handle that watch yet.
+	 *
+	 * It is not allowed to reference a DBusWatch after it has been passed to remove_function.
+	 *
+	 * @param flags The poll condition using DBusWatchFlags values.
+	 * @return false If there wasn't enough memory.
+	 */
+	bool handle(int flags);
+
+	virtual void toggle() = 0;
 
 private:
 
-  DXXAPILOCAL Watch(const Watch &);
+	DXXAPILOCAL Watch(const Watch &);
 
 private:
 
-  Internal *_int;
+	Internal *_int;
 };
 
 class DXXAPI Dispatcher
 {
 public:
+	Dispatcher() : _dispatching(false) {}
 
-  virtual ~Dispatcher()
-  {}
+	virtual ~Dispatcher()
+	{}
 
-  void queue_connection(Connection::Private *);
+	void queue_connection(Connection::Private *);
 
-  void dispatch_pending();
-  bool has_something_to_dispatch();
+	void dispatch_pending();
+	bool has_something_to_dispatch();
 
-  virtual void enter() = 0;
+	virtual void enter() = 0;
 
-  virtual void leave() = 0;
+	virtual void leave() = 0;
 
-  virtual Timeout *add_timeout(Timeout::Internal *) = 0;
+	virtual Timeout *add_timeout(Timeout::Internal *) = 0;
 
-  virtual void rem_timeout(Timeout *) = 0;
+	virtual void rem_timeout(Timeout *) = 0;
 
-  virtual Watch *add_watch(Watch::Internal *) = 0;
+	virtual Watch *add_watch(Watch::Internal *) = 0;
 
-  virtual void rem_watch(Watch *) = 0;
+	virtual void rem_watch(Watch *) = 0;
 
-  struct Private;
+	struct Private;
 
 private:
-  void dispatch_pending(Connection::PrivatePList &pending_queue);
-
-  DefaultMutex _mutex_p;
-  DefaultMutex _mutex_p_copy;
 
-  Connection::PrivatePList _pending_queue;
+	DefaultMutex _mutex_p;
+	Connection::PrivatePList _pending_queue;
+	bool _dispatching;
 };
 
 extern DXXAPI Dispatcher *default_dispatcher;
@@ -192,38 +190,38 @@ class DXXAPI Mutex
 {
 public:
 
-  virtual ~Mutex() {}
+	virtual ~Mutex() {}
 
-  virtual void lock() = 0;
+	virtual void lock() = 0;
 
-  virtual void unlock() = 0;
+	virtual void unlock() = 0;
 
-  struct Internal;
+	struct Internal;
 
 protected:
 
-  Internal *_int;
+	Internal *_int;
 };
 
 class DXXAPI CondVar
 {
 public:
 
-  virtual ~CondVar() {}
+	virtual ~CondVar() {}
 
-  virtual void wait(Mutex *) = 0;
+	virtual void wait(Mutex *) = 0;
 
-  virtual bool wait_timeout(Mutex *, int timeout) = 0;
+	virtual bool wait_timeout(Mutex *, int timeout) = 0;
 
-  virtual void wake_one() = 0;
+	virtual void wake_one() = 0;
 
-  virtual void wake_all() = 0;
+	virtual void wake_all() = 0;
 
-  struct Internal;
+	struct Internal;
 
 protected:
 
-  Internal *_int;
+	Internal *_int;
 };
 
 typedef Mutex *(*MutexNewFn)();
@@ -247,70 +245,84 @@ typedef void (*CondVarWakeAllFn)(CondVar *cv);
 void DXXAPI _init_threading();
 
 void DXXAPI _init_threading(
-  MutexNewFn, MutexFreeFn, MutexLockFn, MutexUnlockFn,
-  CondVarNewFn, CondVarFreeFn, CondVarWaitFn, CondVarWaitTimeoutFn, CondVarWakeOneFn, CondVarWakeAllFn
+	MutexNewFn, MutexFreeFn, MutexLockFn, MutexUnlockFn,
+	CondVarNewFn, CondVarFreeFn, CondVarWaitFn, CondVarWaitTimeoutFn, CondVarWakeOneFn, CondVarWakeAllFn
 );
 
 template<class Mx, class Cv>
 struct Threading
 {
-  static void init()
-  {
-    _init_threading(
-      mutex_new, mutex_free, mutex_lock, mutex_unlock,
-      condvar_new, condvar_free, condvar_wait, condvar_wait_timeout, condvar_wake_one, condvar_wake_all
-    );
-  }
-
-  static Mutex *mutex_new()
-  {
-    return new Mx;
-  }
-
-  static void mutex_free(Mutex *mx)
-  {
-    delete mx;
-  }
-
-  static void mutex_lock(Mutex *mx)
-  {
-    mx->lock();
-  }
-
-  static void mutex_unlock(Mutex *mx)
-  {
-    mx->unlock();
-  }
-
-  static CondVar *condvar_new()
-  {
-    return new Cv;
-  }
-
-  static void condvar_free(CondVar *cv)
-  {
-    delete cv;
-  }
-
-  static void condvar_wait(CondVar *cv, Mutex *mx)
-  {
-    cv->wait(mx);
-  }
-
-  static bool condvar_wait_timeout(CondVar *cv, Mutex *mx, int timeout)
-  {
-    return cv->wait_timeout(mx, timeout);
-  }
-
-  static void condvar_wake_one(CondVar *cv)
-  {
-    cv->wake_one();
-  }
-
-  static void condvar_wake_all(CondVar *cv)
-  {
-    cv->wake_all();
-  }
+	static void init()
+	{
+		_init_threading(
+			mutex_new, mutex_free, mutex_lock, mutex_unlock,
+			condvar_new, condvar_free, condvar_wait, condvar_wait_timeout, condvar_wake_one, condvar_wake_all
+		);
+	}
+
+	static Mutex *mutex_new()
+	{
+		return new Mx;
+	}
+
+#ifndef DBUS_HAS_RECURSIVE_MUTEX
+	static bool mutex_free(Mutex *mx)
+	{
+		delete mx;
+		return false;
+	}
+
+	static bool mutex_lock(Mutex *mx)
+	{
+		mx->lock();
+		return false;
+	}
+#else
+	static void mutex_free(Mutex *mx)
+	{
+		delete mx;
+	}
+
+	static void mutex_lock(Mutex *mx)
+	{
+		mx->lock();
+	}
+#endif//DBUS_HAS_RECURSIVE_MUTEX
+
+	static void mutex_unlock(Mutex *mx)
+	{
+		mx->unlock();
+	}
+
+	static CondVar *condvar_new()
+	{
+		return new Cv;
+	}
+
+	static void condvar_free(CondVar *cv)
+	{
+		delete cv;
+	}
+
+	static void condvar_wait(CondVar *cv, Mutex *mx)
+	{
+		cv->wait(mx);
+	}
+
+	static bool condvar_wait_timeout(CondVar *cv, Mutex *mx, int timeout)
+	{
+		return cv->wait_timeout(mx, timeout);
+	}
+
+	static void condvar_wake_one(CondVar *cv)
+	{
+		cv->wake_one();
+	}
+
+	static void condvar_wake_all(CondVar *cv)
+	{
+		cv->wake_all();
+	}
 };
 
 } /* namespace DBus */
diff --git a/include/dbus-c++/ecore-integration.h b/include/dbus-c++/ecore-integration.h
index 4201442..b475533 100644
--- a/include/dbus-c++/ecore-integration.h
+++ b/include/dbus-c++/ecore-integration.h
@@ -31,11 +31,9 @@
 #include "dispatcher.h"
 #include "Ecore.h"
 
-namespace DBus
-{
+namespace DBus {
 
-namespace Ecore
-{
+namespace Ecore {
 
 class BusDispatcher;
 
@@ -43,72 +41,70 @@ class DXXAPI BusTimeout : public Timeout
 {
 private:
 
-  BusTimeout(Timeout::Internal *);
+	BusTimeout( Timeout::Internal*);
 
-  ~BusTimeout();
+	~BusTimeout();
 
-  void toggle();
+	void toggle();
 
-  static Eina_Bool timeout_handler(void *);
+	static int timeout_handler( void* );
 
-  void _enable();
+	void _enable();
 
-  void _disable();
+	void _disable();
 
 private:
   Ecore_Timer *_etimer;
 
-  friend class BusDispatcher;
+friend class BusDispatcher;
 };
 
 class DXXAPI BusWatch : public Watch
 {
 private:
 
-  BusWatch(Watch::Internal *);
+	BusWatch( Watch::Internal*);
 
-  ~BusWatch();
+	~BusWatch();
 
-  void toggle();
+	void toggle();
 
-  static Eina_Bool watch_check(void *data, Ecore_Fd_Handler *fdh);
-  static Eina_Bool watch_prepare(void *data, Ecore_Fd_Handler *fdh);
-  static Eina_Bool watch_dispatch(void *data, Ecore_Fd_Handler *fdh);
+	static int watch_handler_read ( void*, Ecore_Fd_Handler *fdh);
+    
+  static int watch_handler_error ( void*, Ecore_Fd_Handler *fdh);
 
-  void _enable();
+	void _enable();
 
-  void _disable();
-
-  void data(Ecore::BusDispatcher *bd);
+	void _disable();
 
 private:
-  Ecore_Fd_Handler *fd_handler;
-  Ecore::BusDispatcher *_bd;
+  Ecore_Fd_Handler *fd_handler_read;
+  Ecore_Fd_Handler *fd_handler_error;
 
-  friend class BusDispatcher;
+friend class BusDispatcher;
 };
 
 class DXXAPI BusDispatcher : public Dispatcher
 {
 public:
-  BusDispatcher();
+	BusDispatcher() {}
 
-  void enter() {}
+	void attach();
 
-  void leave() {}
+	void enter() {}
 
-  Timeout *add_timeout(Timeout::Internal *);
+	void leave() {}
 
-  void rem_timeout(Timeout *);
+	Timeout* add_timeout( Timeout::Internal* );
 
-  Watch *add_watch(Watch::Internal *);
+	void rem_timeout( Timeout* );
 
-  void rem_watch(Watch *);
+	Watch* add_watch( Watch::Internal* );
 
-  static Eina_Bool dispatch(void *data, Ecore_Fd_Handler *fdh);
-  static Eina_Bool check(void *data, Ecore_Fd_Handler *fdh);
+	void rem_watch( Watch* );
 
 private:
+
 };
 
 } /* namespace Ecore */
diff --git a/include/dbus-c++/error.h b/include/dbus-c++/error.h
index 57a6471..011a50f 100644
--- a/include/dbus-c++/error.h
+++ b/include/dbus-c++/error.h
@@ -30,255 +30,260 @@
 
 #include <exception>
 
-namespace DBus
-{
+namespace DBus {
 
 class Message;
-class InternalError;
+struct InternalError;
 
 class DXXAPI Error : public std::exception
 {
 public:
 
-  Error();
-
-  Error(InternalError &);
+	Error();
 
-  Error(const char *name, const char *message);
+	Error(InternalError &);
 
-  Error(Message &);
+	Error(const char *name, const char *message);
+	
+	Error(Message &);
 
-  ~Error() throw();
+	~Error() throw();
 
-  const char *what() const throw();
+	const char *what() const throw();
 
-  const char *name() const;
+	const char *name() const;
 
-  const char *message() const;
+	const char *message() const;
 
-  void set(const char *name, const char *message);
-  // parameters MUST be static strings
+	void set(const char *name, const char *message);
 
-  bool is_set() const;
+	bool is_set() const;
 
-  operator bool() const
-  {
-    return is_set();
-  }
+	operator bool() const
+	{
+		return is_set();
+	}
 
 private:
 
-  RefPtrI<InternalError> _int;
+	RefPtrI<InternalError> _int;
 };
 
 struct DXXAPI ErrorFailed : public Error
 {
-  ErrorFailed(const char *message)
-    : Error("org.freedesktop.DBus.Error.Failed", message)
-  {}
+	ErrorFailed(const char *message)
+	: Error("org.freedesktop.DBus.Error.Failed", message)
+	{}
 };
 
 struct DXXAPI ErrorNoMemory : public Error
 {
-  ErrorNoMemory(const char *message)
-    : Error("org.freedesktop.DBus.Error.NoMemory", message)
-  {}
+	ErrorNoMemory(const char *message)
+	: Error("org.freedesktop.DBus.Error.NoMemory", message)
+	{}
 };
 
 struct DXXAPI ErrorServiceUnknown : public Error
 {
-  ErrorServiceUnknown(const char *message)
-    : Error("org.freedesktop.DBus.Error.ServiceUnknown", message)
-  {}
+	ErrorServiceUnknown(const char *message)
+	: Error("org.freedesktop.DBus.Error.ServiceUnknown", message)
+	{}
 };
 
 struct DXXAPI ErrorNameHasNoOwner : public Error
 {
-  ErrorNameHasNoOwner(const char *message)
-    : Error("org.freedesktop.DBus.Error.NameHasNoOwner", message)
-  {}
+	ErrorNameHasNoOwner(const char *message)
+	: Error("org.freedesktop.DBus.Error.NameHasNoOwner", message)
+	{}
 };
 
 struct DXXAPI ErrorNoReply : public Error
 {
-  ErrorNoReply(const char *message)
-    : Error("org.freedesktop.DBus.Error.NoReply", message)
-  {}
+	ErrorNoReply(const char *message)
+	: Error("org.freedesktop.DBus.Error.NoReply", message)
+	{}
 };
 
 struct DXXAPI ErrorIOError : public Error
 {
-  ErrorIOError(const char *message)
-    : Error("org.freedesktop.DBus.Error.IOError", message)
-  {}
+	ErrorIOError(const char *message)
+	: Error("org.freedesktop.DBus.Error.IOError", message)
+	{}
 };
 
 struct DXXAPI ErrorBadAddress : public Error
 {
-  ErrorBadAddress(const char *message)
-    : Error("org.freedesktop.DBus.Error.BadAddress", message)
-  {}
+	ErrorBadAddress(const char *message)
+	: Error("org.freedesktop.DBus.Error.BadAddress", message)
+	{}
 };
 
 struct DXXAPI ErrorNotSupported : public Error
 {
-  ErrorNotSupported(const char *message)
-    : Error("org.freedesktop.DBus.Error.NotSupported", message)
-  {}
+	ErrorNotSupported(const char *message)
+	: Error("org.freedesktop.DBus.Error.NotSupported", message)
+	{}
 };
 
 struct DXXAPI ErrorLimitsExceeded : public Error
 {
-  ErrorLimitsExceeded(const char *message)
-    : Error("org.freedesktop.DBus.Error.LimitsExceeded", message)
-  {}
+	ErrorLimitsExceeded(const char *message)
+	: Error("org.freedesktop.DBus.Error.LimitsExceeded", message)
+	{}
 };
 
 struct DXXAPI ErrorAccessDenied : public Error
 {
-  ErrorAccessDenied(const char *message)
-    : Error("org.freedesktop.DBus.Error.AccessDenied", message)
-  {}
+	ErrorAccessDenied(const char *message)
+	: Error("org.freedesktop.DBus.Error.AccessDenied", message)
+	{}
 };
 
 struct DXXAPI ErrorAuthFailed : public Error
 {
-  ErrorAuthFailed(const char *message)
-    : Error("org.freedesktop.DBus.Error.AuthFailed", message)
-  {}
+	ErrorAuthFailed(const char *message)
+	: Error("org.freedesktop.DBus.Error.AuthFailed", message)
+	{}
 };
 
 struct DXXAPI ErrorNoServer : public Error
 {
-  ErrorNoServer(const char *message)
-    : Error("org.freedesktop.DBus.Error.NoServer", message)
-  {}
+	ErrorNoServer(const char *message)
+	: Error("org.freedesktop.DBus.Error.NoServer", message)
+	{}
 };
 
 struct DXXAPI ErrorTimeout : public Error
 {
-  ErrorTimeout(const char *message)
-    : Error("org.freedesktop.DBus.Error.Timeout", message)
-  {}
+	ErrorTimeout(const char *message)
+	: Error("org.freedesktop.DBus.Error.Timeout", message)
+	{}
 };
 
 struct DXXAPI ErrorNoNetwork : public Error
 {
-  ErrorNoNetwork(const char *message)
-    : Error("org.freedesktop.DBus.Error.NoNetwork", message)
-  {}
+	ErrorNoNetwork(const char *message)
+	: Error("org.freedesktop.DBus.Error.NoNetwork", message)
+	{}
 };
 
 struct DXXAPI ErrorAddressInUse : public Error
 {
-  ErrorAddressInUse(const char *message)
-    : Error("org.freedesktop.DBus.Error.AddressInUse", message)
-  {}
+	ErrorAddressInUse(const char *message)
+	: Error("org.freedesktop.DBus.Error.AddressInUse", message)
+	{}
 };
 
 struct DXXAPI ErrorDisconnected : public Error
 {
-  ErrorDisconnected(const char *message)
-    : Error("org.freedesktop.DBus.Error.Disconnected", message)
-  {}
+	ErrorDisconnected(const char *message)
+	: Error("org.freedesktop.DBus.Error.Disconnected", message)
+	{}
 };
 
 struct DXXAPI ErrorInvalidArgs : public Error
 {
-  ErrorInvalidArgs(const char *message)
-    : Error("org.freedesktop.DBus.Error.InvalidArgs", message)
-  {}
+	ErrorInvalidArgs(const char *message)
+	: Error("org.freedesktop.DBus.Error.InvalidArgs", message)
+	{}
 };
 
 struct DXXAPI ErrorFileNotFound : public Error
 {
-  ErrorFileNotFound(const char *message)
-    : Error("org.freedesktop.DBus.Error.FileNotFound", message)
-  {}
+	ErrorFileNotFound(const char *message)
+	: Error("org.freedesktop.DBus.Error.FileNotFound", message)
+	{}
 };
 
 struct DXXAPI ErrorUnknownMethod : public Error
 {
-  ErrorUnknownMethod(const char *message)
-    : Error("org.freedesktop.DBus.Error.UnknownMethod", message)
-  {}
+	ErrorUnknownMethod(const char *message)
+	: Error("org.freedesktop.DBus.Error.UnknownMethod", message)
+	{}
 };
 
 struct DXXAPI ErrorTimedOut : public Error
 {
-  ErrorTimedOut(const char *message)
-    : Error("org.freedesktop.DBus.Error.TimedOut", message)
-  {}
+	ErrorTimedOut(const char *message)
+	: Error("org.freedesktop.DBus.Error.TimedOut", message)
+	{}
 };
 
 struct DXXAPI ErrorMatchRuleNotFound : public Error
 {
-  ErrorMatchRuleNotFound(const char *message)
-    : Error("org.freedesktop.DBus.Error.MatchRuleNotFound", message)
-  {}
+	ErrorMatchRuleNotFound(const char *message)
+	: Error("org.freedesktop.DBus.Error.MatchRuleNotFound", message)
+	{}
 };
 
 struct DXXAPI ErrorMatchRuleInvalid : public Error
 {
-  ErrorMatchRuleInvalid(const char *message)
-    : Error("org.freedesktop.DBus.Error.MatchRuleInvalid", message)
-  {}
+	ErrorMatchRuleInvalid(const char *message)
+	: Error("org.freedesktop.DBus.Error.MatchRuleInvalid", message)
+	{}
 };
 
 struct DXXAPI ErrorSpawnExecFailed : public Error
 {
-  ErrorSpawnExecFailed(const char *message)
-    : Error("org.freedesktop.DBus.Error.Spawn.ExecFailed", message)
-  {}
+	ErrorSpawnExecFailed(const char *message)
+	: Error("org.freedesktop.DBus.Error.Spawn.ExecFailed", message)
+	{}
 };
 
 struct DXXAPI ErrorSpawnForkFailed : public Error
 {
-  ErrorSpawnForkFailed(const char *message)
-    : Error("org.freedesktop.DBus.Error.Spawn.ForkFailed", message)
-  {}
+	ErrorSpawnForkFailed(const char *message)
+	: Error("org.freedesktop.DBus.Error.Spawn.ForkFailed", message)
+	{}
 };
 
 struct DXXAPI ErrorSpawnChildExited : public Error
 {
-  ErrorSpawnChildExited(const char *message)
-    : Error("org.freedesktop.DBus.Error.Spawn.ChildExited", message)
-  {}
+	ErrorSpawnChildExited(const char *message)
+	: Error("org.freedesktop.DBus.Error.Spawn.ChildExited", message)
+	{}
 };
 
 struct DXXAPI ErrorSpawnChildSignaled : public Error
 {
-  ErrorSpawnChildSignaled(const char *message)
-    : Error("org.freedesktop.DBus.Error.Spawn.ChildSignaled", message)
-  {}
+	ErrorSpawnChildSignaled(const char *message)
+	: Error("org.freedesktop.DBus.Error.Spawn.ChildSignaled", message)
+	{}
 };
 
 struct DXXAPI ErrorSpawnFailed : public Error
 {
-  ErrorSpawnFailed(const char *message)
-    : Error("org.freedesktop.DBus.Error.Spawn.Failed", message)
-  {}
+	ErrorSpawnFailed(const char *message)
+	: Error("org.freedesktop.DBus.Error.Spawn.Failed", message)
+	{}
 };
 
 struct DXXAPI ErrorInvalidSignature : public Error
 {
-  ErrorInvalidSignature(const char *message)
-    : Error("org.freedesktop.DBus.Error.InvalidSignature", message)
-  {}
+	ErrorInvalidSignature(const char *message)
+	: Error("org.freedesktop.DBus.Error.InvalidSignature", message)
+	{}
 };
 
 struct DXXAPI ErrorUnixProcessIdUnknown : public Error
 {
-  ErrorUnixProcessIdUnknown(const char *message)
-    : Error("org.freedesktop.DBus.Error.UnixProcessIdUnknown", message)
-  {}
+	ErrorUnixProcessIdUnknown(const char *message)
+	: Error("org.freedesktop.DBus.Error.UnixProcessIdUnknown", message)
+	{}
 };
 
 struct DXXAPI ErrorSELinuxSecurityContextUnknown : public Error
 {
-  ErrorSELinuxSecurityContextUnknown(const char *message)
-    : Error("org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", message)
-  {}
+	ErrorSELinuxSecurityContextUnknown(const char *message)
+	: Error("org.freedesktop.DBus.Error.SELinuxSecurityContextUnknown", message)
+	{}
+};
+
+struct DXXAPI ErrorObjectPathInUse : public Error
+{
+	ErrorObjectPathInUse(const char *message)
+	: Error("org.freedesktop.DBus.Error.ObjectPathInUse", message)
+	{}
 };
 
 } /* namespace DBus */
diff --git a/include/dbus-c++/eventloop-integration.h b/include/dbus-c++/eventloop-integration.h
index 3e44304..1b56ab5 100644
--- a/include/dbus-c++/eventloop-integration.h
+++ b/include/dbus-c++/eventloop-integration.h
@@ -25,6 +25,7 @@
 #ifndef __DBUSXX_EVENTLOOP_INTEGRATION_H
 #define __DBUSXX_EVENTLOOP_INTEGRATION_H
 
+#include <cstring>
 #include <errno.h>
 #include <unistd.h>
 #include "api.h"
@@ -32,67 +33,78 @@
 #include "util.h"
 #include "eventloop.h"
 
-namespace DBus
-{
+namespace DBus {
 
-/*
+/* 
  * Glue between the event loop and the DBus library
  */
 
 class BusDispatcher;
-class Pipe;
 
 class DXXAPI BusTimeout : public Timeout, public DefaultTimeout
 {
-  BusTimeout(Timeout::Internal *, BusDispatcher *);
+	BusTimeout(Timeout::Internal *, BusDispatcher *);
 
-  void toggle();
+	void toggle();
 
-  friend class BusDispatcher;
+friend class BusDispatcher;
 };
 
 class DXXAPI BusWatch : public Watch, public DefaultWatch
 {
-  BusWatch(Watch::Internal *, BusDispatcher *);
+	BusWatch(Watch::Internal *, BusDispatcher *);
 
-  void toggle();
+	void toggle();
 
-  friend class BusDispatcher;
+friend class BusDispatcher;
 };
 
 class DXXAPI BusDispatcher : public Dispatcher, public DefaultMainLoop
 {
 public:
-  BusDispatcher();
 
-  ~BusDispatcher() {}
+	int _pipe[2];
 
-  virtual void enter();
+	BusDispatcher() : _running(false)
+	{
+		//pipe to create a new fd used to unlock a dispatcher at any
+    // moment (used by leave function)
+		int ret = pipe(_pipe);
+		if (ret == -1) {
+                  char buffer[128]; // buffer copied in Error constructor
+                  throw Error("PipeError:errno", strerror_r(errno,
+                                                            buffer,
+                                                            sizeof(buffer)));
+                }
+		_fdunlock[0] = _pipe[0];
+		_fdunlock[1] = _pipe[1];
+		
+	}
 
-  virtual void leave();
+	~BusDispatcher()
+	{}
 
-  virtual Pipe *add_pipe(void(*handler)(const void *data, void *buffer, unsigned int nbyte), const void *data);
+	virtual void enter();
 
-  virtual void del_pipe(Pipe *pipe);
+	virtual void leave();
 
-  virtual void do_iteration();
+	virtual void do_iteration();
 
-  virtual Timeout *add_timeout(Timeout::Internal *);
+	virtual Timeout *add_timeout(Timeout::Internal *);
 
-  virtual void rem_timeout(Timeout *);
+	virtual void rem_timeout(Timeout *);
 
-  virtual Watch *add_watch(Watch::Internal *);
+	virtual Watch *add_watch(Watch::Internal *);
 
-  virtual void rem_watch(Watch *);
+	virtual void rem_watch(Watch *);
 
-  void watch_ready(DefaultWatch &);
+	void watch_ready(DefaultWatch &);
 
-  void timeout_expired(DefaultTimeout &);
+	void timeout_expired(DefaultTimeout &);
 
 private:
-  bool _running;
-  int _pipe[2];
-  std::list <Pipe *> pipe_list;
+
+	bool _running;
 };
 
 } /* namespace DBus */
diff --git a/include/dbus-c++/eventloop.h b/include/dbus-c++/eventloop.h
index 53f90a7..2475fe5 100644
--- a/include/dbus-c++/eventloop.h
+++ b/include/dbus-c++/eventloop.h
@@ -31,8 +31,7 @@
 #include "api.h"
 #include "util.h"
 
-namespace DBus
-{
+namespace DBus {
 
 /*
  * these Default *classes implement a very simple event loop which
@@ -47,62 +46,38 @@ class DXXAPI DefaultTimeout
 {
 public:
 
-  DefaultTimeout(int interval, bool repeat, DefaultMainLoop *);
-
-  virtual ~DefaultTimeout();
-
-  bool enabled()
-  {
-    return _enabled;
-  }
-  void enabled(bool e)
-  {
-    _enabled = e;
-  }
-
-  int interval()
-  {
-    return _interval;
-  }
-  void interval(int i)
-  {
-    _interval = i;
-  }
-
-  bool repeat()
-  {
-    return _repeat;
-  }
-  void repeat(bool r)
-  {
-    _repeat = r;
-  }
-
-  void *data()
-  {
-    return _data;
-  }
-  void data(void *d)
-  {
-    _data = d;
-  }
-
-  Slot<void, DefaultTimeout &> expired;
+	DefaultTimeout(int interval, bool repeat, DefaultMainLoop *);
 
-private:
+	virtual ~DefaultTimeout();
+
+	bool enabled(){ return _enabled; }
+	void enabled(bool e){ _enabled = e; }
 
-  bool _enabled;
+	int interval(){ return _interval; }
+	void interval(int i){ _interval = i; }
 
-  int _interval;
-  bool _repeat;
+	bool repeat(){ return _repeat; }
+	void repeat(bool r){ _repeat = r; }
 
-  double _expiration;
+	void *data(){ return _data; }
+	void data(void *d){ _data = d; }
+
+	Slot<void, DefaultTimeout &> expired;
+	
+private:
 
-  void *_data;
+	bool _enabled;
 
-  DefaultMainLoop *_disp;
+	int _interval;
+	bool _repeat;
 
-  friend class DefaultMainLoop;
+	double _expiration;
+
+	void *_data;
+	
+	DefaultMainLoop *_disp;
+
+friend class DefaultMainLoop;
 };
 
 typedef std::list< DefaultTimeout *> DefaultTimeouts;
@@ -111,62 +86,38 @@ class DXXAPI DefaultWatch
 {
 public:
 
-  DefaultWatch(int fd, int flags, DefaultMainLoop *);
-
-  virtual ~DefaultWatch();
-
-  bool enabled()
-  {
-    return _enabled;
-  }
-  void enabled(bool e)
-  {
-    _enabled = e;
-  }
-
-  int descriptor()
-  {
-    return _fd;
-  }
-
-  int flags()
-  {
-    return _flags;
-  }
-  void flags(int f)
-  {
-    _flags = f;
-  }
-
-  int state()
-  {
-    return _state;
-  }
-
-  void *data()
-  {
-    return _data;
-  }
-  void data(void *d)
-  {
-    _data = d;
-  }
-
-  Slot<void, DefaultWatch &> ready;
+	DefaultWatch(int fd, int flags, DefaultMainLoop *);
+
+	virtual ~DefaultWatch();
+
+	bool enabled(){ return _enabled; }
+	void enabled(bool e){ _enabled = e; }
+
+	int descriptor(){ return _fd; }
+
+	int flags(){ return _flags; }
+	void flags(int f){ _flags = f; }
+
+	int state(){ return _state; }
+
+	void *data(){ return _data; }
+	void data(void *d){ _data = d; }
+
+	Slot<void, DefaultWatch &> ready;
 
 private:
 
-  bool _enabled;
+	bool _enabled;
 
-  int _fd;
-  int _flags;
-  int _state;
+	int _fd;
+	int _flags;
+	int _state;
 
-  void *_data;
+	void *_data;
 
-  DefaultMainLoop *_disp;
+	DefaultMainLoop *_disp;
 
-  friend class DefaultMainLoop;
+friend class DefaultMainLoop;
 };
 
 typedef std::list< DefaultWatch *> DefaultWatches;
@@ -175,49 +126,46 @@ class DXXAPI DefaultMutex
 {
 public:
 
-  /*!
-   * Constructor for non recursive Mutex
-   */
-  DefaultMutex();
-
-  /*!
-   * Constructor
-   * \param recursive Set if Mutex should be recursive or not.
-   */
-  DefaultMutex(bool recursive);
+	/*!
+	 * Constructor for non recursive Mutex
+	 */
+	DefaultMutex();
 
-  ~DefaultMutex();
+	~DefaultMutex();
 
-  void lock();
+	void lock();
 
-  void unlock();
+	void unlock();
 
 private:
 
-  pthread_mutex_t _mutex;
+	pthread_mutex_t _mutex;
 };
 
 class DXXAPI DefaultMainLoop
 {
 public:
 
-  DefaultMainLoop();
+	DefaultMainLoop();
+
+	virtual ~DefaultMainLoop();
+
+	virtual void dispatch();
 
-  virtual ~DefaultMainLoop();
+protected:
 
-  virtual void dispatch();
+	int _fdunlock[2];
 
-  int _fdunlock[2];
 private:
 
-  DefaultMutex _mutex_t;
-  DefaultTimeouts _timeouts;
+	DefaultMutex _mutex_t;
+	DefaultTimeouts _timeouts;
 
-  DefaultMutex _mutex_w;
-  DefaultWatches _watches;
+	DefaultMutex _mutex_w;
+	DefaultWatches _watches;
 
-  friend class DefaultTimeout;
-  friend class DefaultWatch;
+friend class DefaultTimeout;
+friend class DefaultWatch;
 };
 
 } /* namespace DBus */
diff --git a/include/dbus-c++/glib-integration.h b/include/dbus-c++/glib-integration.h
index e6adece..0f68852 100644
--- a/include/dbus-c++/glib-integration.h
+++ b/include/dbus-c++/glib-integration.h
@@ -30,11 +30,9 @@
 #include "api.h"
 #include "dispatcher.h"
 
-namespace DBus
-{
+namespace DBus {
 
-namespace Glib
-{
+namespace Glib {
 
 class BusDispatcher;
 
@@ -42,80 +40,80 @@ class DXXAPI BusTimeout : public Timeout
 {
 private:
 
-  BusTimeout(Timeout::Internal *, GMainContext *, int);
+	BusTimeout(Timeout::Internal *, GMainContext *, int);
 
-  ~BusTimeout();
+	~BusTimeout();
 
-  void toggle();
+	void toggle();
 
-  static gboolean timeout_handler(gpointer);
+	static gboolean timeout_handler(gpointer);
 
-  void _enable();
+	void _enable();
 
-  void _disable();
+	void _disable();
 
 private:
 
-  GMainContext *_ctx;
-  int _priority;
-  GSource *_source;
+	GMainContext *_ctx;
+	int _priority;
+	GSource *_source;
 
-  friend class BusDispatcher;
+friend class BusDispatcher;
 };
 
 class DXXAPI BusWatch : public Watch
 {
 private:
 
-  BusWatch(Watch::Internal *, GMainContext *, int);
+	BusWatch(Watch::Internal *, GMainContext *, int);
 
-  ~BusWatch();
+	~BusWatch();
 
-  void toggle();
+	void toggle();
 
-  static gboolean watch_handler(gpointer);
+	static gboolean watch_handler(gpointer);
 
-  void _enable();
+	void _enable();
 
-  void _disable();
+	void _disable();
 
 private:
 
-  GMainContext *_ctx;
-  int _priority;
-  GSource *_source;
+	GMainContext *_ctx;
+	int _priority;
+	GSource *_source;
 
-  friend class BusDispatcher;
+friend class BusDispatcher;
 };
 
 class DXXAPI BusDispatcher : public Dispatcher
 {
 public:
 
-  BusDispatcher();
-  ~BusDispatcher();
+	BusDispatcher();
+	~BusDispatcher();
 
-  void attach(GMainContext *);
+	void attach(GMainContext *);
 
-  void enter() {}
+	void enter() {}
 
-  void leave() {}
+	void leave() {}
 
-  Timeout *add_timeout(Timeout::Internal *);
+	Timeout *add_timeout(Timeout::Internal *);
 
-  void rem_timeout(Timeout *);
+	void rem_timeout(Timeout *);
 
-  Watch *add_watch(Watch::Internal *);
+	Watch *add_watch(Watch::Internal *);
 
-  void rem_watch(Watch *);
+	void rem_watch(Watch *);
 
-  void set_priority(int priority);
+	void set_priority(int priority);
 
 private:
 
-  GMainContext *_ctx;
-  int _priority;
-  GSource *_source;
+	GMainContext *_ctx;
+	int _priority;
+	GSource *_source;
 };
 
 } /* namespace Glib */
diff --git a/include/dbus-c++/interface.h b/include/dbus-c++/interface.h
index 9e3106f..db7b7cb 100644
--- a/include/dbus-c++/interface.h
+++ b/include/dbus-c++/interface.h
@@ -33,25 +33,25 @@
 
 #include "message.h"
 
-namespace DBus
-{
+namespace DBus {
 
 //todo: this should belong to to properties.h
 struct DXXAPI PropertyData
 {
-  bool		read;
-  bool		write;
-  std::string	sig;
-  Variant		value;
+	bool		read;
+	bool		write;
+	std::string	sig;
+	Variant		value;
 };
 
 typedef std::map<std::string, PropertyData>	PropertyTable;
 
-class IntrospectedInterface;
+struct IntrospectedInterface;
 
 class ObjectAdaptor;
 class InterfaceAdaptor;
 class SignalMessage;
+class PendingCall;
 
 typedef std::map<std::string, InterfaceAdaptor *> InterfaceAdaptorTable;
 
@@ -59,18 +59,18 @@ class DXXAPI AdaptorBase
 {
 public:
 
-  virtual const ObjectAdaptor *object() const = 0 ;
+	virtual const ObjectAdaptor *object() const = 0 ;
 
 protected:
 
-  InterfaceAdaptor *find_interface(const std::string &name);
+	InterfaceAdaptor *find_interface(const std::string &name);
 
-  virtual ~AdaptorBase()
-  {}
+	virtual ~AdaptorBase()
+	{}
 
-  virtual void _emit_signal(SignalMessage &) = 0;
+	virtual void _emit_signal(SignalMessage &) = 0;
 
-  InterfaceAdaptorTable _interfaces;
+	InterfaceAdaptorTable _interfaces;
 };
 
 /*
@@ -86,35 +86,51 @@ class DXXAPI ProxyBase
 {
 public:
 
-  virtual const ObjectProxy *object() const = 0 ;
+	virtual const ObjectProxy *object() const = 0 ;
 
 protected:
 
-  InterfaceProxy *find_interface(const std::string &name);
-
-  virtual ~ProxyBase()
-  {}
-
-  virtual Message _invoke_method(CallMessage &) = 0;
-
-  virtual bool _invoke_method_noreply(CallMessage &call) = 0;
-
-  InterfaceProxyTable _interfaces;
+	InterfaceProxy *find_interface(const std::string &name);
+
+	virtual ~ProxyBase()
+	{}
+
+	virtual Message _invoke_method(CallMessage &) = 0;
+	
+	virtual bool _invoke_method_noreply(CallMessage &call) = 0;
+
+	/*!
+	 * \brief Perform a non-blocking method invocation.
+	 * \details Queues a message to send, as with _invoke_method(), but instead
+	 * of blocking to wait for a reply, immediately returns a DBus::PendingCall
+	 * used to receive the reply asynchronously.
+	 *
+	 * The PendingCall is owned by the caller, and must be disposed of using
+	 * _remove_pending_call().
+	 */
+	virtual PendingCall *_invoke_method_async(CallMessage &call, int timeout = -1) = 0;
+	/*!
+	 * \brief Deletes the supplied PendingCall without cancelling it.
+	 * \param pending The PendingCall to be deleted.
+	 */
+	virtual void _remove_pending_call(PendingCall *pending) = 0;
+
+	InterfaceProxyTable _interfaces;
 };
 
 class DXXAPI Interface
 {
 public:
+	
+	Interface(const std::string &name);
+	
+	virtual ~Interface();
 
-  Interface(const std::string &name);
-
-  virtual ~Interface();
-
-  inline const std::string &name() const;
+	inline const std::string &name() const;
 
 private:
 
-  std::string 	_name;
+	std::string 	_name;
 };
 
 /*
@@ -122,37 +138,40 @@ private:
 
 const std::string &Interface::name() const
 {
-  return _name;
+	return _name;
 }
 
 /*
 */
 
 typedef std::map< std::string, Slot<Message, const CallMessage &> > MethodTable;
+typedef std::map< std::string, Variant > PropertyDict;
 
 class DXXAPI InterfaceAdaptor : public Interface, public virtual AdaptorBase
 {
 public:
 
-  InterfaceAdaptor(const std::string &name);
+	InterfaceAdaptor(const std::string &name);
+
+	Message dispatch_method(const CallMessage &);
 
-  Message dispatch_method(const CallMessage &);
+	void emit_signal(const SignalMessage &);
 
-  void emit_signal(const SignalMessage &);
+	Variant *get_property(const std::string &name);
 
-  Variant *get_property(const std::string &name);
+	void set_property(const std::string &name, Variant &value);
 
-  void set_property(const std::string &name, Variant &value);
+	PropertyDict *get_all_properties();
 
-  virtual IntrospectedInterface *introspect() const
-  {
-    return NULL;
-  }
+	virtual const IntrospectedInterface *introspect() const
+	{
+		return NULL;
+	}
 
 protected:
 
-  MethodTable	_methods;
-  PropertyTable	_properties;
+	MethodTable	_methods;
+	PropertyTable	_properties;
 };
 
 /*
@@ -164,17 +183,33 @@ class DXXAPI InterfaceProxy : public Interface, public virtual ProxyBase
 {
 public:
 
-  InterfaceProxy(const std::string &name);
+	InterfaceProxy(const std::string &name);
 
-  Message invoke_method(const CallMessage &);
+	Message invoke_method(const CallMessage &);
 
-  bool invoke_method_noreply(const CallMessage &call);
+	bool invoke_method_noreply(const CallMessage &call);
 
-  bool dispatch_signal(const SignalMessage &);
+	/*!
+	 * \brief Perform a non-blocking method invocation.
+	 * \details Queues a message to send, as with invoke_method(), but instead
+	 * of blocking to wait for a reply, immediately returns a DBus::PendingCall
+	 * used to receive the reply asynchronously.
+	 *
+	 * The PendingCall is owned by the caller, and must be disposed of using
+	 * remove_pending_call().
+	 */
+	PendingCall *invoke_method_async(const CallMessage &call, int timeout = -1);
+
+	bool dispatch_signal(const SignalMessage &);
 
 protected:
+	/*!
+	 * \brief Deletes the supplied PendingCall without cancelling it.
+	 * \param pending The PendingCall to be deleted.
+	 */
+	void remove_pending_call(PendingCall *pending);
 
-  SignalTable	_signals;
+	SignalTable	_signals;
 };
 
 # define register_method(interface, method, callback) \
@@ -186,7 +221,7 @@ protected:
 	InterfaceAdaptor::_properties[ #variable ].write = can_write; \
 	InterfaceAdaptor::_properties[ #variable ].sig = type; \
 	variable.bind(InterfaceAdaptor::_properties[ #variable ]);
-
+	
 # define connect_signal(interface, signal, callback) \
 	InterfaceProxy::_signals[ #signal ] = \
 		new ::DBus::Callback< interface, void, const ::DBus::SignalMessage &>(this, & interface :: callback);
diff --git a/include/dbus-c++/introspection.h b/include/dbus-c++/introspection.h
index 9447359..d1bec4f 100644
--- a/include/dbus-c++/introspection.h
+++ b/include/dbus-c++/introspection.h
@@ -28,58 +28,57 @@
 #include "api.h"
 #include "interface.h"
 
-namespace DBus
-{
+namespace DBus {
 
 struct DXXAPI IntrospectedArgument
 {
-  const char *name;
-  const char *type;
-  const bool  in;
+	const char *name;
+	const char *type;
+	const bool  in;
 };
 
 struct DXXAPI IntrospectedMethod
 {
-  const char *name;
-  const IntrospectedArgument *args;
+	const char *name;
+	const IntrospectedArgument *args;
 };
 
 struct DXXAPI IntrospectedProperty
 {
-  const char *name;
-  const char *type;
-  const bool  read;
-  const bool  write;
+	const char *name;
+	const char *type;
+	const bool  read;
+	const bool  write;
 };
 
 struct DXXAPI IntrospectedInterface
 {
-  const char *name;
-  const IntrospectedMethod *methods;
-  const IntrospectedMethod *signals;
-  const IntrospectedProperty *properties;
+	const char *name;
+	const IntrospectedMethod *methods;
+	const IntrospectedMethod *signals;
+	const IntrospectedProperty *properties;
 };
 
 class DXXAPI IntrospectableAdaptor : public InterfaceAdaptor
 {
 public:
 
-  IntrospectableAdaptor();
+	IntrospectableAdaptor();
 
-  Message Introspect(const CallMessage &);
+	Message Introspect(const CallMessage &);
 
 protected:
 
-  IntrospectedInterface *introspect() const;
+	const IntrospectedInterface *introspect() const;
 };
 
 class DXXAPI IntrospectableProxy : public InterfaceProxy
 {
 public:
 
-  IntrospectableProxy();
+	IntrospectableProxy();
 
-  std::string Introspect();
+	std::string Introspect();
 };
 
 } /* namespace DBus */
diff --git a/include/dbus-c++/message.h b/include/dbus-c++/message.h
index a9041d8..a1de8a9 100644
--- a/include/dbus-c++/message.h
+++ b/include/dbus-c++/message.h
@@ -31,8 +31,7 @@
 #include "api.h"
 #include "util.h"
 
-namespace DBus
-{
+namespace DBus {
 
 class Message;
 class ErrorMessage;
@@ -40,180 +39,194 @@ class SignalMessage;
 class ReturnMessage;
 class Error;
 class Connection;
+class Tag;
 
 class DXXAPI MessageIter
 {
 public:
 
-  MessageIter() {}
+	MessageIter();
+
+	~MessageIter();
+
+	MessageIter(const MessageIter &iter);
+
+	MessageIter &operator =(const MessageIter &iter);
 
-  int type();
+	int type();
 
-  bool at_end();
+	bool at_end();
 
-  bool has_next();
+	bool has_next();
 
-  MessageIter &operator ++();
+	MessageIter &operator ++();
 
-  MessageIter operator ++(int);
+	MessageIter operator ++(int);
 
-  bool append_byte(unsigned char byte);
+	bool append_byte(unsigned char byte);
 
-  unsigned char get_byte();
+	unsigned char get_byte();
 
-  bool append_bool(bool b);
+	bool append_bool(bool b);
 
-  bool get_bool();
+	bool get_bool();
 
-  bool append_int16(signed short i);
+	bool append_int16(signed short i);
 
-  signed short get_int16();
+	signed short get_int16();
 
-  bool append_uint16(unsigned short u);
+	bool append_uint16(unsigned short u);
 
-  unsigned short get_uint16();
+	unsigned short get_uint16();
 
-  bool append_int32(signed int i);
+	bool append_int32(signed int i);
 
-  signed int get_int32();
+	signed int get_int32();
 
-  bool append_uint32(unsigned int u);
+	bool append_uint32(unsigned int u);
 
-  unsigned int get_uint32();
+	unsigned int get_uint32();
 
-  bool append_int64(signed long long i);
+	bool append_int64(signed long long i);
 
-  signed long long get_int64();
+	signed long long get_int64();
 
-  bool append_uint64(unsigned long long i);
+	bool append_uint64(unsigned long long i);
 
-  unsigned long long get_uint64();
+	unsigned long long get_uint64();
 
-  bool append_double(double d);
+	bool append_double(double d);
 
-  double get_double();
+	double get_double();
 
-  bool append_string(const char *chars);
+	bool append_string(const char *chars);
 
-  const char *get_string();
+	const char *get_string();
 
-  bool append_path(const char *chars);
+	bool append_path(const char *chars);
 
-  const char *get_path();
+	const char *get_path();
 
-  bool append_signature(const char *chars);
+	bool append_signature(const char *chars);
 
-  const char *get_signature();
+	const char *get_signature();
 
-  char *signature() const; //returned string must be manually free()'d
+	char *signature() const; //returned string must be manually free()'d
 
-  MessageIter recurse();
+	int get_fd();
 
-  bool append_array(char type, const void *ptr, size_t length);
+	bool append_fd(int fd);
 
-  int array_type();
+	MessageIter recurse();
 
-  int get_array(void *ptr);
+	bool append_array(char type, const void *ptr, size_t length);
 
-  bool is_array();
+	int array_type();
 
-  bool is_dict();
+	int get_array(void *ptr);
 
-  MessageIter new_array(const char *sig);
+	bool is_array();
 
-  MessageIter new_variant(const char *sig);
+	bool is_dict();
 
-  MessageIter new_struct();
+	MessageIter new_array(const char *sig);
 
-  MessageIter new_dict_entry();
+	MessageIter new_variant(const char *sig);
 
-  void close_container(MessageIter &container);
+	MessageIter new_struct();
 
-  void copy_data(MessageIter &to);
+	MessageIter new_dict_entry();
 
-  Message &msg() const
-  {
-    return *_msg;
-  }
+	void close_container(MessageIter &container);
+
+	void copy_data(MessageIter &to);
+
+	Message &msg() const
+	{
+		return *_msg;
+	}
 
 private:
 
-  DXXAPILOCAL MessageIter(Message &msg) : _msg(&msg) {}
+	DXXAPILOCAL MessageIter(Message &msg);
 
-  DXXAPILOCAL bool append_basic(int type_id, void *value);
+	DXXAPILOCAL bool append_basic(int type_id, void *value);
 
-  DXXAPILOCAL void get_basic(int type_id, void *ptr);
+	DXXAPILOCAL void get_basic(int type_id, void *ptr);
 
 private:
 
-  /* I'm sorry, but don't want to include dbus.h in the public api
-   */
-  unsigned char _iter[sizeof(void *) * 3 + sizeof(int) * 11];
+	struct Private;
 
-  Message *_msg;
+	Private *_pvt;
 
-  friend class Message;
+	Message *_msg;
+
+friend class Message;
 };
 
 class DXXAPI Message
 {
 public:
 
-  struct Private;
+	struct Private;
+
+	Message(Private *, bool incref = true);
 
-  Message(Private *, bool incref = true);
+	Message(const Message &m);
 
-  Message(const Message &m);
+	~Message();
 
-  ~Message();
+	Message &operator = (const Message &m);
 
-  Message &operator = (const Message &m);
+	Message copy();
 
-  Message copy();
+	int type() const;
 
-  int type() const;
+	int serial() const;
 
-  int serial() const;
+	int reply_serial() const;
 
-  int reply_serial() const;
+	bool reply_serial(int);
 
-  bool reply_serial(int);
+	const char *sender() const;
 
-  const char *sender() const;
+	bool sender(const char *s);
 
-  bool sender(const char *s);
+	const char *destination() const;
 
-  const char *destination() const;
+	bool destination(const char *s);
 
-  bool destination(const char *s);
+	bool is_error() const;
 
-  bool is_error() const;
+	bool is_signal(const char *interface, const char *member) const;
 
-  bool is_signal(const char *interface, const char *member) const;
+	Tag *tag() const;
 
-  MessageIter reader() const;
+	MessageIter reader() const;
 
-  MessageIter writer();
+	MessageIter writer();
 
-  bool append(int first_type, ...);
+	bool append(int first_type, ...);
 
-  void terminate();
+	void terminate();
 
 protected:
 
-  Message();
+	Message();
 
 protected:
 
-  RefPtrI<Private> _pvt;
+	RefPtrI<Private> _pvt;
 
-  /*	classes who need to read `_pvt` directly
-  */
-  friend class ErrorMessage;
-  friend class ReturnMessage;
-  friend class MessageIter;
-  friend class Error;
-  friend class Connection;
+/*	classes who need to read `_pvt` directly
+*/
+friend class ErrorMessage;
+friend class ReturnMessage;
+friend class MessageIter;
+friend class Error;
+friend class Connection;
+friend class TagMessage;
 };
 
 /*
@@ -223,15 +236,15 @@ class DXXAPI ErrorMessage : public Message
 {
 public:
 
-  ErrorMessage();
+	ErrorMessage();
 
-  ErrorMessage(const Message &, const char *name, const char *message);
+	ErrorMessage(const Message &, const char *name, const char *message);
 
-  const char *name() const;
+	const char *name() const;
 
-  bool name(const char *n);
+	bool name(const char *n);
 
-  bool operator == (const ErrorMessage &) const;
+	bool operator == (const ErrorMessage &) const;
 };
 
 /*
@@ -241,25 +254,25 @@ class DXXAPI SignalMessage : public Message
 {
 public:
 
-  SignalMessage(const char *name);
+	SignalMessage(const char *name);
 
-  SignalMessage(const char *path, const char *interface, const char *name);
+	SignalMessage(const char *path, const char *interface, const char *name);
 
-  const char *interface() const;
+	const char *interface() const;
 
-  bool interface(const char *i);
+	bool interface(const char *i);
 
-  const char *member() const;
+	const char *member() const;
 
-  bool member(const char *m);
+	bool member(const char *m);
 
-  const char *path() const;
+	const char *path() const;
 
-  char **path_split() const;
+	char ** path_split() const;
 
-  bool path(const char *p);
+	bool path(const char *p);
 
-  bool operator == (const SignalMessage &) const;
+	bool operator == (const SignalMessage &) const;
 };
 
 /*
@@ -269,27 +282,36 @@ class DXXAPI CallMessage : public Message
 {
 public:
 
-  CallMessage();
+	CallMessage();
+
+	CallMessage(const char *dest, const char *path, const char *iface, const char *method);
 
-  CallMessage(const char *dest, const char *path, const char *iface, const char *method);
+	const char *interface() const;
 
-  const char *interface() const;
+	bool interface(const char *i);
 
-  bool interface(const char *i);
+	const char *member() const;
 
-  const char *member() const;
+	bool member(const char *m);
 
-  bool member(const char *m);
+	const char *path() const;
 
-  const char *path() const;
+	char ** path_split() const;
 
-  char **path_split() const;
+	bool path(const char *p);
 
-  bool path(const char *p);
+	const char *signature() const;
+
+	bool operator == (const CallMessage &) const;
+};
 
-  const char *signature() const;
+/*
+*/
 
-  bool operator == (const CallMessage &) const;
+class DXXAPI TagMessage : public Message
+{
+public:
+	TagMessage(Tag *tag);
 };
 
 /*
@@ -299,9 +321,9 @@ class DXXAPI ReturnMessage : public Message
 {
 public:
 
-  ReturnMessage(const CallMessage &callee);
+	ReturnMessage(const CallMessage &callee);
 
-  const char *signature() const;
+	const char *signature() const;
 };
 
 } /* namespace DBus */
diff --git a/include/dbus-c++/object.h b/include/dbus-c++/object.h
index 3c68876..0b20a92 100644
--- a/include/dbus-c++/object.h
+++ b/include/dbus-c++/object.h
@@ -34,41 +34,38 @@
 #include "message.h"
 #include "types.h"
 
-namespace DBus
-{
+namespace DBus {
 
 class DXXAPI Object
 {
 protected:
 
-  Object(Connection &conn, const Path &path, const char *service);
+	Object(Connection &conn, const Path &path, const char *service);
 
 public:
 
-  virtual ~Object();
-
-  inline const DBus::Path &path() const;
+	virtual ~Object();
 
-  inline const std::string &service() const;
+	inline const DBus::Path &path() const;
 
-  inline Connection &conn();
+	inline const std::string &service() const;
 
-  void set_timeout(int new_timeout = -1);
+ 	inline Connection &conn();
 
-  inline int get_timeout() const;
+protected:
+	virtual void register_obj() = 0;
+	virtual void unregister_obj() = 0;
+	virtual bool is_registered() = 0;
 
 private:
 
-  DXXAPILOCAL virtual bool handle_message(const Message &) = 0;
-  DXXAPILOCAL virtual void register_obj() = 0;
-  DXXAPILOCAL virtual void unregister_obj(bool throw_on_error = true) = 0;
+	DXXAPILOCAL virtual bool handle_message(const Message &) = 0;
 
 private:
 
-  Connection	_conn;
-  DBus::Path	_path;
-  std::string	_service;
-  int		_default_timeout;
+	Connection	_conn;
+	DBus::Path	_path;
+	std::string	_service;
 };
 
 /*
@@ -76,22 +73,17 @@ private:
 
 Connection &Object::conn()
 {
-  return _conn;
+	return _conn;
 }
 
 const DBus::Path &Object::path() const
 {
-  return _path;
+	return _path;
 }
 
 const std::string &Object::service() const
 {
-  return _service;
-}
-
-int Object::get_timeout() const
-{
-  return _default_timeout;
+	return _service;
 }
 
 /*
@@ -101,8 +93,8 @@ class DXXAPI Tag
 {
 public:
 
-  virtual ~Tag()
-  {}
+	virtual ~Tag()
+	{}
 };
 
 /*
@@ -117,79 +109,95 @@ class DXXAPI ObjectAdaptor : public Object, public virtual AdaptorBase
 {
 public:
 
-  static ObjectAdaptor *from_path(const Path &path);
+	static ObjectAdaptor *from_path(const Path &path);
+
+	static ObjectAdaptorPList from_path_prefix(const std::string &prefix);
 
-  static ObjectAdaptorPList from_path_prefix(const std::string &prefix);
+	static ObjectPathList child_nodes_from_prefix(const std::string &prefix);
 
-  static ObjectPathList child_nodes_from_prefix(const std::string &prefix);
+	struct Private;
 
-  struct Private;
+	enum registration_time {
+		REGISTER_NOW,
+		REGISTER_LATER,
+	};
 
-  ObjectAdaptor(Connection &conn, const Path &path);
+	enum exceptions_flag {
+		USE_EXCEPTIONS,
+		AVOID_EXCEPTIONS
+	};
 
-  ~ObjectAdaptor();
+	ObjectAdaptor(Connection &conn, const Path &path);
+	ObjectAdaptor(Connection &conn, const Path &path, registration_time rtime);
+	ObjectAdaptor(Connection &conn, const Path &path, registration_time rtime,
+		      exceptions_flag eflag);
 
-  inline const ObjectAdaptor *object() const;
+	~ObjectAdaptor();
+
+	inline const ObjectAdaptor *object() const;
 
 protected:
 
-  class DXXAPI Continuation
-  {
-  public:
+	class DXXAPI Continuation
+	{
+	public:
+
+		inline MessageIter &writer();
 
-    inline MessageIter &writer();
+		inline Tag *tag();
 
-    inline Tag *tag();
+	private:
 
-  private:
+		Continuation(Connection &conn, const CallMessage &call, const Tag *tag);
 
-    Continuation(Connection &conn, const CallMessage &call, const Tag *tag);
+		Connection _conn;
+		CallMessage _call;
+		MessageIter _writer;
+		ReturnMessage _return;
+		const Tag *_tag;
 
-    Connection _conn;
-    CallMessage _call;
-    MessageIter _writer;
-    ReturnMessage _return;
-    const Tag *_tag;
+	friend class ObjectAdaptor;
+	};
 
-    friend class ObjectAdaptor;
-  };
+	void return_later(const Tag *tag);
 
-  void return_later(const Tag *tag);
+	void return_now(Continuation *ret);
 
-  void return_now(Continuation *ret);
+	void return_error(Continuation *ret, const Error error);
 
-  void return_error(Continuation *ret, const Error error);
+	Continuation *find_continuation(const Tag *tag);
 
-  Continuation *find_continuation(const Tag *tag);
+	virtual void register_obj();
+	virtual void unregister_obj();
+	virtual bool is_registered();
 
 private:
 
-  void _emit_signal(SignalMessage &);
+	void _emit_signal(SignalMessage &);
 
-  bool handle_message(const Message &);
+	bool handle_message(const Message &);
 
-  void register_obj();
-  void unregister_obj(bool throw_on_error = true);
+	typedef std::map<const Tag *, Continuation *> ContinuationMap;
+	ContinuationMap _continuations;
 
-  typedef std::map<const Tag *, Continuation *> ContinuationMap;
-  ContinuationMap _continuations;
+	exceptions_flag _eflag;
 
-  friend struct Private;
+friend struct Private;
 };
 
 const ObjectAdaptor *ObjectAdaptor::object() const
 {
-  return this;
+	return this;
 }
 
 Tag *ObjectAdaptor::Continuation::tag()
 {
-  return const_cast<Tag *>(_tag);
+	return const_cast<Tag *>(_tag);
 }
 
 MessageIter &ObjectAdaptor::Continuation::writer()
 {
-  return _writer;
+	return _writer;
 }
 
 /*
@@ -199,35 +207,52 @@ class ObjectProxy;
 
 typedef std::list<ObjectProxy *> ObjectProxyPList;
 
+/*!
+ * \brief An ObjectProxy wraps a dbus object on which methods can
+ * be invoked and signals can be received.
+ *
+ * ObjectProxy objects should not be deleted while in a callback
+ * handling either a signal or a pending call reply. Doing so may
+ * result in a deadlock.
+ */
 class DXXAPI ObjectProxy : public Object, public virtual ProxyBase
 {
 public:
 
-  ObjectProxy(Connection &conn, const Path &path, const char *service = "");
+	ObjectProxy(Connection &conn, const Path &path, const char *service = "");
 
-  ~ObjectProxy();
+	~ObjectProxy();
 
-  inline const ObjectProxy *object() const;
+	inline const ObjectProxy *object() const;
 
 private:
 
-  Message _invoke_method(CallMessage &);
+	Message _invoke_method(CallMessage &);
 
-  bool _invoke_method_noreply(CallMessage &call);
+	bool _invoke_method_noreply(CallMessage &call);
 
-  bool handle_message(const Message &);
+	PendingCall *_invoke_method_async(CallMessage &call, int timeout = -1);
 
-  void register_obj();
-  void unregister_obj(bool throw_on_error = true);
+	bool handle_message(const Message &);
+
+protected:
+	virtual void register_obj();
+	virtual void unregister_obj();
+	virtual bool is_registered();
+	virtual void _remove_pending_call(PendingCall *pending);
 
 private:
+	void cancel_pending_calls();
+
+	MessageSlot _filtered;
 
-  MessageSlot _filtered;
+	typedef std::vector<PendingCall*> PendingCallList;
+	PendingCallList _pending_calls;
 };
 
 const ObjectProxy *ObjectProxy::object() const
 {
-  return this;
+	return this;
 }
 
 } /* namespace DBus */
diff --git a/include/dbus-c++/pendingcall.h b/include/dbus-c++/pendingcall.h
index 1f5ebe9..8bbb620 100644
--- a/include/dbus-c++/pendingcall.h
+++ b/include/dbus-c++/pendingcall.h
@@ -29,103 +29,119 @@
 #include "util.h"
 #include "message.h"
 
-namespace DBus
-{
+namespace DBus {
 
 class Connection;
+class PendingCall;
+
+typedef Slot<void, PendingCall *> AsyncReplyHandler;
 
 class DXXAPI PendingCall
 {
 public:
 
-  struct Private;
-
-  PendingCall(Private *);
-
-  PendingCall(const PendingCall &);
-
-  virtual ~PendingCall();
-
-  PendingCall &operator = (const PendingCall &);
-
-  /*!
-   * \brief Checks whether the pending call has received a reply yet, or not.
-   *
-   * \return true If a reply has been received.
-   */
-  bool completed();
-
-  /*!
-   * \brief Cancels the pending call, such that any reply or error received will
-   *        just be ignored.
-   *
-   * Drops the dbus library's internal reference to the DBusPendingCall so will
-   * free the call if nobody else is holding a reference. However you usually
-   * get a reference from Connection::send_async() so probably your app
-   * owns a ref also.
-   *
-   * Note that canceling a pending call will not simulate a timed-out call; if a
-   * call times out, then a timeout error reply is received. If you cancel the
-   * call, no reply is received unless the the reply was already received before
-   * you canceled.
-   */
-  void cancel();
-
-  /*!
-   * \brief Block until the pending call is completed.
-   *
-   * The blocking is as with Connection::send_blocking(); it
-   * does not enter the main loop or process other messages, it simply waits for
-   * the reply in question.
-   *
-   * If the pending call is already completed, this function returns immediately.
-   */
-  void block();
-
-  /*!
-   * \brief Stores a pointer on a PendingCall, along with an optional function to
-   *        be used for freeing the data when the data is set again, or when the
-   *        pending call is finalized.
-   *
-   * The slot is allocated automatic.
-   *
-   * \param data The data to store.
-   * \throw ErrorNoMemory
-   */
-  void data(void *data);
-
-  /*!
-   * \brief Retrieves data previously set with dbus_pending_call_set_data().
-   *
-   * The slot must still be allocated (must not have been freed).
-   *
-   * \return The data, or NULL if not found.
-   */
-  void *data();
-
-  /*!
-   * \return The data slot.
-   */
-  Slot<void, PendingCall &>& slot();
-
-  /*!
-   * \brief Gets the reply
-   *
-   * Ownership of the reply message passes to the caller. This function can only
-   * be called once per pending call, since the reply message is tranferred to
-   * the caller.
-   *
-   * \return The reply Message.
-   * \throw ErrorNoReply
-   */
-  Message steal_reply();
+	struct Private;
+
+	PendingCall(Private *);
+
+	PendingCall(const PendingCall &);
+
+	virtual ~PendingCall();
+
+	PendingCall &operator = (const PendingCall &);
+
+	/*!
+	 * \brief Checks whether the pending call has received a reply yet, or not.
+	 *
+	 * \return true If a reply has been received.
+	 */
+	bool completed();
+	
+	/*!
+	 * \brief Cancels the pending call, such that any reply or error received will 
+	 *        just be ignored.
+	 *
+	 * Drops the dbus library's internal reference to the DBusPendingCall so will 
+	 * free the call if nobody else is holding a reference. However you usually 
+	 * get a reference from Connection::send_async() so probably your app 
+	 * owns a ref also.
+	 *
+	 * Note that canceling a pending call will not simulate a timed-out call; if a 
+	 * call times out, then a timeout error reply is received. If you cancel the 
+	 * call, no reply is received unless the the reply was already received before 
+	 * you cancelled.
+	 */
+	void cancel();
+
+	/*!
+	 * \brief Block until the pending call is completed.
+	 *
+	 * The blocking is as with Connection::send_blocking(); it
+	 * does not enter the main loop or process other messages, it simply waits for
+	 * the reply in question.
+	 *
+	 * If the pending call is already completed, this function returns immediately.
+	 */
+	void block();
+
+	/*!
+	 * \brief Stores a pointer on a PendingCall, along with an optional function to 
+	 *        be used for freeing the data when the data is set again, or when the
+	 *        pending call is finalized.
+	 *
+	 * The slot is allocated automatically.
+	 *
+	 * \param data The data to store.
+	 * \throw ErrorNoMemory
+	 */
+	void data( void* data );
+
+	/*!
+	 * \brief Retrieves data previously set with dbus_pending_call_set_data().
+	 *
+	 * The slot must still be allocated (must not have been freed).
+	 *
+	 * \return The data, or NULL if not found.
+	 */
+	void *data();
+
+	/*!
+	 * \return The reply handler slot.
+	 */
+	AsyncReplyHandler& reply_handler();
+
+	/*!
+	 * \brief Sets a callback to handle an asynchronous reply to a method
+	 * invocation.
+	 *
+	 * If the pending call has not been cancelled, the supplied callback will
+	 * be invoked when a reply is received. The callback is a templated
+	 * class, where the two template arguments are the type of the single
+	 * argument taken by the handler function, and the return type of that
+	 * function.
+	 *
+	 * \param handler The callback.
+	 */
+	void reply_handler(const AsyncReplyHandler& handler);
+
+	/*!
+	 * \brief Gets the reply message
+	 *
+	 * Ownership of the reply message passes to the caller. This function can only 
+	 * be called once per pending call, since the reply message is tranferred to 
+	 * the caller.
+	 *
+	 * \return The reply Message.
+	 * \throw ErrorNoReply
+	 */
+	Message steal_reply();
 
 private:
 
-  RefPtrI<Private> _pvt;
+	RefPtrI<Private> _pvt;
 
-  friend struct Private;
-  friend class Connection;
+friend struct Private;
+friend class Connection;
 };
 
 } /* namespace DBus */
diff --git a/include/dbus-c++/property.h b/include/dbus-c++/property.h
index 00095c9..8755d01 100644
--- a/include/dbus-c++/property.h
+++ b/include/dbus-c++/property.h
@@ -29,38 +29,37 @@
 #include "types.h"
 #include "interface.h"
 
-namespace DBus
-{
+namespace DBus {
 
 template <typename T>
 class PropertyAdaptor
 {
 public:
 
-  PropertyAdaptor() : _data(0)
-  {}
+	PropertyAdaptor() : _data(0)
+	{}
 
-  void bind(PropertyData &data)
-  {
-    _data = &data;
-  }
+	void bind(PropertyData &data)
+	{
+		_data = &data;
+	}
 
-  T operator()(void) const
-  {
-    return _data->value.operator T();
-  }
+	T operator() (void) const
+	{
+		return (T)_data->value;
+	}
 
-  PropertyAdaptor &operator = (const T &t)
-  {
-    _data->value.clear();
-    MessageIter wi = _data->value.writer();
-    wi << t;
-    return *this;
-  }
+	PropertyAdaptor &operator = (const T &t)
+	{
+		_data->value.clear();
+		MessageIter wi = _data->value.writer();
+		wi << t;
+		return *this;
+	}
 
 private:
 
-  PropertyData *_data;
+	PropertyData *_data;
 };
 
 struct IntrospectedInterface;
@@ -69,35 +68,36 @@ class DXXAPI PropertiesAdaptor : public InterfaceAdaptor
 {
 public:
 
-  PropertiesAdaptor();
+	PropertiesAdaptor();
+
+	Message Get(const CallMessage &);
 
-  Message Get(const CallMessage &);
+	Message Set(const CallMessage &);
 
-  Message Set(const CallMessage &);
+	Message GetAll(const CallMessage &);
 
 protected:
 
-  virtual void on_get_property(InterfaceAdaptor &/*interface*/, const std::string &/*property*/, Variant &/*value*/)
-  {}
+	virtual void on_get_property(InterfaceAdaptor &/*interface*/, const std::string &/*property*/, Variant &/*value*/)
+	{}
 
-  virtual void on_set_property(InterfaceAdaptor &/*interface*/, const std::string &/*property*/, const Variant &/*value*/)
-  {}
+	virtual void on_set_property(InterfaceAdaptor &/*interface*/, const std::string &/*property*/, const Variant &/*value*/)
+	{}
 
-  IntrospectedInterface *introspect() const;
+	const IntrospectedInterface *introspect() const;
 };
 
 class DXXAPI PropertiesProxy : public InterfaceProxy
 {
 public:
 
-  PropertiesProxy();
+	PropertiesProxy();
 
-  Variant Get(const std::string &interface, const std::string &property);
+	Variant Get(const std::string &interface, const std::string &property);
 
-  void Set(const std::string &interface, const std::string &property, const Variant &value);
+	void Set(const std::string &interface, const std::string &property, const Variant &value);
 };
 
 } /* namespace DBus */
 
 #endif//__DBUSXX_PROPERTY_H
-
diff --git a/include/dbus-c++/refptr_impl.h b/include/dbus-c++/refptr_impl.h
index d7de857..fc10cef 100644
--- a/include/dbus-c++/refptr_impl.h
+++ b/include/dbus-c++/refptr_impl.h
@@ -28,18 +28,17 @@
 #include "api.h"
 #include "util.h"
 
-namespace DBus
-{
-
+namespace DBus {
+	
 template <class T>
 RefPtrI<T>::RefPtrI(T *ptr)
-  : __ptr(ptr)
+: __ptr(ptr)
 {}
 
 template <class T>
 RefPtrI<T>::~RefPtrI()
 {
-  if (__cnt.one()) delete __ptr;
+	if (__cnt.one()) delete __ptr;
 }
 
 } /* namespace DBus */
diff --git a/include/dbus-c++/server.h b/include/dbus-c++/server.h
index 0a807c1..9815bcd 100644
--- a/include/dbus-c++/server.h
+++ b/include/dbus-c++/server.h
@@ -33,8 +33,7 @@
 #include "util.h"
 #include "dispatcher.h"
 
-namespace DBus
-{
+namespace DBus {
 
 class Server;
 
@@ -44,30 +43,30 @@ class DXXAPI Server
 {
 public:
 
-  Server(const char *address);
+	Server(const char *address);
 
-  Dispatcher *setup(Dispatcher *);
+	Dispatcher *setup(Dispatcher *);
 
-  virtual ~Server();
+	virtual ~Server();
 
-  bool listening() const;
+	bool listening() const;
 
-  bool operator == (const Server &) const;
+	bool operator == (const Server &) const;
 
-  void disconnect();
+	void disconnect();
 
-  struct Private;
+	struct Private;
 
 protected:
 
-  Server(const Server &s)
-  {}
+	Server(const Server &/*s*/)
+	{}
 
-  virtual void on_new_connection(Connection &c) = 0;
+	virtual void on_new_connection(Connection &c) = 0;
 
 private:
 
-  RefPtrI<Private> _pvt;
+	RefPtrI<Private> _pvt;
 };
 
 } /* namespace DBus */
diff --git a/include/dbus-c++/types.h b/include/dbus-c++/types.h
index 044e72b..db7b5d6 100644
--- a/include/dbus-c++/types.h
+++ b/include/dbus-c++/types.h
@@ -35,31 +35,45 @@
 #include "message.h"
 #include "error.h"
 
-namespace DBus
-{
+namespace DBus {
 
 struct DXXAPI Path : public std::string
-{
-  Path() {}
-  Path(const std::string &s) : std::string(s) {}
-  Path(const char *c) : std::string(c) {}
-  Path &operator = (std::string &s)
-  {
-    std::string::operator = (s);
-    return *this;
-  }
+{ 
+	Path() {}
+	Path(const std::string &s) : std::string(s) {}
+	Path(const char *c) : std::string(c) {}
+	Path &operator = (std::string &s)
+	{
+		std::string::operator = (s);
+		return *this;
+	}
 };
 
 struct DXXAPI Signature : public std::string
+{ 
+	Signature() {}
+	Signature(const std::string &s) : std::string(s) {}
+	Signature(const char *c) : std::string(c) {}
+	Signature &operator = (std::string &s)
+	{
+		std::string::operator = (s);
+		return *this;
+	}
+};
+
+class DXXAPI FileDescriptor
 {
-  Signature() {}
-  Signature(const std::string &s) : std::string(s) {}
-  Signature(const char *c) : std::string(c) {}
-  Signature &operator = (std::string &s)
-  {
-    std::string::operator = (s);
-    return *this;
-  }
+public:
+	FileDescriptor() : _fd(-1) {}
+	FileDescriptor(int n) : _fd(n) {}
+	FileDescriptor &operator = (int fd)
+	{
+		_fd = fd;
+		return *this;
+	}
+	int get() const { return _fd; }
+private:
+	int _fd;
 };
 
 struct DXXAPI Invalid {};
@@ -68,583 +82,449 @@ class DXXAPI Variant
 {
 public:
 
-  Variant();
+	Variant();
 
-  Variant(MessageIter &it);
+	Variant(MessageIter &it);
 
-  Variant &operator = (const Variant &v);
+	Variant &operator = (const Variant &v);
 
-  const Signature signature() const;
+	const Signature signature() const;
 
-  void clear();
+	void clear();
 
-  MessageIter reader() const
-  {
-    return _msg.reader();
-  }
+	MessageIter reader() const
+	{
+		return _msg.reader();
+	}
 
-  MessageIter writer()
-  {
-    return _msg.writer();
-  }
+	MessageIter writer()
+	{
+		return _msg.writer();
+	}
 
-  template <typename T>
-  operator T() const
-  {
-    T cast;
-    MessageIter ri = _msg.reader();
-    ri >> cast;
-    return cast;
-  }
+	template <typename T>
+	operator T() const;
 
 private:
 
-  Message _msg;
+	Message _msg;
 };
 
 template <
-typename T1,
-         typename T2 = Invalid,
-         typename T3 = Invalid,
-         typename T4 = Invalid,
-         typename T5 = Invalid,
-         typename T6 = Invalid,
-         typename T7 = Invalid,
-         typename T8 = Invalid,
-         typename T9 = Invalid,
-         typename T10 = Invalid,
-         typename T11 = Invalid,
-         typename T12 = Invalid,
-         typename T13 = Invalid,
-         typename T14 = Invalid,
-         typename T15 = Invalid,
-         typename T16 = Invalid // nobody needs more than 16
-         >
+	typename T1,
+	typename T2 = Invalid,
+	typename T3 = Invalid,
+	typename T4 = Invalid,
+	typename T5 = Invalid,
+	typename T6 = Invalid,
+	typename T7 = Invalid,
+	typename T8 = Invalid	// who needs more than eight?
+>
 struct Struct
 {
-  T1 _1;
-  T2 _2;
-  T3 _3;
-  T4 _4;
-  T5 _5;
-  T6 _6;
-  T7 _7;
-  T8 _8;
-  T9 _9;
-  T10 _10;
-  T11 _11;
-  T12 _12;
-  T13 _13;
-  T14 _14;
-  T15 _15;
-  T16 _16;
+	T1 _1; T2 _2; T3 _3; T4 _4; T5 _5; T6 _6; T7 _7; T8 _8; 
 };
 
 template<typename K, typename V>
-inline bool dict_has_key(const std::map<K, V>& map, const K &key)
+inline bool dict_has_key(const std::map<K,V>& map, const K &key)
 {
-  return map.find(key) != map.end();
+	return map.find(key) != map.end();
 }
 
 template <typename T>
 struct type
 {
-  static std::string sig()
-  {
-    throw ErrorInvalidArgs("unknown type");
-    return "";
-  }
-};
-
-template <> struct type<Variant>
-{
-  static std::string sig()
-  {
-    return "v";
-  }
-};
-template <> struct type<uint8_t>
-{
-  static std::string sig()
-  {
-    return "y";
-  }
-};
-template <> struct type<bool>
-{
-  static std::string sig()
-  {
-    return "b";
-  }
-};
-template <> struct type<int16_t>
-{
-  static std::string sig()
-  {
-    return "n";
-  }
-};
-template <> struct type<uint16_t>
-{
-  static std::string sig()
-  {
-    return "q";
-  }
-};
-template <> struct type<int32_t>
-{
-  static std::string sig()
-  {
-    return "i";
-  }
-};
-template <> struct type<uint32_t>
-{
-  static std::string sig()
-  {
-    return "u";
-  }
-};
-template <> struct type<int64_t>
-{
-  static std::string sig()
-  {
-    return "x";
-  }
-};
-template <> struct type<uint64_t>
-{
-  static std::string sig()
-  {
-    return "t";
-  }
-};
-template <> struct type<double>
-{
-  static std::string sig()
-  {
-    return "d";
-  }
-};
-template <> struct type<std::string>
-{
-  static std::string sig()
-  {
-    return "s";
-  }
-};
-template <> struct type<Path>
-{
-  static std::string sig()
-  {
-    return "o";
-  }
-};
-template <> struct type<Signature>
-{
-  static std::string sig()
-  {
-    return "g";
-  }
-};
-template <> struct type<Invalid>
-{
-  static std::string sig()
-  {
-    return "";
-  }
+	static std::string sig()
+	{
+		throw ErrorInvalidArgs("unknown type");
+		return "";
+	}
 };
 
-template <typename E>
+template <> struct type<Variant>        { static std::string sig(){ return "v"; } };
+template <> struct type<uint8_t>        { static std::string sig(){ return "y"; } };
+template <> struct type<bool>           { static std::string sig(){ return "b"; } };
+template <> struct type<int16_t>        { static std::string sig(){ return "n"; } };
+template <> struct type<uint16_t>       { static std::string sig(){ return "q"; } };
+template <> struct type<int32_t>        { static std::string sig(){ return "i"; } };
+template <> struct type<uint32_t>       { static std::string sig(){ return "u"; } };
+template <> struct type<int64_t>        { static std::string sig(){ return "x"; } };
+template <> struct type<uint64_t>       { static std::string sig(){ return "t"; } };
+template <> struct type<double>         { static std::string sig(){ return "d"; } };
+template <> struct type<std::string>    { static std::string sig(){ return "s"; } };
+template <> struct type<Path>           { static std::string sig(){ return "o"; } };
+template <> struct type<Signature>      { static std::string sig(){ return "g"; } };
+template <> struct type<Invalid>        { static std::string sig(){ return "";  } };
+
+template <typename E> 
 struct type< std::vector<E> >
-{
-  static std::string sig()
-  {
-    return "a" + type<E>::sig();
-  }
-};
+{ static std::string sig(){ return "a" + type<E>::sig(); } };
 
 template <typename K, typename V>
-struct type< std::map<K, V> >
-{
-  static std::string sig()
-  {
-    return "a{" + type<K>::sig() + type<V>::sig() + "}";
-  }
-};
+struct type< std::map<K,V> >
+{ static std::string sig(){ return "a{" + type<K>::sig() + type<V>::sig() + "}"; } };
 
 template <
-typename T1,
-         typename T2,
-         typename T3,
-         typename T4,
-         typename T5,
-         typename T6,
-         typename T7,
-         typename T8,
-         typename T9,
-         typename T10,
-         typename T11,
-         typename T12,
-         typename T13,
-         typename T14,
-         typename T15,
-         typename T16 // nobody needs more than 16
-         >
-struct type< Struct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> >
-{
-  static std::string sig()
-  {
-    return "("
-           + type<T1>::sig()
-           + type<T2>::sig()
-           + type<T3>::sig()
-           + type<T4>::sig()
-           + type<T5>::sig()
-           + type<T6>::sig()
-           + type<T7>::sig()
-           + type<T8>::sig()
-           + type<T9>::sig()
-           + type<T10>::sig()
-           + type<T11>::sig()
-           + type<T12>::sig()
-           + type<T13>::sig()
-           + type<T14>::sig()
-           + type<T15>::sig()
-           + type<T16>::sig()
-           + ")";
-  }
+	typename T1,
+	typename T2,
+	typename T3,
+	typename T4,
+	typename T5,
+	typename T6,
+	typename T7,
+	typename T8 // who needs more than eight?
+>
+struct type< Struct<T1,T2,T3,T4,T5,T6,T7,T8> >
+{ 
+	static std::string sig()
+	{ 
+		return "("
+			+ type<T1>::sig()
+			+ type<T2>::sig()
+			+ type<T3>::sig()
+			+ type<T4>::sig()
+			+ type<T5>::sig()
+			+ type<T6>::sig()
+			+ type<T7>::sig()
+			+ type<T8>::sig()
+			+ ")";
+	}
 };
 
-} /* namespace DBus */
+extern DXXAPI DBus::MessageIter &operator << (DBus::MessageIter &iter, const DBus::Variant &val);
 
 inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const DBus::Invalid &)
 {
-  return iter;
+	return iter;
 }
 
 inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const uint8_t &val)
 {
-  iter.append_byte(val);
-  return iter;
+	iter.append_byte(val);
+	return iter;
 }
 
 inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const bool &val)
 {
-  iter.append_bool(val);
-  return iter;
+	iter.append_bool(val);
+	return iter;
 }
 
-inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const int16_t &val)
+inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const int16_t& val)
 {
-  iter.append_int16(val);
-  return iter;
+	iter.append_int16(val);
+	return iter;
 }
 
-inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const uint16_t &val)
+inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const uint16_t& val)
 {
-  iter.append_uint16(val);
-  return iter;
+	iter.append_uint16(val);
+	return iter;
 }
 
-inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const int32_t &val)
+inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const int32_t& val)
 {
-  iter.append_int32(val);
-  return iter;
+	iter.append_int32(val);
+	return iter;
 }
 
-inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const uint32_t &val)
+inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const uint32_t& val)
 {
-  iter.append_uint32(val);
-  return iter;
+	iter.append_uint32(val);
+	return iter;
 }
 
-inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const int64_t &val)
+inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const int64_t& val)
 {
-  iter.append_int64(val);
-  return iter;
+	iter.append_int64(val);
+	return iter;
 }
 
-inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const uint64_t &val)
+inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const uint64_t& val)
 {
-  iter.append_uint64(val);
-  return iter;
+	iter.append_uint64(val);
+	return iter;
 }
 
 inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const double &val)
 {
-  iter.append_double(val);
-  return iter;
+	iter.append_double(val);
+	return iter;
 }
 
 inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const std::string &val)
 {
-  iter.append_string(val.c_str());
-  return iter;
+	iter.append_string(val.c_str());
+	return iter;
 }
 
 inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const DBus::Path &val)
 {
-  iter.append_path(val.c_str());
-  return iter;
+	iter.append_path(val.c_str());
+	return iter;
 }
 
 inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const DBus::Signature &val)
 {
-  iter.append_signature(val.c_str());
-  return iter;
+	iter.append_signature(val.c_str());
+	return iter;
+}
+
+inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const DBus::FileDescriptor &val)
+{
+	iter.append_fd(val.get());
+	return iter;
 }
 
 template<typename E>
 inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const std::vector<E>& val)
 {
-  const std::string sig = DBus::type<E>::sig();
-  DBus::MessageIter ait = iter.new_array(sig.c_str());
+	const std::string sig = DBus::type<E>::sig();
+	DBus::MessageIter ait = iter.new_array(sig.c_str());
 
-  typename std::vector<E>::const_iterator vit;
-  for (vit = val.begin(); vit != val.end(); ++vit)
-  {
-    ait << *vit;
-  }
+	typename std::vector<E>::const_iterator vit;
+	for (vit = val.begin(); vit != val.end(); ++vit)
+	{
+		ait << *vit;
+	}
 
-  iter.close_container(ait);
-  return iter;
+	iter.close_container(ait);
+	return iter;
 }
 
 template<>
 inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const std::vector<uint8_t>& val)
 {
-  DBus::MessageIter ait = iter.new_array("y");
-  ait.append_array('y', &val.front(), val.size());
-  iter.close_container(ait);
-  return iter;
+	DBus::MessageIter ait = iter.new_array("y");
+	if (!val.empty())
+		ait.append_array('y', &val.front(), val.size());
+	iter.close_container(ait);
+	return iter;
 }
 
 template<typename K, typename V>
-inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const std::map<K, V>& val)
+inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const std::map<K,V>& val)
 {
-  const std::string sig = "{" + DBus::type<K>::sig() + DBus::type<V>::sig() + "}";
-  DBus::MessageIter ait = iter.new_array(sig.c_str());
+	const std::string sig = "{" + DBus::type<K>::sig() + DBus::type<V>::sig() + "}";
+	DBus::MessageIter ait = iter.new_array(sig.c_str());
 
-  typename std::map<K, V>::const_iterator mit;
-  for (mit = val.begin(); mit != val.end(); ++mit)
-  {
-    DBus::MessageIter eit = ait.new_dict_entry();
+	typename std::map<K,V>::const_iterator mit;
+	for (mit = val.begin(); mit != val.end(); ++mit)
+	{
+		DBus::MessageIter eit = ait.new_dict_entry();
 
-    eit << mit->first << mit->second;
+		eit << mit->first << mit->second;
 
-    ait.close_container(eit);
-  }
+		ait.close_container(eit);
+	}
 
-  iter.close_container(ait);
-  return iter;
+	iter.close_container(ait);
+	return iter;
 }
 
 template <
-typename T1,
-         typename T2,
-         typename T3,
-         typename T4,
-         typename T5,
-         typename T6,
-         typename T7,
-         typename T8,
-         typename T9,
-         typename T10,
-         typename T11,
-         typename T12,
-         typename T13,
-         typename T14,
-         typename T15,
-         typename T16
-         >
-inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const DBus::Struct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>& val)
-{
-  DBus::MessageIter sit = iter.new_struct();
-
-  sit << val._1 << val._2 << val._3 << val._4
-      << val._5 << val._6 << val._7 << val._8
-      << val._9 << val._10 << val._11 << val._12
-      << val._13 << val._14 << val._15 << val._16;
-
-  iter.close_container(sit);
-
-  return iter;
+	typename T1,
+	typename T2,
+	typename T3,
+	typename T4,
+	typename T5,
+	typename T6,
+	typename T7,
+	typename T8
+>
+inline DBus::MessageIter &operator << (DBus::MessageIter &iter, const DBus::Struct<T1,T2,T3,T4,T5,T6,T7,T8>& val)
+{
+/*	const std::string sig = 
+		DBus::type<T1>::sig() + DBus::type<T2>::sig() + DBus::type<T3>::sig() + DBus::type<T4>::sig() +
+		DBus::type<T5>::sig() + DBus::type<T6>::sig() + DBus::type<T7>::sig() + DBus::type<T8>::sig();
+*/
+	DBus::MessageIter sit = iter.new_struct(/*sig.c_str()*/);
+
+	sit << val._1 << val._2 << val._3 << val._4 << val._5 << val._6 << val._7 << val._8;
+
+	iter.close_container(sit);
+
+	return iter;
 }
 
-extern DXXAPI DBus::MessageIter &operator << (DBus::MessageIter &iter, const DBus::Variant &val);
+/*
+ */
 
 inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, DBus::Invalid &)
 {
-  return iter;
+	return iter;
 }
 
 inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, uint8_t &val)
 {
-  val = iter.get_byte();
-  return ++iter;
+	val = iter.get_byte();
+	return ++iter;
 }
 
 inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, bool &val)
 {
-  val = iter.get_bool();
-  return ++iter;
+	val = iter.get_bool();
+	return ++iter;
 }
 
-inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, int16_t &val)
+inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, int16_t& val)
 {
-  val = iter.get_int16();
-  return ++iter;
+	val = iter.get_int16();
+	return ++iter;
 }
 
-inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, uint16_t &val)
+inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, uint16_t& val)
 {
-  val = iter.get_uint16();
-  return ++iter;
+	val = iter.get_uint16();
+	return ++iter;
 }
 
-inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, int32_t &val)
+inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, int32_t& val)
 {
-  val = iter.get_int32();
-  return ++iter;
+	val = iter.get_int32();
+	return ++iter;
 }
 
-inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, uint32_t &val)
+inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, uint32_t& val)
 {
-  val = iter.get_uint32();
-  return ++iter;
+	val = iter.get_uint32();
+	return ++iter;
 }
 
-inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, int64_t &val)
+inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, int64_t& val)
 {
-  val = iter.get_int64();
-  return ++iter;
+	val = iter.get_int64();
+	return ++iter;
 }
 
-inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, uint64_t &val)
+inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, uint64_t& val)
 {
-  val = iter.get_uint64();
-  return ++iter;
+	val = iter.get_uint64();
+	return ++iter;
 }
 
 inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, double &val)
 {
-  val = iter.get_double();
-  return ++iter;
+	val = iter.get_double();
+	return ++iter;
 }
 
 inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, std::string &val)
 {
-  val = iter.get_string();
-  return ++iter;
+	val = iter.get_string();
+	return ++iter;
 }
 
 inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, DBus::Path &val)
 {
-  val = iter.get_path();
-  return ++iter;
+	val = iter.get_path();
+	return ++iter;
 }
 
 inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, DBus::Signature &val)
 {
-  val = iter.get_signature();
-  return ++iter;
+	val = iter.get_signature();
+	return ++iter;
+}
+
+inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, DBus::FileDescriptor &val)
+{
+	val = iter.get_fd();
+	return ++iter;
 }
 
+extern DXXAPI DBus::MessageIter &operator >> (DBus::MessageIter &iter, DBus::Variant &val);
+
 template<typename E>
 inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, std::vector<E>& val)
 {
-  if (!iter.is_array())
-    throw DBus::ErrorInvalidArgs("array expected");
+	if (!iter.is_array())
+		throw DBus::ErrorInvalidArgs("array expected");
 
-  DBus::MessageIter ait = iter.recurse();
+	DBus::MessageIter ait = iter.recurse();
 
-  while (!ait.at_end())
-  {
-    E elem;
+	while (!ait.at_end())
+	{
+		E elem;
 
-    ait >> elem;
+		ait >> elem;
 
-    val.push_back(elem);
-  }
-  return ++iter;
+		val.push_back(elem);
+	}
+	return ++iter;
 }
 
 template<>
 inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, std::vector<uint8_t>& val)
 {
-  if (!iter.is_array())
-    throw DBus::ErrorInvalidArgs("array expected");
+	if (!iter.is_array())
+		throw DBus::ErrorInvalidArgs("array expected");
 
-  if (iter.array_type() != 'y')
-    throw DBus::ErrorInvalidArgs("byte-array expected");
+	if (iter.array_type() != 'y')
+		throw DBus::ErrorInvalidArgs("byte-array expected");
 
-  DBus::MessageIter ait = iter.recurse();
+	DBus::MessageIter ait = iter.recurse();
 
-  uint8_t *array;
-  size_t length = ait.get_array(&array);
+	uint8_t *array;
+	size_t length = ait.get_array(&array);
 
-  val.insert(val.end(), array, array + length);
+	val.insert(val.end(), array, array+length);
 
-  return ++iter;
+	return ++iter;
 }
 
 template<typename K, typename V>
-inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, std::map<K, V>& val)
+inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, std::map<K,V>& val)
 {
-  if (!iter.is_dict())
-    throw DBus::ErrorInvalidArgs("dictionary value expected");
+	if (!iter.is_dict())
+		throw DBus::ErrorInvalidArgs("dictionary value expected");
 
-  DBus::MessageIter mit = iter.recurse();
+	DBus::MessageIter mit = iter.recurse();
 
-  while (!mit.at_end())
-  {
-    K key;
-    V value;
+	while (!mit.at_end())
+	{
+		K key; V value;
 
-    DBus::MessageIter eit = mit.recurse();
+		DBus::MessageIter eit = mit.recurse();
 
-    eit >> key >> value;
+		eit >> key >> value;
 
-    val[key] = value;
+		val[key] = value;
 
-    ++mit;
-  }
+		++mit;
+	}
 
-  return ++iter;
+	return ++iter;
 }
 
 template <
-typename T1,
-         typename T2,
-         typename T3,
-         typename T4,
-         typename T5,
-         typename T6,
-         typename T7,
-         typename T8,
-         typename T9,
-         typename T10,
-         typename T11,
-         typename T12,
-         typename T13,
-         typename T14,
-         typename T15,
-         typename T16
-         >
-inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, DBus::Struct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>& val)
-{
-  DBus::MessageIter sit = iter.recurse();
-
-  sit >> val._1 >> val._2 >> val._3 >> val._4
-      >> val._5 >> val._6 >> val._7 >> val._8
-      >> val._9 >> val._10 >> val._11 >> val._12
-      >> val._13 >> val._14 >> val._15 >> val._16;
-
-  return ++iter;
+	typename T1,
+	typename T2,
+	typename T3,
+	typename T4,
+	typename T5,
+	typename T6,
+	typename T7,
+	typename T8
+>
+inline DBus::MessageIter &operator >> (DBus::MessageIter &iter, DBus::Struct<T1,T2,T3,T4,T5,T6,T7,T8>& val)
+{
+	DBus::MessageIter sit = iter.recurse();
+
+	sit >> val._1 >> val._2 >> val._3 >> val._4 >> val._5 >> val._6 >> val._7 >> val._8;
+
+	return ++iter;
 }
 
-extern DXXAPI DBus::MessageIter &operator >> (DBus::MessageIter &iter, DBus::Variant &val);
+template <typename T>
+inline DBus::Variant::operator T() const
+{
+	T cast;
+	DBus::MessageIter ri = _msg.reader();
+	ri >> cast;
+	return cast;
+}
 
-#endif//__DBUSXX_TYPES_H
+} /* namespace DBus */
 
+#endif//__DBUSXX_TYPES_H
diff --git a/include/dbus-c++/util.h b/include/dbus-c++/util.h
index b8dca47..225e1ca 100644
--- a/include/dbus-c++/util.h
+++ b/include/dbus-c++/util.h
@@ -25,16 +25,10 @@
 #ifndef __DBUSXX_UTIL_H
 #define __DBUSXX_UTIL_H
 
-#include <sstream>
-#include <iostream>
-#include <iomanip>
-#include <cassert>
-
 #include "api.h"
 #include "debug.h"
 
-namespace DBus
-{
+namespace DBus {
 
 /*
  *   Very simple reference counting
@@ -44,65 +38,65 @@ class DXXAPI RefCnt
 {
 public:
 
-  RefCnt()
-  {
-    __ref = new int;
-    (*__ref) = 1;
-  }
-
-  RefCnt(const RefCnt &rc)
-  {
-    __ref = rc.__ref;
-    ref();
-  }
-
-  virtual ~RefCnt()
-  {
-    unref();
-  }
-
-  RefCnt &operator = (const RefCnt &ref)
-  {
-    ref.ref();
-    unref();
-    __ref = ref.__ref;
-    return *this;
-  }
-
-  bool noref() const
-  {
-    return (*__ref) == 0;
-  }
-
-  bool one() const
-  {
-    return (*__ref) == 1;
-  }
+	RefCnt()
+	{
+		__ref = new int;
+		(*__ref) = 1;
+	}
+
+	RefCnt(const RefCnt &rc)
+	{
+		__ref = rc.__ref;
+		ref();
+	}
+
+	virtual ~RefCnt()
+	{
+		unref();
+	}
+
+	RefCnt &operator = (const RefCnt &ref)
+	{
+		ref.ref();
+		unref();
+		__ref = ref.__ref;
+		return *this;
+	}
+
+	bool noref() const
+	{
+		return (*__ref) == 0;
+	}
+
+	bool one() const
+	{
+		return (*__ref) == 1;
+	}
 
 private:
 
-  DXXAPILOCAL void ref() const
-  {
-    ++ (*__ref);
-  }
-  DXXAPILOCAL void unref() const
-  {
-    -- (*__ref);
-
-    if ((*__ref) < 0)
-    {
-      debug_log("%p: refcount dropped below zero!", __ref);
-    }
-
-    if (noref())
-    {
-      delete __ref;
-    }
-  }
+	DXXAPILOCAL void ref() const
+	{
+		++ (*__ref);
+	}
+	DXXAPILOCAL void unref() const
+	{
+		-- (*__ref);
+
+		if ((*__ref) < 0)
+		{
+			debug_log("%p: refcount dropped below zero!", __ref);
+		}
+
+		if (noref())
+		{
+			delete __ref;
+		}
+	}
 
 private:
 
-  int *__ref;
+	int *__ref;
 };
 
 /*
@@ -114,45 +108,45 @@ class RefPtrI		// RefPtr to incomplete type
 {
 public:
 
-  RefPtrI(T *ptr = 0);
-
-  ~RefPtrI();
-
-  RefPtrI &operator = (const RefPtrI &ref)
-  {
-    if (this != &ref)
-    {
-      if (__cnt.one()) delete __ptr;
-
-      __ptr = ref.__ptr;
-      __cnt = ref.__cnt;
-    }
-    return *this;
-  }
-
-  T &operator *() const
-  {
-    return *__ptr;
-  }
-
-  T *operator ->() const
-  {
-    if (__cnt.noref()) return 0;
-
-    return __ptr;
-  }
-
-  T *get() const
-  {
-    if (__cnt.noref()) return 0;
-
-    return __ptr;
-  }
+	RefPtrI(T *ptr = 0);
+
+	~RefPtrI();
+
+	RefPtrI &operator = (const RefPtrI &ref)
+	{
+		if (this != &ref)
+		{
+			if (__cnt.one()) delete __ptr;
+
+			__ptr = ref.__ptr;
+			__cnt = ref.__cnt;
+		}
+		return *this;
+	}
+
+	T &operator *() const
+	{
+		return *__ptr;
+	}
+
+	T *operator ->() const
+	{
+		if (__cnt.noref()) return 0;
+		
+		return __ptr;
+	}
+
+	T *get() const
+	{
+		if (__cnt.noref()) return 0;
+		
+		return __ptr;
+	}
 
 private:
 
-  T *__ptr;
-  RefCnt __cnt;
+	T *__ptr;
+	RefCnt __cnt;
 };
 
 template <class T>
@@ -160,50 +154,50 @@ class RefPtr
 {
 public:
 
-  RefPtr(T *ptr = 0)
-    : __ptr(ptr)
-  {}
-
-  ~RefPtr()
-  {
-    if (__cnt.one()) delete __ptr;
-  }
-
-  RefPtr &operator = (const RefPtr &ref)
-  {
-    if (this != &ref)
-    {
-      if (__cnt.one()) delete __ptr;
-
-      __ptr = ref.__ptr;
-      __cnt = ref.__cnt;
-    }
-    return *this;
-  }
-
-  T &operator *() const
-  {
-    return *__ptr;
-  }
-
-  T *operator ->() const
-  {
-    if (__cnt.noref()) return 0;
-
-    return __ptr;
-  }
-
-  T *get() const
-  {
-    if (__cnt.noref()) return 0;
-
-    return __ptr;
-  }
+	RefPtr(T *ptr = 0)
+	: __ptr(ptr)
+	{}
+
+	~RefPtr()
+	{
+		if (__cnt.one()) delete __ptr;
+	}
+
+	RefPtr &operator = (const RefPtr &ref)
+	{
+		if (this != &ref)
+		{
+			if (__cnt.one()) delete __ptr;
+
+			__ptr = ref.__ptr;
+			__cnt = ref.__cnt;
+		}
+		return *this;
+	}
+
+	T &operator *() const
+	{
+		return *__ptr;
+	}
+
+	T *operator ->() const
+	{
+		if (__cnt.noref()) return 0;
+		
+		return __ptr;
+	}
+
+	T *get() const
+	{
+		if (__cnt.noref()) return 0;
+		
+		return __ptr;
+	}
 
 private:
 
-  T *__ptr;
-  RefCnt __cnt;
+	T *__ptr;
+	RefCnt __cnt;
 };
 
 /*
@@ -215,10 +209,10 @@ class Callback_Base
 {
 public:
 
-  virtual R call(P param) const = 0;
+	virtual R call(P param) const = 0;
 
-  virtual ~Callback_Base()
-  {}
+	virtual ~Callback_Base()
+	{}
 };
 
 template <class R, class P>
@@ -226,78 +220,54 @@ class Slot
 {
 public:
 
-  Slot &operator = (Callback_Base<R, P>* s)
-  {
-    _cb = s;
-
-    return *this;
-  }
-
-  R operator()(P param) const
-  {
-    if (!empty())
-    {
-      return _cb->call(param);
-    }
-
-    // TODO: think about return type in this case
-    // this assert should help me to find the use case where it's needed...
-    //assert (false);
-  }
-
-  R call(P param) const
-  {
-    if (!empty())
-    {
-      return _cb->call(param);
-    }
-
-    // TODO: think about return type in this case
-    // this assert should help me to find the use case where it's needed...
-    //assert (false);
-  }
-
-  bool empty() const
-  {
-    return _cb.get() == 0;
-  }
+	Slot &operator = (Callback_Base<R,P>* s)
+	{
+		_cb = s;
+
+		return *this;
+	}
+
+	R operator()(P param) const
+	{
+		/*if (_cb.get())*/ return _cb->call(param);
+	}
+
+	R call(P param) const
+	{
+		/*if (_cb.get())*/ return _cb->call(param);
+	}
+
+	bool empty()
+	{
+		return _cb.get() == 0;
+	}
 
 private:
 
-  RefPtr< Callback_Base<R, P> > _cb;
+	RefPtr< Callback_Base<R,P> > _cb;
 };
 
 template <class C, class R, class P>
-class Callback : public Callback_Base<R, P>
+class Callback : public Callback_Base<R,P>
 {
 public:
 
-  typedef R(C::*M)(P);
+	typedef R (C::*M)(P);
 
-  Callback(C *c, M m)
-    : _c(c), _m(m)
-  {}
+	Callback(C *c, M m)
+	: _c(c), _m(m)
+	{}
 
-  R call(P param) const
-  {
-    /*if (_c)*/ return (_c->*_m)(param);
-  }
+	R call(P param) const
+	{
+		/*if (_c)*/ return (_c->*_m)(param);
+	}
 
 private:
 
-  C *_c;
-  M _m;
+	C *_c; M _m;
 };
 
-/// create std::string from any number
-template <typename T>
-std::string toString(const T &thing, int w = 0, int p = 0)
-{
-  std::ostringstream os;
-  os << std::setw(w) << std::setprecision(p) << thing;
-  return os.str();
-}
-
 } /* namespace DBus */
 
 #endif//__DBUSXX_UTIL_H
diff --git a/src/Makefile.am b/src/Makefile.am
index 802fcfc..6a358a4 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1,70 +1,50 @@
-lib_LTLIBRARIES = \
-	libdbus-c++-1.la
-
-libdbus_c___1_la_SOURCES = \
-	connection.cpp    \
-	connection_p.h    \
-	debug.cpp    \
-	dispatcher.cpp    \
-	dispatcher_p.h    \
-	error.cpp    \
-	eventloop.cpp    \
-	eventloop-integration.cpp    \
-	interface.cpp    \
-	internalerror.h    \
-	introspection.cpp    \
-	message.cpp    \
-	message_p.h    \
-	object.cpp    \
-	pendingcall.cpp    \
-	pendingcall_p.h    \
-	pipe.cpp    \
-	property.cpp    \
-	server.cpp    \
-	server_p.h    \
-	types.cpp    
-
-libdbus_c___1_la_CXXFLAGS = \
-	-I$(top_srcdir)/include \
-	-Wno-unused-parameter
-
-libdbus_c___1_la_LIBADD = \
-	$(dbus_LIBS)
-
 AM_CPPFLAGS = \
 	$(dbus_CFLAGS) \
 	$(glib_CFLAGS) \
-	$(ecore_CFLAGS)
-
-SUBDIRS = \
-	integration
-
-HEADER_DIR  = $(top_srcdir)/include/dbus-c++
-libdbus_c___1_HEADERS = \
-	$(HEADER_DIR)/api.h          \
-	$(HEADER_DIR)/connection.h          \
-	$(HEADER_DIR)/dbus.h          \
-	$(HEADER_DIR)/debug.h          \
-	$(HEADER_DIR)/dispatcher.h          \
-	$(HEADER_DIR)/error.h          \
-	$(HEADER_DIR)/eventloop.h          \
-	$(HEADER_DIR)/eventloop-integration.h          \
-	$(HEADER_DIR)/interface.h          \
-	$(HEADER_DIR)/introspection.h          \
-	$(HEADER_DIR)/message.h          \
-	$(HEADER_DIR)/object.h          \
-	$(HEADER_DIR)/pendingcall.h          \
-	$(HEADER_DIR)/pipe.h          \
-	$(HEADER_DIR)/property.h          \
-	$(HEADER_DIR)/refptr_impl.h          \
-	$(HEADER_DIR)/server.h          \
-	$(HEADER_DIR)/types.h          \
-	$(HEADER_DIR)/util.h
-
-libdbus_c___1dir=$(includedir)/dbus-c++-1/dbus-c++/
+	$(ecore_CFLAGS) \
+	$(PTHREAD_CFLAGS) \
+	$(PRIVATE_CFLAGS) \
+	-I$(top_srcdir)/include \
+	-I$(top_builddir)/include
 
-EXTRA_DIST = \
-	$(libdbus_c___1_HEADERS)
+if ENABLE_GLIB
+GLIB_H = $(HEADER_DIR)/glib-integration.h
+GLIB_CPP = glib-integration.cpp
+endif
 
-## File created by the gnome-build tools
+if ENABLE_ECORE
+ECORE_H = $(HEADER_DIR)/ecore-integration.h
+ECORE_CPP = ecore-integration.cpp
+endif
 
+HEADER_DIR  = $(top_srcdir)/include/dbus-c++
+HEADER_FILES = \
+	$(HEADER_DIR)/dbus.h \
+	$(HEADER_DIR)/types.h \
+	$(HEADER_DIR)/connection.h \
+	$(HEADER_DIR)/property.h \
+	$(HEADER_DIR)/debug.h \
+	$(HEADER_DIR)/error.h \
+	$(HEADER_DIR)/interface.h \
+	$(HEADER_DIR)/message.h \
+	$(HEADER_DIR)/dispatcher.h \
+	$(HEADER_DIR)/object.h \
+	$(HEADER_DIR)/pendingcall.h \
+	$(HEADER_DIR)/server.h \
+	$(HEADER_DIR)/util.h \
+	$(HEADER_DIR)/refptr_impl.h \
+	$(HEADER_DIR)/introspection.h \
+	$(HEADER_DIR)/api.h \
+	$(HEADER_DIR)/eventloop.h \
+	$(HEADER_DIR)/eventloop-integration.h \
+	$(GLIB_H) $(ECORE_H)
+
+lib_includedir=$(includedir)/dbus-c++-1/dbus-c++/
+lib_include_HEADERS = $(HEADER_FILES)
+
+lib_LTLIBRARIES = libdbus-c++-1.la
+libdbus_c___1_la_SOURCES = $(HEADER_FILES) interface.cpp object.cpp introspection.cpp debug.cpp types.cpp connection.cpp connection_p.h property.cpp dispatcher.cpp dispatcher_p.h pendingcall.cpp pendingcall_p.h error.cpp internalerror.h message.cpp message_p.h server.cpp server_p.h eventloop.cpp eventloop-integration.cpp $(GLIB_CPP) $(ECORE_CPP)
+libdbus_c___1_la_LIBADD = $(dbus_LIBS) $(glib_LIBS) $(PTHREAD_CFLAGS) $(PTHREAD_LIBS) $(ecore_LIBS)
+
+MAINTAINERCLEANFILES = \
+	Makefile.in
diff --git a/src/connection.cpp b/src/connection.cpp
index a203d73..10d96bd 100644
--- a/src/connection.cpp
+++ b/src/connection.cpp
@@ -42,433 +42,488 @@
 using namespace DBus;
 
 Connection::Private::Private(DBusConnection *c, Server::Private *s)
-  : conn(c) , dispatcher(NULL), server(s)
+: conn(c) , dispatcher(0), server(s)
 {
-  init();
+	init();
 }
 
 Connection::Private::Private(DBusBusType type)
-  : dispatcher(NULL), server(NULL)
 {
-  InternalError e;
+	InternalError e;
 
-  conn = dbus_bus_get_private(type, e);
+	conn = dbus_bus_get_private(type, e);
 
-  if (e) throw Error(e);
+	if (e) throw Error(e);
 
-  init();
+	init();
 }
 
 Connection::Private::~Private()
 {
-  debug_log("terminating connection 0x%08x", conn);
+	debug_log("terminating connection 0x%08x", conn);
 
-  detach_server();
+	detach_server();
 
-  if (dbus_connection_get_is_connected(conn))
-  {
-    std::vector<std::string>::iterator i = names.begin();
+	if (dbus_connection_get_is_connected(conn))
+	{
+		std::vector<std::string>::iterator i = names.begin();
 
-    while (i != names.end())
-    {
-      debug_log("%s: releasing bus name %s", dbus_bus_get_unique_name(conn), i->c_str());
-      dbus_bus_release_name(conn, i->c_str(), NULL);
-      ++i;
-    }
-    dbus_connection_close(conn);
-  }
-  dbus_connection_unref(conn);
+		while (i != names.end())
+		{
+			debug_log("%s: releasing bus name %s", dbus_bus_get_unique_name(conn), i->c_str());
+			dbus_bus_release_name(conn, i->c_str(), NULL);
+			++i;
+		}
+		dbus_connection_close(conn);
+	}
+	dbus_connection_unref(conn);
 }
 
 void Connection::Private::init()
 {
-  dbus_connection_ref(conn);
-  dbus_connection_ref(conn);	//todo: the library has to own another reference
+	dbus_connection_ref(conn);
+	dbus_connection_ref(conn);	//todo: the library has to own another reference
 
-  disconn_filter = new Callback<Connection::Private, bool, const Message &>(
-    this, &Connection::Private::disconn_filter_function
-  );
+	disconn_filter = new Callback<Connection::Private, bool, const Message &>(
+		this, &Connection::Private::disconn_filter_function
+	);
 
-  dbus_connection_add_filter(conn, message_filter_stub, &disconn_filter, NULL); // TODO: some assert at least
+	dbus_connection_add_filter(conn, message_filter_stub, &disconn_filter, NULL); // TODO: some assert at least
 
-  dbus_connection_set_dispatch_status_function(conn, dispatch_status_stub, this, 0);
-  dbus_connection_set_exit_on_disconnect(conn, false); //why was this set to true??
+	dbus_connection_set_dispatch_status_function(conn, dispatch_status_stub, this, 0);
+	dbus_connection_set_exit_on_disconnect(conn, false); //why was this set to true??
 }
 
 void Connection::Private::detach_server()
 {
-  /*	Server::Private *tmp = server;
+/*	Server::Private *tmp = server;
 
-  	server = NULL;
+	server = NULL;
 
-  	if (tmp)
-  	{
-  		ConnectionList::iterator i;
+	if (tmp)
+	{
+		ConnectionList::iterator i;
 
-  		for (i = tmp->connections.begin(); i != tmp->connections.end(); ++i)
-  		{
-  			if (i->_pvt.get() == this)
-  			{
-  				tmp->connections.erase(i);
-  				break;
-  			}
-  		}
-  	}*/
+		for (i = tmp->connections.begin(); i != tmp->connections.end(); ++i)
+		{
+			if (i->_pvt.get() == this)
+			{
+				tmp->connections.erase(i);
+				break;
+			}
+		}
+	}*/
 }
 
 bool Connection::Private::do_dispatch()
 {
-  debug_log("dispatching on %p", conn);
+	debug_log("dispatching on %p", conn);
 
-  if (!dbus_connection_get_is_connected(conn))
-  {
-    debug_log("connection terminated");
+	if (!dbus_connection_get_is_connected(conn))
+	{
+		debug_log("connection terminated");
 
-    detach_server();
+		detach_server();
 
-    return true;
-  }
+		return true;
+	}
 
-  return dbus_connection_dispatch(conn) != DBUS_DISPATCH_DATA_REMAINS;
+	return dbus_connection_dispatch(conn) != DBUS_DISPATCH_DATA_REMAINS;
 }
 
 void Connection::Private::dispatch_status_stub(DBusConnection *dc, DBusDispatchStatus status, void *data)
 {
-  Private *p = static_cast<Private *>(data);
+	Private *p = static_cast<Private *>(data);
 
-  switch (status)
-  {
-  case DBUS_DISPATCH_DATA_REMAINS:
-    debug_log("some dispatching to do on %p", dc);
-    p->dispatcher->queue_connection(p);
-    break;
+	switch (status)
+	{
+		case DBUS_DISPATCH_DATA_REMAINS:
+		debug_log("some dispatching to do on %p", dc);
+		p->dispatcher->queue_connection(p);
+		break;
 
-  case DBUS_DISPATCH_COMPLETE:
-    debug_log("all dispatching done on %p", dc);
-    break;
+		case DBUS_DISPATCH_COMPLETE:
+		debug_log("all dispatching done on %p", dc);
+		break;
 
-  case DBUS_DISPATCH_NEED_MEMORY: //uh oh...
-    debug_log("connection %p needs memory", dc);
-    break;
-  }
+		case DBUS_DISPATCH_NEED_MEMORY: //uh oh...
+		debug_log("connection %p needs memory", dc);
+		break;
+	}
 }
 
 DBusHandlerResult Connection::Private::message_filter_stub(DBusConnection *conn, DBusMessage *dmsg, void *data)
 {
-  MessageSlot *slot = static_cast<MessageSlot *>(data);
+	MessageSlot *slot = static_cast<MessageSlot *>(data);
 
-  Message msg = Message(new Message::Private(dmsg));
+	Message msg = Message(new Message::Private(dmsg));
 
-  return slot && !slot->empty() && slot->call(msg)
-         ? DBUS_HANDLER_RESULT_HANDLED
-         : DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+	return slot && !slot->empty() && slot->call(msg) 
+			? DBUS_HANDLER_RESULT_HANDLED
+			: DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 }
 
 bool Connection::Private::disconn_filter_function(const Message &msg)
 {
-  if (msg.is_signal(DBUS_INTERFACE_LOCAL, "Disconnected"))
-  {
-    debug_log("%p disconnected by local bus", conn);
-    dbus_connection_close(conn);
+	if (msg.is_signal(DBUS_INTERFACE_LOCAL,"Disconnected"))
+	{
+		debug_log("%p disconnected by local bus", conn);
+		dbus_connection_close(conn);
 
-    return true;
-  }
-  return false;
+		return true;
+	}
+	return false;
 }
 
 DBusDispatchStatus Connection::Private::dispatch_status()
 {
-  return dbus_connection_get_dispatch_status(conn);
+	return dbus_connection_get_dispatch_status(conn);
 }
 
 bool Connection::Private::has_something_to_dispatch()
 {
-  return dispatch_status() == DBUS_DISPATCH_DATA_REMAINS;
+	return dispatch_status() == DBUS_DISPATCH_DATA_REMAINS;
 }
 
 
 Connection Connection::SystemBus()
 {
-  return Connection(new Private(DBUS_BUS_SYSTEM));
+	return Connection(new Private(DBUS_BUS_SYSTEM));
 }
 
 Connection Connection::SessionBus()
 {
-  return Connection(new Private(DBUS_BUS_SESSION));
+	return Connection(new Private(DBUS_BUS_SESSION));
 }
 
 Connection Connection::ActivationBus()
 {
-  return Connection(new Private(DBUS_BUS_STARTER));
+	return Connection(new Private(DBUS_BUS_STARTER));
 }
 
 Connection::Connection(const char *address, bool priv)
-  : _timeout(-1)
+: _timeout(-1)
 {
-  InternalError e;
-  DBusConnection *conn = priv
-                         ? dbus_connection_open_private(address, e)
-                         : dbus_connection_open(address, e);
+	InternalError e;
+	DBusConnection *conn = priv 
+		? dbus_connection_open_private(address, e)
+		: dbus_connection_open(address, e);
 
-  if (e) throw Error(e);
+	if (e) throw Error(e);
 
-  _pvt = new Private(conn);
+	_pvt = new Private(conn);
 
-  setup(default_dispatcher);
+	setup(default_dispatcher);
 
-  debug_log("connected to %s", address);
+	debug_log("connected to %s", address);
 }
 
 Connection::Connection(Connection::Private *p)
-  : _pvt(p), _timeout(-1)
+: _pvt(p), _timeout(-1)
 {
-  setup(default_dispatcher);
+	setup(default_dispatcher);
 }
 
 Connection::Connection(const Connection &c)
-  : _pvt(c._pvt), _timeout(c._timeout)
+: _pvt(c._pvt),_timeout(c._timeout)
 {
-  dbus_connection_ref(_pvt->conn);
+	dbus_connection_ref(_pvt->conn);
 }
 
 Connection::~Connection()
 {
-  dbus_connection_unref(_pvt->conn);
+	dbus_connection_unref(_pvt->conn);
 }
 
 Dispatcher *Connection::setup(Dispatcher *dispatcher)
 {
-  debug_log("registering stubs for connection %p", _pvt->conn);
+	debug_log("registering stubs for connection %p", _pvt->conn);
 
-  if (!dispatcher) dispatcher = default_dispatcher;
+	if (!dispatcher) dispatcher = default_dispatcher;
 
-  if (!dispatcher) throw ErrorFailed("no default dispatcher set for new connection");
+	if (!dispatcher) throw ErrorFailed("no default dispatcher set for new connection");
 
-  Dispatcher *prev = _pvt->dispatcher;
+	Dispatcher *prev = _pvt->dispatcher;
 
-  _pvt->dispatcher = dispatcher;
+	_pvt->dispatcher = dispatcher;
 
-  dispatcher->queue_connection(_pvt.get());
+	dispatcher->queue_connection(_pvt.get());
 
-  dbus_connection_set_watch_functions(
-    _pvt->conn,
-    Dispatcher::Private::on_add_watch,
-    Dispatcher::Private::on_rem_watch,
-    Dispatcher::Private::on_toggle_watch,
-    dispatcher,
-    0
-  );
+	dbus_connection_set_watch_functions(
+		_pvt->conn,
+		Dispatcher::Private::on_add_watch,
+		Dispatcher::Private::on_rem_watch,
+		Dispatcher::Private::on_toggle_watch,
+		dispatcher,
+		0
+	);
 
-  dbus_connection_set_timeout_functions(
-    _pvt->conn,
-    Dispatcher::Private::on_add_timeout,
-    Dispatcher::Private::on_rem_timeout,
-    Dispatcher::Private::on_toggle_timeout,
-    dispatcher,
-    0
-  );
+	dbus_connection_set_timeout_functions(
+		_pvt->conn,
+		Dispatcher::Private::on_add_timeout,
+		Dispatcher::Private::on_rem_timeout,
+		Dispatcher::Private::on_toggle_timeout,
+		dispatcher,
+		0
+	);
 
-  return prev;
+	return prev;
 }
 
 bool Connection::operator == (const Connection &c) const
 {
-  return _pvt->conn == c._pvt->conn;
+	return _pvt->conn == c._pvt->conn;
 }
 
 bool Connection::register_bus()
 {
-  InternalError e;
+	InternalError e;
 
-  bool r = dbus_bus_register(_pvt->conn, e);
+	bool r = dbus_bus_register(_pvt->conn, e);
+  
+	if (e) throw (e);
 
-  if (e) throw(e);
-
-  return r;
+	return r;
 }
 
 bool Connection::connected() const
 {
-  return dbus_connection_get_is_connected(_pvt->conn);
+	return dbus_connection_get_is_connected(_pvt->conn);
 }
 
 void Connection::disconnect()
 {
 //	dbus_connection_disconnect(_pvt->conn); // disappeared in 0.9x
-  dbus_connection_close(_pvt->conn);
+	dbus_connection_close(_pvt->conn);
 }
 
 void Connection::exit_on_disconnect(bool exit)
 {
-  dbus_connection_set_exit_on_disconnect(_pvt->conn, exit);
+	dbus_connection_set_exit_on_disconnect(_pvt->conn, exit);
 }
 
 bool Connection::unique_name(const char *n)
 {
-  return dbus_bus_set_unique_name(_pvt->conn, n);
+	return dbus_bus_set_unique_name(_pvt->conn, n);
 }
 
 const char *Connection::unique_name() const
 {
-  return dbus_bus_get_unique_name(_pvt->conn);
+	return dbus_bus_get_unique_name(_pvt->conn);
 }
 
 void Connection::flush()
 {
-  dbus_connection_flush(_pvt->conn);
+	dbus_connection_flush(_pvt->conn);
 }
 
 void Connection::add_match(const char *rule)
 {
-  InternalError e;
+	InternalError e;
 
-  dbus_bus_add_match(_pvt->conn, rule, e);
+	dbus_bus_add_match(_pvt->conn, rule, e);
 
-  debug_log("%s: added match rule %s", unique_name(), rule);
+	debug_log("%s: added match rule %s", unique_name(), rule);
 
-  if (e) throw Error(e);
+	if (e) throw Error(e);
 }
 
-void Connection::remove_match(const char	*rule,
-                              bool		throw_on_error)
+void Connection::remove_match(const char *rule)
 {
-  InternalError e;
-
-  dbus_bus_remove_match(_pvt->conn, rule, e);
+	InternalError e;
+	
+	dbus_bus_remove_match(_pvt->conn, rule, e);
 
-  debug_log("%s: removed match rule %s", unique_name(), rule);
+	debug_log("%s: removed match rule %s", unique_name(), rule);
 
-  if (e)
-  {
-    if (throw_on_error)
-      throw Error(e);
-    else
-      debug_log("DBus::Connection::remove_match: %s (%s).",
-                static_cast<DBusError *>(e)->message,
-                static_cast<DBusError *>(e)->name);
-  }
+	if (e) throw Error(e);
 }
 
 bool Connection::add_filter(MessageSlot &s)
 {
-  debug_log("%s: adding filter", unique_name());
-  return dbus_connection_add_filter(_pvt->conn, Private::message_filter_stub, &s, NULL);
+	debug_log("%s: adding filter", unique_name());
+	return dbus_connection_add_filter(_pvt->conn, Private::message_filter_stub, &s, NULL);
 }
 
 void Connection::remove_filter(MessageSlot &s)
 {
-  debug_log("%s: removing filter", unique_name());
-  dbus_connection_remove_filter(_pvt->conn, Private::message_filter_stub, &s);
+	debug_log("%s: removing filter", unique_name());
+	dbus_connection_remove_filter(_pvt->conn, Private::message_filter_stub, &s);
 }
 
 bool Connection::send(const Message &msg, unsigned int *serial)
 {
-  return dbus_connection_send(_pvt->conn, msg._pvt->msg, serial);
+	return dbus_connection_send(_pvt->conn, msg._pvt->msg, serial);
 }
 
 Message Connection::send_blocking(Message &msg, int timeout)
 {
-  DBusMessage *reply;
-  InternalError e;
-
-  if (this->_timeout != -1)
-  {
-    reply = dbus_connection_send_with_reply_and_block(_pvt->conn, msg._pvt->msg, this->_timeout, e);
-  }
-  else
-  {
-    reply = dbus_connection_send_with_reply_and_block(_pvt->conn, msg._pvt->msg, timeout, e);
-  }
+	DBusMessage *reply;
+	InternalError e;
+	
+	if (this->_timeout != -1)
+	{
+		reply = dbus_connection_send_with_reply_and_block(_pvt->conn, msg._pvt->msg, this->_timeout, e);
+	}
+	else
+	{
+		reply = dbus_connection_send_with_reply_and_block(_pvt->conn, msg._pvt->msg, timeout, e);
+	}
 
-  if (e) throw Error(e);
+	if (e) throw Error(e);
 
-  return Message(new Message::Private(reply), false);
+	return Message(new Message::Private(reply), false);
 }
 
-PendingCall Connection::send_async(Message &msg, int timeout)
+PendingCall *Connection::send_async(Message &msg, int timeout)
 {
-  DBusPendingCall *pending;
+	DBusPendingCall *pending;
 
-  if (!dbus_connection_send_with_reply(_pvt->conn, msg._pvt->msg, &pending, timeout))
-  {
-    throw ErrorNoMemory("Unable to start asynchronous call");
-  }
-  return PendingCall(new PendingCall::Private(pending));
+	// TODO(ers) At the moment using a timeout other than -1
+	// results in a deadlock if the timeout expires.
+	if (!dbus_connection_send_with_reply(_pvt->conn, msg._pvt->msg, &pending, timeout))
+	{
+		throw ErrorNoMemory("Unable to start asynchronous call");
+	}
+	return new PendingCall(new PendingCall::Private(pending));
 }
 
-void Connection::request_name(const char *name, int flags)
+int Connection::_request_name(const char *name, int flags)
 {
-  InternalError e;
+	InternalError e;
 
-  debug_log("%s: registering bus name %s", unique_name(), name);
+	debug_log("%s: registering bus name %s", unique_name(), name);
 
-  /*
-   * TODO:
-   * Think about giving back the 'ret' value. Some people on the list
-   * requested about this...
-   */
-  int ret = dbus_bus_request_name(_pvt->conn, name, flags, e);
+	int ret = dbus_bus_request_name(_pvt->conn, name, flags, e);
 
-  if (ret == -1)
-  {
-    if (e) throw Error(e);
-  }
+	if (ret == -1)
+	{
+		if (e) throw Error(e);
+	}
 
 //	this->remove_match("destination");
 
-  if (name)
-  {
-    _pvt->names.push_back(name);
-    std::string match = "destination='" + _pvt->names.back() + "'";
-    add_match(match.c_str());
-  }
+	if (name)
+	{
+		_pvt->names.push_back(name);
+		std::string match = "destination='" + _pvt->names.back() + "'";
+		add_match(match.c_str());
+	}
+
+	return ret;
 }
 
-unsigned long Connection::sender_unix_uid(const char *sender)
+void Connection::request_name(const char *name, int flags)
 {
-  InternalError e;
-
-  unsigned long ul = dbus_bus_get_unix_user(_pvt->conn, sender, e);
-
-  if (e) throw Error(e);
+	/*
+	 * TODO:
+	 * Think about giving back the 'ret' value. Some people on the list
+	 * requested about this...
+	 */
+	_request_name(name, flags);
+}
+
+bool Connection::acquire_name(const char *name)
+{
+	/*
+	 * Request the desired name, allowing the request to be queued.
+	 */
+	int ret = _request_name(name, 0);
+	switch (ret) {
+		case DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER:
+		case DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER:
+			return true;
+		case DBUS_REQUEST_NAME_REPLY_IN_QUEUE:
+			break;
+		case DBUS_REQUEST_NAME_REPLY_EXISTS:
+		default:
+			// Unexpected, but try to keep going.
+			debug_log("%s: unexpected reply %d for RequestName",
+				  dbus_bus_get_unique_name(_pvt->conn), ret);
+			break;
+	}
+
+	/*
+	 * We didn't get the name. Perhaps the name owner terminated
+	 * abruptly, and dbus-daemon doesn't know that yet.  Ask
+	 * dbus-daemon to check if the name owner is still up.
+	 */
+	CallMessage ping_request(name, "/", "org.freedesktop.DBus.Peer", "Ping");
+	try {
+		send_blocking(ping_request, DBUS_TIMEOUT_USE_DEFAULT);
+	} catch (const DBus::Error &) {
+		/*
+		 * We don't care if the ping request times out or generates
+                 * some other error. We only care about its side-effect.
+		 */
+	}
+
+	/*
+	 * Now that we've nudged dbus-daemon, try requesting the name
+	 * one more time. Note that we may already be the owner at
+	 * this point, because our first attempt allowed queuing the
+	 * request.
+	 */
+	ret = _request_name(name, DBUS_NAME_FLAG_DO_NOT_QUEUE);
+	switch (ret) {
+		case DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER:
+		case DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER:
+			return true;
+		case DBUS_REQUEST_NAME_REPLY_EXISTS:
+			return false;
+		case DBUS_REQUEST_NAME_REPLY_IN_QUEUE:
+		default:
+			// Log unexpected response.
+			debug_log("%s: unexpected reply %d for RequestName",
+				  dbus_bus_get_unique_name(_pvt->conn), ret);
+			return false;
+	}
+}
 
-  return ul;
+unsigned long Connection::sender_unix_uid(const char *sender)
+{
+    InternalError e;
+    
+    unsigned long ul = dbus_bus_get_unix_user(_pvt->conn, sender, e);
+    
+    if (e) throw Error(e);
+    
+    return ul;
 }
 
 bool Connection::has_name(const char *name)
-{
-  InternalError e;
+{	
+	InternalError e;
 
-  bool b = dbus_bus_name_has_owner(_pvt->conn, name, e);
+	bool b = dbus_bus_name_has_owner(_pvt->conn, name, e);
 
-  if (e) throw Error(e);
+	if (e) throw Error(e);
 
-  return b;
+	return b;
 }
 
 const std::vector<std::string>& Connection::names()
 {
-  return _pvt->names;
+	return _pvt->names;
 }
 
 bool Connection::start_service(const char *name, unsigned long flags)
 {
-  InternalError e;
-
-  bool b = dbus_bus_start_service_by_name(_pvt->conn, name, flags, NULL, e);
+	InternalError e;
 
-  if (e) throw Error(e);
+	bool b = dbus_bus_start_service_by_name(_pvt->conn, name, flags, NULL, e);
 
-  return b;
+	if (e) throw Error(e);
+	
+	return b;
 }
 
 void Connection::set_timeout(int timeout)
 {
-  _timeout = timeout;
+	_timeout=timeout;
 }
-
+	
 int Connection::get_timeout()
 {
-  return _timeout;
+	return _timeout;
 }
-
diff --git a/src/connection_p.h b/src/connection_p.h
index a54d3b3..a6ea96c 100644
--- a/src/connection_p.h
+++ b/src/connection_p.h
@@ -38,38 +38,37 @@
 
 #include <string>
 
-namespace DBus
-{
+namespace DBus {
 
 struct DXXAPILOCAL Connection::Private
 {
-  DBusConnection 	*conn;
+	DBusConnection *	conn;
 
-  std::vector<std::string> names;
+	std::vector<std::string> names;
 
-  Dispatcher *dispatcher;
-  bool do_dispatch();
+	Dispatcher *dispatcher;
+	bool do_dispatch();
 
-  MessageSlot disconn_filter;
-  bool disconn_filter_function(const Message &);
+	MessageSlot disconn_filter;
+	bool disconn_filter_function(const Message &);
 
-  Server::Private *server;
-  void detach_server();
+	Server::Private *server;
+	void detach_server();
 
-  Private(DBusConnection *, Server::Private * = NULL);
+	Private(DBusConnection *, Server::Private * = NULL);
 
-  Private(DBusBusType);
+	Private(DBusBusType);
 
-  ~Private();
+	~Private();
 
-  void init();
+	void init();
 
-  DBusDispatchStatus dispatch_status();
-  bool has_something_to_dispatch();
+	DBusDispatchStatus dispatch_status();
+	bool has_something_to_dispatch();
 
-  static void dispatch_status_stub(DBusConnection *, DBusDispatchStatus, void *);
+	static void dispatch_status_stub(DBusConnection *, DBusDispatchStatus, void *);
 
-  static DBusHandlerResult message_filter_stub(DBusConnection *, DBusMessage *, void *);
+	static DBusHandlerResult message_filter_stub(DBusConnection *, DBusMessage *, void *);
 };
 
 } /* namespace DBus */
diff --git a/src/debug.cpp b/src/debug.cpp
index 91f8550..4f97dae 100644
--- a/src/debug.cpp
+++ b/src/debug.cpp
@@ -33,23 +33,23 @@
 
 static void _debug_log_default(const char *format, ...)
 {
-//#ifdef DEBUG
+#ifdef DEBUG
 
-  static int debug_env = getenv("DBUSXX_VERBOSE") ? 1 : 0;
+	static int debug_env = getenv("DBUSXX_VERBOSE") ? 1 : 0;
 
-  if (debug_env)
-  {
-    va_list args;
-    va_start(args, format);
+	if (debug_env)
+	{
+	        va_list args;
+	        va_start(args, format);
 
-    fprintf(stderr, "dbus-c++: ");
-    vfprintf(stderr, format, args);
-    fprintf(stderr, "\n");
+	        fprintf(stderr, "dbus-c++: ");
+	        vfprintf(stderr, format, args);
+	        fprintf(stderr, "\n");
 
-    va_end(args);
-  }
+	        va_end(args);
+	}
 
-//#endif//DEBUG
+#endif//DEBUG
 }
 
 DBus::LogFunction DBus::debug_log = _debug_log_default;
diff --git a/src/dispatcher.cpp b/src/dispatcher.cpp
index bc07d71..37bd279 100644
--- a/src/dispatcher.cpp
+++ b/src/dispatcher.cpp
@@ -25,6 +25,8 @@
 #include <config.h>
 #endif
 
+#include <cassert>
+
 #include <dbus-c++/dispatcher.h>
 
 #include <dbus/dbus.h>
@@ -38,64 +40,57 @@ DBus::Dispatcher *DBus::default_dispatcher = NULL;
 using namespace DBus;
 
 Timeout::Timeout(Timeout::Internal *i)
-  : _int(i)
+: _int(i)
 {
-  dbus_timeout_set_data((DBusTimeout *)i, this, NULL);
+	dbus_timeout_set_data((DBusTimeout *)i, this, NULL);
 }
 
 int Timeout::interval() const
 {
-  return dbus_timeout_get_interval((DBusTimeout *)_int);
+	return dbus_timeout_get_interval((DBusTimeout *)_int);
 }
 
 bool Timeout::enabled() const
 {
-  return dbus_timeout_get_enabled((DBusTimeout *)_int);
+	return dbus_timeout_get_enabled((DBusTimeout *)_int);
 }
 
 bool Timeout::handle()
 {
-  return dbus_timeout_handle((DBusTimeout *)_int);
+	return dbus_timeout_handle((DBusTimeout *)_int);
 }
 
 /*
 */
 
 Watch::Watch(Watch::Internal *i)
-  : _int(i)
+: _int(i)
 {
-  dbus_watch_set_data((DBusWatch *)i, this, NULL);
+	dbus_watch_set_data((DBusWatch *)i, this, NULL);
 }
 
 int Watch::descriptor() const
 {
 #if HAVE_WIN32
-  return dbus_watch_get_socket((DBusWatch *)_int);
-#else
-  // check dbus version and use dbus_watch_get_unix_fd() only in dbus >= 1.1.1
-#if (DBUS_VERSION_MAJOR == 1 && DBUS_VERSION_MINOR == 1 && DBUS_VERSION_MICRO >= 1) || \
-		(DBUS_VERSION_MAJOR == 1 && DBUS_VERSION_MAJOR > 1) || \
-		(DBUS_VERSION_MAJOR > 1)
-  return dbus_watch_get_unix_fd((DBusWatch *)_int);
+	return dbus_watch_get_socket((DBusWatch*)_int);
 #else
-  return dbus_watch_get_fd((DBusWatch *)_int);
-#endif
+	return dbus_watch_get_unix_fd((DBusWatch*)_int);
 #endif
 }
 
 int Watch::flags() const
 {
-  return dbus_watch_get_flags((DBusWatch *)_int);
+	return dbus_watch_get_flags((DBusWatch *)_int);
 }
 
 bool Watch::enabled() const
 {
-  return dbus_watch_get_enabled((DBusWatch *)_int);
+	return dbus_watch_get_enabled((DBusWatch *)_int);
 }
 
 bool Watch::handle(int flags)
 {
-  return dbus_watch_handle((DBusWatch *)_int, flags);
+	return dbus_watch_handle((DBusWatch *)_int, flags);
 }
 
 /*
@@ -103,218 +98,182 @@ bool Watch::handle(int flags)
 
 dbus_bool_t Dispatcher::Private::on_add_watch(DBusWatch *watch, void *data)
 {
-  Dispatcher *d = static_cast<Dispatcher *>(data);
+	Dispatcher *d = static_cast<Dispatcher *>(data);
 
-  Watch::Internal *w = reinterpret_cast<Watch::Internal *>(watch);
+	Watch::Internal *w = reinterpret_cast<Watch::Internal *>(watch);
 
-  d->add_watch(w);
+	d->add_watch(w);
 
-  return true;
+	return true;
 }
 
 void Dispatcher::Private::on_rem_watch(DBusWatch *watch, void *data)
 {
-  Dispatcher *d = static_cast<Dispatcher *>(data);
+	Dispatcher *d = static_cast<Dispatcher *>(data);
 
-  Watch *w = static_cast<Watch *>(dbus_watch_get_data(watch));
+	Watch *w = static_cast<Watch *>(dbus_watch_get_data(watch));
 
-  d->rem_watch(w);
+	d->rem_watch(w);
 }
 
 void Dispatcher::Private::on_toggle_watch(DBusWatch *watch, void *data)
 {
-  Watch *w = static_cast<Watch *>(dbus_watch_get_data(watch));
+	Watch *w = static_cast<Watch *>(dbus_watch_get_data(watch));
 
-  w->toggle();
+	w->toggle();
 }
 
 dbus_bool_t Dispatcher::Private::on_add_timeout(DBusTimeout *timeout, void *data)
 {
-  Dispatcher *d = static_cast<Dispatcher *>(data);
+	Dispatcher *d = static_cast<Dispatcher *>(data);
 
-  Timeout::Internal *t = reinterpret_cast<Timeout::Internal *>(timeout);
+	Timeout::Internal *t = reinterpret_cast<Timeout::Internal *>(timeout);
 
-  d->add_timeout(t);
+	d->add_timeout(t);
 
-  return true;
+	return true;
 }
 
 void Dispatcher::Private::on_rem_timeout(DBusTimeout *timeout, void *data)
 {
-  Dispatcher *d = static_cast<Dispatcher *>(data);
+	Dispatcher *d = static_cast<Dispatcher *>(data);
 
-  Timeout *t = static_cast<Timeout *>(dbus_timeout_get_data(timeout));
+	Timeout *t = static_cast<Timeout *>(dbus_timeout_get_data(timeout));
 
-  d->rem_timeout(t);
+	d->rem_timeout(t);
 }
 
 void Dispatcher::Private::on_toggle_timeout(DBusTimeout *timeout, void *data)
 {
-  Timeout *t = static_cast<Timeout *>(dbus_timeout_get_data(timeout));
+	Timeout *t = static_cast<Timeout *>(dbus_timeout_get_data(timeout));
 
-  t->toggle();
+	t->toggle();
 }
 
 void Dispatcher::queue_connection(Connection::Private *cp)
 {
-  _mutex_p.lock();
-  _pending_queue.push_back(cp);
-  _mutex_p.unlock();
+	_mutex_p.lock();
+	_pending_queue.push_back(cp);
+	_mutex_p.unlock();
 }
 
 
 bool Dispatcher::has_something_to_dispatch()
 {
-  _mutex_p.lock();
-  bool has_something = false;
-  for (Connection::PrivatePList::iterator it = _pending_queue.begin();
-       it != _pending_queue.end() && !has_something;
-       ++it)
-  {
-    has_something = (*it)->has_something_to_dispatch();
-  }
-
-  _mutex_p.unlock();
-  return has_something;
+	_mutex_p.lock();
+	bool has_something = false;
+	for(Connection::PrivatePList::iterator it = _pending_queue.begin();
+		it != _pending_queue.end() && !has_something;
+		++it)
+	{
+		has_something = (*it)->has_something_to_dispatch();
+	}
+
+	_mutex_p.unlock();
+	return has_something;
 }
 
 
 void Dispatcher::dispatch_pending()
 {
-  while (1)
-  {
-    _mutex_p.lock();
-    if (_pending_queue.empty())
-    {
-      _mutex_p.unlock();
-      break;
-    }
-
-    Connection::PrivatePList pending_queue_copy(_pending_queue);
-    _mutex_p.unlock();
-
-    size_t copy_elem_num(pending_queue_copy.size());
-
-    dispatch_pending(pending_queue_copy);
-
-    //only push_back on list is mandatory!
-    _mutex_p.lock();
-
-    Connection::PrivatePList::iterator i, j;
-    i = _pending_queue.begin();
-    size_t counter = 0;
-    while (counter < copy_elem_num && i != _pending_queue.end())
-    {
-      j = i;
-      ++j;
-      _pending_queue.erase(i);
-      i = j;
-      ++counter;
-    }
-
-    _mutex_p.unlock();
-  }
-}
-
-void Dispatcher::dispatch_pending(Connection::PrivatePList &pending_queue)
-{
-  // SEEME: dbus-glib is dispatching only one message at a time to not starve the loop/other things...
-
-  _mutex_p_copy.lock();
-  while (pending_queue.size() > 0)
-  {
-    Connection::PrivatePList::iterator i, j;
-
-    i = pending_queue.begin();
-
-    while (i != pending_queue.end())
-    {
-      j = i;
-
-      ++j;
-
-      if ((*i)->do_dispatch())
-        pending_queue.erase(i);
-      else
-        debug_log("dispatch_pending_private: do_dispatch error");
-
-      i = j;
-    }
-  }
-  _mutex_p_copy.unlock();
+	_mutex_p.lock();
+
+	// Reentrancy is not permitted for this function
+	assert(!_dispatching);
+	_dispatching = true;
+
+	// SEEME: dbus-glib is dispatching only one message at a time to not starve the loop/other things...
+
+	while (_pending_queue.size() > 0)
+	{
+		Connection::PrivatePList::iterator i, j;
+		i = _pending_queue.begin();
+		while (i != _pending_queue.end())
+		{
+			j = i;
+			++j;
+			_mutex_p.unlock();
+			bool done = (*i)->do_dispatch();
+			_mutex_p.lock();
+			if (done)
+				_pending_queue.erase(i);
+
+			i = j;
+		}
+	}
+	_dispatching = false;
+	_mutex_p.unlock();
 }
 
 void DBus::_init_threading()
 {
 #ifdef DBUS_HAS_THREADS_INIT_DEFAULT
-  dbus_threads_init_default();
+	dbus_threads_init_default();
 #else
-  debug_log("Thread support is not enabled! Your D-Bus version is too old!");
+	debug_log("Thread support is not enabled! Your D-Bus version is too old!");
 #endif//DBUS_HAS_THREADS_INIT_DEFAULT
 }
 
 void DBus::_init_threading(
-  MutexNewFn m1,
-  MutexFreeFn m2,
-  MutexLockFn m3,
-  MutexUnlockFn m4,
-  CondVarNewFn c1,
-  CondVarFreeFn c2,
-  CondVarWaitFn c3,
-  CondVarWaitTimeoutFn c4,
-  CondVarWakeOneFn c5,
-  CondVarWakeAllFn c6
+	MutexNewFn m1,
+	MutexFreeFn m2,
+	MutexLockFn m3,
+	MutexUnlockFn m4,
+	CondVarNewFn c1,
+	CondVarFreeFn c2,
+	CondVarWaitFn c3,
+	CondVarWaitTimeoutFn c4,
+	CondVarWakeOneFn c5,
+	CondVarWakeAllFn c6
 )
 {
 #ifndef DBUS_HAS_RECURSIVE_MUTEX
-  DBusThreadFunctions functions =
-  {
-    DBUS_THREAD_FUNCTIONS_MUTEX_NEW_MASK |
-    DBUS_THREAD_FUNCTIONS_MUTEX_FREE_MASK |
-    DBUS_THREAD_FUNCTIONS_MUTEX_LOCK_MASK |
-    DBUS_THREAD_FUNCTIONS_MUTEX_UNLOCK_MASK |
-    DBUS_THREAD_FUNCTIONS_CONDVAR_NEW_MASK |
-    DBUS_THREAD_FUNCTIONS_CONDVAR_FREE_MASK |
-    DBUS_THREAD_FUNCTIONS_CONDVAR_WAIT_MASK |
-    DBUS_THREAD_FUNCTIONS_CONDVAR_WAIT_TIMEOUT_MASK |
-    DBUS_THREAD_FUNCTIONS_CONDVAR_WAKE_ONE_MASK |
-    DBUS_THREAD_FUNCTIONS_CONDVAR_WAKE_ALL_MASK,
-    (DBusMutexNewFunction) m1,
-    (DBusMutexFreeFunction) m2,
-    (DBusMutexLockFunction) m3,
-    (DBusMutexUnlockFunction) m4,
-    (DBusCondVarNewFunction) c1,
-    (DBusCondVarFreeFunction) c2,
-    (DBusCondVarWaitFunction) c3,
-    (DBusCondVarWaitTimeoutFunction) c4,
-    (DBusCondVarWakeOneFunction) c5,
-    (DBusCondVarWakeAllFunction) c6
-  };
+	DBusThreadFunctions functions = {
+		DBUS_THREAD_FUNCTIONS_MUTEX_NEW_MASK |
+		DBUS_THREAD_FUNCTIONS_MUTEX_FREE_MASK |
+		DBUS_THREAD_FUNCTIONS_MUTEX_LOCK_MASK |
+		DBUS_THREAD_FUNCTIONS_MUTEX_UNLOCK_MASK |
+		DBUS_THREAD_FUNCTIONS_CONDVAR_NEW_MASK |
+		DBUS_THREAD_FUNCTIONS_CONDVAR_FREE_MASK |
+		DBUS_THREAD_FUNCTIONS_CONDVAR_WAIT_MASK |
+		DBUS_THREAD_FUNCTIONS_CONDVAR_WAIT_TIMEOUT_MASK |
+		DBUS_THREAD_FUNCTIONS_CONDVAR_WAKE_ONE_MASK|
+		DBUS_THREAD_FUNCTIONS_CONDVAR_WAKE_ALL_MASK,
+		(DBusMutexNewFunction) m1,
+		(DBusMutexFreeFunction) m2,
+		(DBusMutexLockFunction) m3,
+		(DBusMutexUnlockFunction) m4,
+		(DBusCondVarNewFunction) c1,
+		(DBusCondVarFreeFunction) c2,
+		(DBusCondVarWaitFunction) c3,
+		(DBusCondVarWaitTimeoutFunction) c4,
+		(DBusCondVarWakeOneFunction) c5,
+		(DBusCondVarWakeAllFunction) c6
+	};
 #else
-  DBusThreadFunctions functions =
-  {
-    DBUS_THREAD_FUNCTIONS_RECURSIVE_MUTEX_NEW_MASK |
-    DBUS_THREAD_FUNCTIONS_RECURSIVE_MUTEX_FREE_MASK |
-    DBUS_THREAD_FUNCTIONS_RECURSIVE_MUTEX_LOCK_MASK |
-    DBUS_THREAD_FUNCTIONS_RECURSIVE_MUTEX_UNLOCK_MASK |
-    DBUS_THREAD_FUNCTIONS_CONDVAR_NEW_MASK |
-    DBUS_THREAD_FUNCTIONS_CONDVAR_FREE_MASK |
-    DBUS_THREAD_FUNCTIONS_CONDVAR_WAIT_MASK |
-    DBUS_THREAD_FUNCTIONS_CONDVAR_WAIT_TIMEOUT_MASK |
-    DBUS_THREAD_FUNCTIONS_CONDVAR_WAKE_ONE_MASK |
-    DBUS_THREAD_FUNCTIONS_CONDVAR_WAKE_ALL_MASK,
-    0, 0, 0, 0,
-    (DBusCondVarNewFunction) c1,
-    (DBusCondVarFreeFunction) c2,
-    (DBusCondVarWaitFunction) c3,
-    (DBusCondVarWaitTimeoutFunction) c4,
-    (DBusCondVarWakeOneFunction) c5,
-    (DBusCondVarWakeAllFunction) c6,
-    (DBusRecursiveMutexNewFunction) m1,
-    (DBusRecursiveMutexFreeFunction) m2,
-    (DBusRecursiveMutexLockFunction) m3,
-    (DBusRecursiveMutexUnlockFunction) m4
-  };
+	DBusThreadFunctions functions = {
+		DBUS_THREAD_FUNCTIONS_RECURSIVE_MUTEX_NEW_MASK |
+		DBUS_THREAD_FUNCTIONS_RECURSIVE_MUTEX_FREE_MASK |
+		DBUS_THREAD_FUNCTIONS_RECURSIVE_MUTEX_LOCK_MASK |
+		DBUS_THREAD_FUNCTIONS_RECURSIVE_MUTEX_UNLOCK_MASK |
+		DBUS_THREAD_FUNCTIONS_CONDVAR_NEW_MASK |
+		DBUS_THREAD_FUNCTIONS_CONDVAR_FREE_MASK |
+		DBUS_THREAD_FUNCTIONS_CONDVAR_WAIT_MASK |
+		DBUS_THREAD_FUNCTIONS_CONDVAR_WAIT_TIMEOUT_MASK |
+		DBUS_THREAD_FUNCTIONS_CONDVAR_WAKE_ONE_MASK|
+		DBUS_THREAD_FUNCTIONS_CONDVAR_WAKE_ALL_MASK,
+		0, 0, 0, 0,
+		(DBusCondVarNewFunction) c1,
+		(DBusCondVarFreeFunction) c2,
+		(DBusCondVarWaitFunction) c3,
+		(DBusCondVarWaitTimeoutFunction) c4,
+		(DBusCondVarWakeOneFunction) c5,
+		(DBusCondVarWakeAllFunction) c6,
+		(DBusRecursiveMutexNewFunction) m1,
+		(DBusRecursiveMutexFreeFunction) m2,
+		(DBusRecursiveMutexLockFunction) m3,
+		(DBusRecursiveMutexUnlockFunction) m4
+	};
 #endif//DBUS_HAS_RECURSIVE_MUTEX
-  dbus_threads_init(&functions);
+	dbus_threads_init(&functions);
 }
diff --git a/src/dispatcher_p.h b/src/dispatcher_p.h
index 5aa2e53..33c0cac 100644
--- a/src/dispatcher_p.h
+++ b/src/dispatcher_p.h
@@ -35,22 +35,21 @@
 
 #include "internalerror.h"
 
-namespace DBus
-{
+namespace DBus {
 
 struct DXXAPILOCAL Dispatcher::Private
 {
-  static dbus_bool_t on_add_watch(DBusWatch *watch, void *data);
+	static dbus_bool_t on_add_watch(DBusWatch *watch, void *data);
 
-  static void on_rem_watch(DBusWatch *watch, void *data);
+	static void on_rem_watch(DBusWatch *watch, void *data);
 
-  static void on_toggle_watch(DBusWatch *watch, void *data);
+	static void on_toggle_watch(DBusWatch *watch, void *data);
 
-  static dbus_bool_t on_add_timeout(DBusTimeout *timeout, void *data);
+	static dbus_bool_t on_add_timeout(DBusTimeout *timeout, void *data);
 
-  static void on_rem_timeout(DBusTimeout *timeout, void *data);
+	static void on_rem_timeout(DBusTimeout *timeout, void *data);
 
-  static void on_toggle_timeout(DBusTimeout *timeout, void *data);
+	static void on_toggle_timeout(DBusTimeout *timeout, void *data);
 };
 
 } /* namespace DBus */
diff --git a/src/ecore-integration.cpp b/src/ecore-integration.cpp
new file mode 100644
index 0000000..e530e06
--- /dev/null
+++ b/src/ecore-integration.cpp
@@ -0,0 +1,213 @@
+/*
+ *
+ *  D-Bus++ - C++ bindings for D-Bus
+ *
+ *  Copyright (C) 2005-2007  Paolo Durante <shackan@gmail.com>
+ *
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <dbus-c++/ecore-integration.h>
+
+#include <dbus/dbus.h> // for DBUS_WATCH_*
+
+using namespace DBus;
+
+Ecore::BusTimeout::BusTimeout( Timeout::Internal* ti)
+: Timeout(ti)
+{
+	_enable();
+}
+
+Ecore::BusTimeout::~BusTimeout()
+{
+	_disable();
+}
+
+void Ecore::BusTimeout::toggle()
+{
+	debug_log("ecore: timeout %p toggled (%s)", this, Timeout::enabled() ? "on":"off");
+
+	if(Timeout::enabled())	_enable();
+	else			_disable();
+}
+
+int Ecore::BusTimeout::timeout_handler( void *data )
+{
+	Ecore::BusTimeout* t = reinterpret_cast<Ecore::BusTimeout*>(data);
+
+	debug_log("Ecore::BusTimeout::timeout_handler( void *data )");
+
+	t->handle();
+
+	return 1; // 1 -> reshedule in ecore for next timer interval
+}
+
+void Ecore::BusTimeout::_enable()
+{
+  debug_log("Ecore::BusTimeout::_enable()");
+  
+  _etimer = ecore_timer_add (((double)Timeout::interval())/1000, timeout_handler, this);
+}
+
+void Ecore::BusTimeout::_disable()
+{
+  debug_log("Ecore::BusTimeout::_disable()");
+
+  ecore_timer_del (_etimer);
+}
+
+/*static bool watch_prepare( int *timeout )
+{
+	debug_log("ecore: watch_prepare");
+
+	*timeout = -1;
+	return false;
+}*/
+
+/*static bool watch_check( )
+{
+	debug_log("ecore: watch_check");
+
+	return true;
+}*/
+
+static bool watch_dispatch( void *data )
+{
+	debug_log("ecore: watch_dispatch");
+
+	bool cb = true;
+	DBus::default_dispatcher->dispatch_pending(); //TODO: won't work in case of multiple dispatchers
+	return cb;
+}
+
+Ecore::BusWatch::BusWatch( Watch::Internal* wi)
+: Watch(wi)
+{
+	_enable();
+}
+
+Ecore::BusWatch::~BusWatch()
+{
+	_disable();
+}
+
+void Ecore::BusWatch::toggle()
+{
+	debug_log("ecore: watch %p toggled (%s)", this, Watch::enabled() ? "on":"off");
+
+	if(Watch::enabled())	_enable();
+	else			_disable();
+}
+
+int Ecore::BusWatch::watch_handler_read( void *data, Ecore_Fd_Handler *fdh  )
+{
+	Ecore::BusWatch* w = reinterpret_cast<Ecore::BusWatch*>(data);
+
+	debug_log("ecore: watch_handler_read");
+  
+	int flags = DBUS_WATCH_READABLE;
+  
+  watch_dispatch(NULL);
+
+	w->handle(flags);
+
+	return 1;
+}
+
+int Ecore::BusWatch::watch_handler_error( void *data, Ecore_Fd_Handler *fdh  )
+{
+	//Ecore::BusWatch* w = reinterpret_cast<Ecore::BusWatch*>(data);
+
+	debug_log("ecore: watch_handler_error");
+
+	//int flags = DBUS_WATCH_ERROR;
+  
+	watch_dispatch(NULL);
+
+	return 1;
+}
+
+void Ecore::BusWatch::_enable()
+{
+  debug_log("Ecore::BusWatch::_enable()");
+  
+  //int flags = Watch::flags();
+  
+  fd_handler_read = ecore_main_fd_handler_add (Watch::descriptor(),
+                                                            ECORE_FD_READ,
+                                                            watch_handler_read,
+                                                            this,
+                                                            NULL, NULL);
+  
+  ecore_main_fd_handler_active_set(fd_handler_read, ECORE_FD_READ);
+  
+  fd_handler_error = ecore_main_fd_handler_add (Watch::descriptor(),
+                                                            ECORE_FD_ERROR,
+                                                            watch_handler_error,
+                                                            this,
+                                                            NULL, NULL);
+  
+  ecore_main_fd_handler_active_set(fd_handler_error, ECORE_FD_ERROR);
+}
+
+void Ecore::BusWatch::_disable()
+{
+  ecore_main_fd_handler_del (fd_handler_read);
+  ecore_main_fd_handler_del (fd_handler_error);
+}
+
+void Ecore::BusDispatcher::attach( )
+{
+}
+
+Timeout* Ecore::BusDispatcher::add_timeout( Timeout::Internal* wi )
+{
+	Timeout* t = new Ecore::BusTimeout( wi );
+
+	debug_log("ecore: added timeout %p (%s)", t, t->enabled() ? "on":"off");
+
+	return t;
+}
+
+void Ecore::BusDispatcher::rem_timeout( Timeout* t )
+{
+	debug_log("ecore: removed timeout %p", t);
+
+	delete t;
+}
+
+Watch* Ecore::BusDispatcher::add_watch( Watch::Internal* wi )
+{
+	Watch* w = new Ecore::BusWatch(wi);
+
+	debug_log("ecore: added watch %p (%s) fd=%d flags=%d",
+		w, w->enabled() ? "on":"off", w->descriptor(), w->flags()
+	);
+	return w;
+}
+
+void Ecore::BusDispatcher::rem_watch( Watch* w )
+{
+	debug_log("ecore: removed watch %p", w);
+
+	delete w;
+}
diff --git a/src/error.cpp b/src/error.cpp
index 7b2d119..4333537 100644
--- a/src/error.cpp
+++ b/src/error.cpp
@@ -39,23 +39,23 @@ using namespace DBus;
 */
 
 Error::Error()
-  : _int(new InternalError)
+: _int(new InternalError)
 {}
 
 Error::Error(InternalError &i)
-  : _int(new InternalError(i))
+: _int(new InternalError(i))
 {}
 
 Error::Error(const char *name, const char *message)
-  : _int(new InternalError)
+: _int(new InternalError)
 {
-  set(name, message);
+	set(name, message);
 }
 
 Error::Error(Message &m)
-  : _int(new InternalError)
+: _int(new InternalError)
 {
-  dbus_set_error_from_message(&(_int->error), m._pvt->msg);
+	dbus_set_error_from_message(&(_int->error), m._pvt->msg);
 }
 
 Error::~Error() throw()
@@ -64,26 +64,25 @@ Error::~Error() throw()
 
 const char *Error::name() const
 {
-  return _int->error.name;
+	return _int->error.name;
 }
 
 const char *Error::message() const
 {
-  return _int->error.message;
+	return _int->error.message;
 }
 
 bool Error::is_set() const
 {
-  return *(_int);
+	return *(_int);
 }
 
 void Error::set(const char *name, const char *message)
 {
-  dbus_set_error_const(&(_int->error), name, message);
+	dbus_set_error(&(_int->error), name, "%s", message);
 }
 
 const char *Error::what() const throw()
 {
-  return _int->error.message;
+	return _int->error.message;
 }
-
diff --git a/src/eventloop-integration.cpp b/src/eventloop-integration.cpp
index 1c57cd8..11eefa4 100644
--- a/src/eventloop-integration.cpp
+++ b/src/eventloop-integration.cpp
@@ -25,200 +25,155 @@
 #include <config.h>
 #endif
 
-/* Project */
+#include <string.h>
+
 #include <dbus-c++/eventloop-integration.h>
 #include <dbus-c++/debug.h>
-#include <dbus-c++/pipe.h>
 
-/* DBus */
-#include <dbus/dbus.h>
+#include <sys/poll.h>
 
-/* STD */
-#include <string.h>
-#include <cassert>
-#include <poll.h>
-#include <fcntl.h>
+#include <dbus/dbus.h>
+#include <errno.h>
 
 using namespace DBus;
-using namespace std;
 
 BusTimeout::BusTimeout(Timeout::Internal *ti, BusDispatcher *bd)
-  : Timeout(ti), DefaultTimeout(Timeout::interval(), true, bd)
+: Timeout(ti), DefaultTimeout(Timeout::interval(), true, bd)
 {
-  DefaultTimeout::enabled(Timeout::enabled());
+	DefaultTimeout::enabled(Timeout::enabled());
 }
 
 void BusTimeout::toggle()
 {
-  debug_log("timeout %p toggled (%s)", this, Timeout::enabled() ? "on" : "off");
+	debug_log("timeout %p toggled (%s)", this, Timeout::enabled() ? "on":"off");
 
-  DefaultTimeout::enabled(Timeout::enabled());
+	DefaultTimeout::enabled(Timeout::enabled());
 }
 
 BusWatch::BusWatch(Watch::Internal *wi, BusDispatcher *bd)
-  : Watch(wi), DefaultWatch(Watch::descriptor(), 0, bd)
+: Watch(wi), DefaultWatch(Watch::descriptor(), 0, bd)
 {
-  int flags = POLLHUP | POLLERR;
+	int flags = POLLHUP | POLLERR;
 
-  if (Watch::flags() & DBUS_WATCH_READABLE)
-    flags |= POLLIN;
-  if (Watch::flags() & DBUS_WATCH_WRITABLE)
-    flags |= POLLOUT;
+	if (Watch::flags() & DBUS_WATCH_READABLE)
+		flags |= POLLIN;
+	if (Watch::flags() & DBUS_WATCH_WRITABLE)
+		flags |= POLLOUT;
 
-  DefaultWatch::flags(flags);
-  DefaultWatch::enabled(Watch::enabled());
+	DefaultWatch::flags(flags);
+	DefaultWatch::enabled(Watch::enabled());
 }
 
 void BusWatch::toggle()
 {
-  debug_log("watch %p toggled (%s)", this, Watch::enabled() ? "on" : "off");
+	debug_log("watch %p toggled (%s)", this, Watch::enabled() ? "on":"off");
 
-  DefaultWatch::enabled(Watch::enabled());
-}
-
-BusDispatcher::BusDispatcher() :
-  _running(false)
-{
-  // pipe to create a new fd used to unlock a dispatcher at any
-  // moment (used by leave function)
-  int ret = pipe(_pipe);
-  if (ret == -1) throw Error("PipeError:errno", toString(errno).c_str());
-
-  _fdunlock[0] = _pipe[0];
-  _fdunlock[1] = _pipe[1];
+	DefaultWatch::enabled(Watch::enabled());
 }
 
 void BusDispatcher::enter()
 {
-  debug_log("entering dispatcher %p", this);
-
-  _running = true;
-
-  while (_running)
-  {
-    do_iteration();
+	debug_log("entering dispatcher %p", this);
 
-    for (std::list <Pipe *>::iterator p_it = pipe_list.begin();
-         p_it != pipe_list.end();
-         ++p_it)
-    {
-      Pipe *read_pipe = *p_it;
-      char buffer[1024]; // TODO: should be max pipe size
-      unsigned int nbytes = 0;
+	_running = true;
 
-      while (read_pipe->read(buffer, nbytes) > 0)
-      {
-        read_pipe->_handler(read_pipe->_data, buffer, nbytes);
-      }
+	while (_running)
+	{
+		do_iteration();
+	}
 
-    }
-  }
-
-  debug_log("leaving dispatcher %p", this);
+	debug_log("leaving dispatcher %p", this);
 }
 
 void BusDispatcher::leave()
 {
-  _running = false;
-
-  int ret = write(_fdunlock[1], "exit", strlen("exit"));
-  if (ret == -1) throw Error("WriteError:errno", toString(errno).c_str());
-
-  close(_fdunlock[1]);
-  close(_fdunlock[0]);
-}
-
-Pipe *BusDispatcher::add_pipe(void(*handler)(const void *data, void *buffer, unsigned int nbyte), const void *data)
-{
-  Pipe *new_pipe = new Pipe(handler, data);
-  pipe_list.push_back(new_pipe);
-
-  return new_pipe;
-}
-
-void BusDispatcher::del_pipe(Pipe *pipe)
-{
-  pipe_list.remove(pipe);
-  delete pipe;
+	_running = false;
+	if (_fdunlock[1] >= 0) {
+		int ret = write(_fdunlock[1],"exit",strlen("exit"));
+		if (ret == -1) {
+			char buffer[128]; // buffer copied in Error constructor
+			throw Error("PipeError:errno", strerror_r(errno,
+								  buffer,
+								  sizeof(buffer)));
+		}
+	}
+	close(_fdunlock[1]);
+	close(_fdunlock[0]);
 }
 
 void BusDispatcher::do_iteration()
 {
-  dispatch_pending();
-  dispatch();
+	dispatch_pending();
+	dispatch();
 }
 
 Timeout *BusDispatcher::add_timeout(Timeout::Internal *ti)
 {
-  BusTimeout *bt = new BusTimeout(ti, this);
+	BusTimeout *bt = new BusTimeout(ti, this);
 
-  bt->expired = new Callback<BusDispatcher, void, DefaultTimeout &>(this, &BusDispatcher::timeout_expired);
-  bt->data(bt);
+	bt->expired = new Callback<BusDispatcher, void, DefaultTimeout &>(this, &BusDispatcher::timeout_expired);
+	bt->data(bt);
 
-  debug_log("added timeout %p (%s) (%d millies)",
-            bt,
-            ((Timeout *)bt)->enabled() ? "on" : "off",
-            ((Timeout *)bt)->interval()
-           );
+	debug_log("added timeout %p (%s) interval=%d",
+		bt, ((Timeout *)bt)->enabled() ? "on":"off", ((Timeout *)bt)->interval());
 
-  return bt;
+	return bt;
 }
 
 void BusDispatcher::rem_timeout(Timeout *t)
 {
-  debug_log("removed timeout %p", t);
+	debug_log("removed timeout %p", t);
 
-  delete t;
+	delete t;
 }
 
 Watch *BusDispatcher::add_watch(Watch::Internal *wi)
 {
-  BusWatch *bw = new BusWatch(wi, this);
+	BusWatch *bw = new BusWatch(wi, this);
 
-  bw->ready = new Callback<BusDispatcher, void, DefaultWatch &>(this, &BusDispatcher::watch_ready);
-  bw->data(bw);
+	bw->ready = new Callback<BusDispatcher, void, DefaultWatch &>(this, &BusDispatcher::watch_ready);
+	bw->data(bw);
 
-  debug_log("added watch %p (%s) fd=%d flags=%d",
-            bw, ((Watch *)bw)->enabled() ? "on" : "off", ((Watch *)bw)->descriptor(), ((Watch *)bw)->flags());
+	debug_log("added watch %p (%s) fd=%d flags=%d",
+		bw, ((Watch *)bw)->enabled() ? "on":"off", ((Watch *)bw)->descriptor(), ((Watch *)bw)->flags());
 
-  return bw;
+	return bw;
 }
 
 void BusDispatcher::rem_watch(Watch *w)
 {
-  debug_log("removed watch %p", w);
+	debug_log("removed watch %p", w);
 
-  delete w;
+	delete w;
 }
 
 void BusDispatcher::timeout_expired(DefaultTimeout &et)
 {
-  debug_log("timeout %p expired", &et);
+	debug_log("timeout %p expired", &et);
 
-  BusTimeout *timeout = reinterpret_cast<BusTimeout *>(et.data());
+	BusTimeout *timeout = reinterpret_cast<BusTimeout *>(et.data());
 
-  timeout->handle();
+	timeout->handle();
 }
 
 void BusDispatcher::watch_ready(DefaultWatch &ew)
 {
-  BusWatch *watch = reinterpret_cast<BusWatch *>(ew.data());
+	BusWatch *watch = reinterpret_cast<BusWatch *>(ew.data());
 
-  debug_log("watch %p ready, flags=%d state=%d",
-            watch, ((Watch *)watch)->flags(), watch->state()
-           );
+	debug_log("watch %p ready, flags=%d state=%d",
+		watch, ((Watch *)watch)->flags(), watch->state()
+	);
 
-  int flags = 0;
+	int flags = 0;
 
-  if (watch->state() & POLLIN)
-    flags |= DBUS_WATCH_READABLE;
-  if (watch->state() & POLLOUT)
-    flags |= DBUS_WATCH_WRITABLE;
-  if (watch->state() & POLLHUP)
-    flags |= DBUS_WATCH_HANGUP;
-  if (watch->state() & POLLERR)
-    flags |= DBUS_WATCH_ERROR;
+	if (watch->state() & POLLIN)
+		flags |= DBUS_WATCH_READABLE;
+	if (watch->state() & POLLOUT)
+		flags |= DBUS_WATCH_WRITABLE;
+	if (watch->state() & POLLHUP)
+		flags |= DBUS_WATCH_HANGUP;
+	if (watch->state() & POLLERR)
+		flags |= DBUS_WATCH_ERROR;
 
-  watch->handle(flags);
+	watch->handle(flags);
 }
-
diff --git a/src/eventloop.cpp b/src/eventloop.cpp
index 7790e1e..81861f0 100644
--- a/src/eventloop.cpp
+++ b/src/eventloop.cpp
@@ -25,242 +25,235 @@
 #include <config.h>
 #endif
 
+#include <cassert>
+#include <errno.h>
+
 #include <dbus-c++/eventloop.h>
 #include <dbus-c++/debug.h>
 
-#include <poll.h>
+#include <sys/poll.h>
 #include <sys/time.h>
 
 #include <dbus/dbus.h>
 
 using namespace DBus;
-using namespace std;
 
 static double millis(timeval tv)
 {
-  return (tv.tv_sec * 1000.0 + tv.tv_usec / 1000.0);
+	return (tv.tv_sec *1000.0 + tv.tv_usec/1000.0);
 }
-
+	
 DefaultTimeout::DefaultTimeout(int interval, bool repeat, DefaultMainLoop *ed)
-  : _enabled(true), _interval(interval), _repeat(repeat), _expiration(0), _data(0), _disp(ed)
+: _enabled(true), _interval(interval), _repeat(repeat), _expiration(0), _data(0), _disp(ed)
 {
-  timeval now;
-  gettimeofday(&now, NULL);
+	timeval now;
+	gettimeofday(&now, NULL);
 
-  _expiration = millis(now) + interval;
+	_expiration = millis(now) + interval;
 
-  _disp->_mutex_t.lock();
-  _disp->_timeouts.push_back(this);
-  _disp->_mutex_t.unlock();
+	_disp->_mutex_t.lock();
+	_disp->_timeouts.push_back(this);
+	_disp->_mutex_t.unlock();
 }
 
 DefaultTimeout::~DefaultTimeout()
 {
-  _disp->_mutex_t.lock();
-  _disp->_timeouts.remove(this);
-  _disp->_mutex_t.unlock();
+	_disp->_mutex_t.lock();
+	_disp->_timeouts.remove(this);
+	_disp->_mutex_t.unlock();
 }
 
 DefaultWatch::DefaultWatch(int fd, int flags, DefaultMainLoop *ed)
-  : _enabled(true), _fd(fd), _flags(flags), _state(0), _data(0), _disp(ed)
+: _enabled(true), _fd(fd), _flags(flags), _state(0), _data(0), _disp(ed)
 {
-  _disp->_mutex_w.lock();
-  _disp->_watches.push_back(this);
-  _disp->_mutex_w.unlock();
+	_disp->_mutex_w.lock();
+	_disp->_watches.push_back(this);
+	_disp->_mutex_w.unlock();
 }
 
 DefaultWatch::~DefaultWatch()
 {
-  _disp->_mutex_w.lock();
-  _disp->_watches.remove(this);
-  _disp->_mutex_w.unlock();
+	_disp->_mutex_w.lock();
+	_disp->_watches.remove(this);
+	_disp->_mutex_w.unlock();
 }
 
 DefaultMutex::DefaultMutex()
 {
-  pthread_mutex_init(&_mutex, NULL);
-}
-
-DefaultMutex::DefaultMutex(bool recursive)
-{
-  if (recursive)
-  {
-    pthread_mutexattr_t attr;
-
-    pthread_mutexattr_init(&attr);
-    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
-    pthread_mutex_init(&_mutex, &attr);
-  }
-  else
-  {
-    pthread_mutex_init(&_mutex, NULL);
-  }
+	pthread_mutexattr_t attr;
+	pthread_mutexattr_init(&attr);
+	pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK);
+	pthread_mutex_init(&_mutex, &attr);
 }
 
 DefaultMutex::~DefaultMutex()
 {
-  pthread_mutex_destroy(&_mutex);
+	pthread_mutex_destroy(&_mutex);
 }
 
 void DefaultMutex::lock()
 {
-  pthread_mutex_lock(&_mutex);
+	int r = pthread_mutex_lock(&_mutex);
+	/* This assert is here to avoid a difficult-to-diagnose deadlock. See
+	 * crosbug.com/8486 and crosbug.com/8596. */
+	assert(r != EDEADLK);
 }
 
 void DefaultMutex::unlock()
 {
-  pthread_mutex_unlock(&_mutex);
+	pthread_mutex_unlock(&_mutex);
 }
 
-DefaultMainLoop::DefaultMainLoop() :
-  _mutex_w(true)
+DefaultMainLoop::DefaultMainLoop()
 {
+	  _fdunlock[0] = -1;
+	  _fdunlock[1] = -1;
 }
 
 DefaultMainLoop::~DefaultMainLoop()
 {
-  _mutex_w.lock();
-
-  DefaultWatches::iterator wi = _watches.begin();
-  while (wi != _watches.end())
-  {
-    DefaultWatches::iterator wmp = wi;
-    ++wmp;
-    _mutex_w.unlock();
-    delete(*wi);
-    _mutex_w.lock();
-    wi = wmp;
-  }
-  _mutex_w.unlock();
-
-  _mutex_t.lock();
-
-  DefaultTimeouts::iterator ti = _timeouts.begin();
-  while (ti != _timeouts.end())
-  {
-    DefaultTimeouts::iterator tmp = ti;
-    ++tmp;
-    _mutex_t.unlock();
-    delete(*ti);
-    _mutex_t.lock();
-    ti = tmp;
-  }
-  _mutex_t.unlock();
+	_mutex_w.lock();
+
+	DefaultWatches::iterator wi = _watches.begin();
+	while (wi != _watches.end())
+	{
+		DefaultWatches::iterator wmp = wi;
+		++wmp;
+		_mutex_w.unlock();
+		delete (*wi);
+		_mutex_w.lock();
+		wi = wmp;
+	}
+	_mutex_w.unlock();
+
+	_mutex_t.lock();
+
+	DefaultTimeouts::iterator ti = _timeouts.begin();
+	while (ti != _timeouts.end())
+	{
+		DefaultTimeouts::iterator tmp = ti;
+		++tmp;
+		_mutex_t.unlock();
+		delete (*ti);
+		_mutex_t.lock();
+		ti = tmp;
+	}
+	_mutex_t.unlock();
 }
 
 void DefaultMainLoop::dispatch()
 {
-  _mutex_w.lock();
-
-  int nfd = _watches.size();
+	_mutex_w.lock();
 
-  if (_fdunlock)
-  {
-    nfd = nfd + 2;
-  }
+	int nfd = _watches.size();
 
-  pollfd fds[nfd];
+	if (_fdunlock[0] >= 0 && _fdunlock[1] >= 0)
+	{
+		nfd=nfd+2;
+	}
 
-  DefaultWatches::iterator wi = _watches.begin();
+	pollfd fds[nfd];
 
-  for (nfd = 0; wi != _watches.end(); ++wi)
-  {
-    if ((*wi)->enabled())
-    {
-      fds[nfd].fd = (*wi)->descriptor();
-      fds[nfd].events = (*wi)->flags();
-      fds[nfd].revents = 0;
+	DefaultWatches::iterator wi = _watches.begin();
 
-      ++nfd;
-    }
-  }
+	for (nfd = 0; wi != _watches.end(); ++wi)
+	{
+		if ((*wi)->enabled())
+		{
+			fds[nfd].fd = (*wi)->descriptor();
+			fds[nfd].events = (*wi)->flags();
+			fds[nfd].revents = 0;
 
-  if (_fdunlock)
-  {
-    fds[nfd].fd = _fdunlock[0];
-    fds[nfd].events = POLLIN | POLLOUT | POLLPRI ;
-    fds[nfd].revents = 0;
+			++nfd;
+		}
+	}
 
-    nfd++;
-    fds[nfd].fd = _fdunlock[1];
-    fds[nfd].events = POLLIN | POLLOUT | POLLPRI ;
-    fds[nfd].revents = 0;
-  }
+	if (_fdunlock[0] >= 0 && _fdunlock[1] >= 0)
+	{
+		fds[nfd].fd = _fdunlock[0];
+		fds[nfd].events = POLLIN | POLLOUT | POLLPRI ;
+		fds[nfd].revents = 0;
+		
+		nfd++;
+		fds[nfd].fd = _fdunlock[1];
+		fds[nfd].events = POLLIN | POLLOUT | POLLPRI ;
+		fds[nfd].revents = 0;
+	}
 
-  _mutex_w.unlock();
+	_mutex_w.unlock();
 
-  int wait_min = 10000;
+	int wait_min = -1;
 
-  DefaultTimeouts::iterator ti;
+	DefaultTimeouts::iterator ti;
 
-  _mutex_t.lock();
+	_mutex_t.lock();
 
-  for (ti = _timeouts.begin(); ti != _timeouts.end(); ++ti)
-  {
-    if ((*ti)->enabled() && (*ti)->interval() < wait_min)
-      wait_min = (*ti)->interval();
-  }
+	for (ti = _timeouts.begin(); ti != _timeouts.end(); ++ti)
+	{
+		if (((*ti)->enabled() && (*ti)->interval() < wait_min) || (wait_min < 0))
+			wait_min = (*ti)->interval();
+	}
 
-  _mutex_t.unlock();
+	_mutex_t.unlock();
 
-  poll(fds, nfd, wait_min);
+	poll(fds, nfd, wait_min);
 
-  timeval now;
-  gettimeofday(&now, NULL);
+	timeval now;
+	gettimeofday(&now, NULL);
 
-  double now_millis = millis(now);
+	double now_millis = millis(now);
 
-  _mutex_t.lock();
+	_mutex_t.lock();
 
-  ti = _timeouts.begin();
+	ti = _timeouts.begin();
 
-  while (ti != _timeouts.end())
-  {
-    DefaultTimeouts::iterator tmp = ti;
-    ++tmp;
+	while (ti != _timeouts.end())
+	{
+		DefaultTimeouts::iterator tmp = ti;
+		++tmp;
 
-    if ((*ti)->enabled() && now_millis >= (*ti)->_expiration)
-    {
-      (*ti)->expired(*(*ti));
+		if ((*ti)->enabled() && now_millis >= (*ti)->_expiration)
+		{
+			(*ti)->expired(*(*ti));
 
-      if ((*ti)->_repeat)
-      {
-        (*ti)->_expiration = now_millis + (*ti)->_interval;
-      }
+			if ((*ti)->_repeat)
+			{
+				(*ti)->_expiration = now_millis + (*ti)->_interval;
+			}
 
-    }
+		}
 
-    ti = tmp;
-  }
+		ti = tmp;
+	}
 
-  _mutex_t.unlock();
+	_mutex_t.unlock();
 
-  _mutex_w.lock();
+	_mutex_w.lock();
 
-  for (int j = 0; j < nfd; ++j)
-  {
-    DefaultWatches::iterator wi;
+	for (int j = 0; j < nfd; ++j)
+	{
+		DefaultWatches::iterator wi;
 
-    for (wi = _watches.begin(); wi != _watches.end();)
-    {
-      DefaultWatches::iterator tmp = wi;
-      ++tmp;
+		for (wi = _watches.begin(); wi != _watches.end();)
+		{
+			DefaultWatches::iterator tmp = wi;
+			++tmp;
 
-      if ((*wi)->enabled() && (*wi)->_fd == fds[j].fd)
-      {
-        if (fds[j].revents)
-        {
-          (*wi)->_state = fds[j].revents;
+			if ((*wi)->enabled() && (*wi)->_fd == fds[j].fd)
+			{
+				if (fds[j].revents)
+				{
+					(*wi)->_state = fds[j].revents;
 
-          (*wi)->ready(*(*wi));
+					(*wi)->ready(*(*wi));
 
-          fds[j].revents = 0;
-        }
-      }
+					fds[j].revents = 0;
+				}
+			}
 
-      wi = tmp;
-    }
-  }
-  _mutex_w.unlock();
+			wi = tmp;
+		}
+	}
+	_mutex_w.unlock();
 }
 
diff --git a/src/glib-integration.cpp b/src/glib-integration.cpp
new file mode 100644
index 0000000..491c950
--- /dev/null
+++ b/src/glib-integration.cpp
@@ -0,0 +1,314 @@
+/*
+ *
+ *  D-Bus++ - C++ bindings for D-Bus
+ *
+ *  Copyright (C) 2005-2007  Paolo Durante <shackan@gmail.com>
+ *
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <dbus-c++/glib-integration.h>
+
+#include <dbus/dbus.h> // for DBUS_WATCH_*
+
+using namespace DBus;
+
+Glib::BusTimeout::BusTimeout(Timeout::Internal *ti, GMainContext *ctx, int priority)
+: Timeout(ti), _ctx(ctx), _priority(priority), _source(NULL)
+{
+	if (Timeout::enabled())
+		_enable();
+}
+
+Glib::BusTimeout::~BusTimeout()
+{
+	_disable();
+}
+
+void Glib::BusTimeout::toggle()
+{
+	debug_log("glib: timeout %p toggled (%s)", this, Timeout::enabled() ? "on":"off");
+
+	if (Timeout::enabled())	_enable();
+	else			_disable();
+}
+
+gboolean Glib::BusTimeout::timeout_handler(gpointer data)
+{
+	Glib::BusTimeout *t = reinterpret_cast<Glib::BusTimeout *>(data);
+
+	t->handle();
+
+	return TRUE;
+}
+
+void Glib::BusTimeout::_enable()
+{
+	if (_source)
+		_disable(); // be sane
+
+	_source = g_timeout_source_new(Timeout::interval());
+	g_source_set_priority(_source, _priority);
+	g_source_set_callback(_source, timeout_handler, this, NULL);
+	g_source_attach(_source, _ctx);
+}
+
+void Glib::BusTimeout::_disable()
+{
+	if (_source)
+	{
+		g_source_destroy(_source);
+		_source = NULL;
+	}
+}
+
+struct BusSource
+{
+	GSource source;
+	GPollFD poll;
+};
+
+static gboolean watch_prepare(GSource *source, gint *timeout)
+{
+	//debug_log("glib: watch_prepare");
+
+	*timeout = -1;
+	return FALSE;
+}
+
+static gboolean watch_check(GSource *source)
+{
+	//debug_log("glib: watch_check");
+
+	BusSource *io = (BusSource *)source;
+	return io->poll.revents ? TRUE : FALSE;
+}
+
+static gboolean watch_dispatch(GSource *source, GSourceFunc callback, gpointer data)
+{
+	debug_log("glib: watch_dispatch");
+
+	gboolean cb = callback(data);
+	return cb;
+}
+
+static GSourceFuncs watch_funcs = {
+	watch_prepare,
+	watch_check,
+	watch_dispatch,
+	NULL
+};
+
+Glib::BusWatch::BusWatch(Watch::Internal *wi, GMainContext *ctx, int priority)
+: Watch(wi), _ctx(ctx), _priority(priority), _source(NULL)
+{
+	if (Watch::enabled())
+		_enable();
+}
+
+Glib::BusWatch::~BusWatch()
+{
+	_disable();
+}
+
+void Glib::BusWatch::toggle()
+{
+	debug_log("glib: watch %p toggled (%s)", this, Watch::enabled() ? "on":"off");
+
+	if (Watch::enabled())	_enable();
+	else			_disable();
+}
+
+gboolean Glib::BusWatch::watch_handler(gpointer data)
+{
+	Glib::BusWatch *w = reinterpret_cast<Glib::BusWatch *>(data);
+
+	BusSource *io = (BusSource *)(w->_source);
+
+	int flags = 0;
+	if (io->poll.revents &G_IO_IN)
+	     flags |= DBUS_WATCH_READABLE;
+	if (io->poll.revents &G_IO_OUT)
+	     flags |= DBUS_WATCH_WRITABLE;
+	if (io->poll.revents &G_IO_ERR)
+	     flags |= DBUS_WATCH_ERROR;
+	if (io->poll.revents &G_IO_HUP)
+	     flags |= DBUS_WATCH_HANGUP;
+
+	w->handle(flags);
+
+	return TRUE;
+}
+
+void Glib::BusWatch::_enable()
+{
+	if (_source)
+		_disable(); // be sane
+	_source = g_source_new(&watch_funcs, sizeof(BusSource));
+	g_source_set_priority(_source, _priority);
+	g_source_set_callback(_source, watch_handler, this, NULL);
+
+	int flags = Watch::flags();
+	int condition = 0;
+
+	if (flags &DBUS_WATCH_READABLE)
+		condition |= G_IO_IN;
+	if (flags &DBUS_WATCH_WRITABLE)
+		condition |= G_IO_OUT;
+	if (flags &DBUS_WATCH_ERROR)
+		condition |= G_IO_ERR;
+	if (flags &DBUS_WATCH_HANGUP)
+		condition |= G_IO_HUP;
+
+	GPollFD *poll = &(((BusSource *)_source)->poll);
+	poll->fd = Watch::descriptor();
+	poll->events = condition;
+	poll->revents = 0;
+
+	g_source_add_poll(_source, poll);
+	g_source_attach(_source, _ctx);
+}
+
+void Glib::BusWatch::_disable()
+{
+	if (!_source)
+		return;
+	GPollFD *poll = &(((BusSource *)_source)->poll);
+	g_source_remove_poll(_source, poll);
+	g_source_destroy(_source);
+	_source = NULL;
+}
+
+/*
+ * We need this on top of the IO handlers, because sometimes
+ * there are messages to dispatch queued up but no IO pending.
+ * (fixes also a previous problem of code not working in case of multiple dispatchers)
+*/
+struct DispatcherSource
+{
+	GSource source;
+	Dispatcher *dispatcher;
+};
+
+
+static gboolean dispatcher_prepare(GSource *source, gint *timeout)
+{
+	Dispatcher *dispatcher = ((DispatcherSource*)source)->dispatcher;
+  
+  	*timeout = -1;
+
+  	return dispatcher->has_something_to_dispatch()? TRUE:FALSE;
+}
+
+static gboolean dispatcher_check(GSource *source)
+{
+  	return FALSE;
+}
+
+static gboolean
+dispatcher_dispatch(GSource *source,
+                    GSourceFunc callback,
+                    gpointer user_data)
+{
+  	Dispatcher *dispatcher = ((DispatcherSource*)source)->dispatcher;
+
+	dispatcher->dispatch_pending();
+  	return TRUE;
+}
+
+static const GSourceFuncs dispatcher_funcs = {
+	dispatcher_prepare,
+	dispatcher_check,
+	dispatcher_dispatch,
+	NULL
+};
+
+Glib::BusDispatcher::BusDispatcher()
+: _ctx(NULL), _priority(G_PRIORITY_DEFAULT), _source(NULL)
+{
+}
+
+Glib::BusDispatcher::~BusDispatcher()
+{
+	if (_source)
+	{
+		GSource *temp = _source;
+		_source = NULL;
+
+		g_source_destroy (temp);
+		g_source_unref (temp);
+	}
+
+	if (_ctx)
+		g_main_context_unref(_ctx);
+}
+
+void Glib::BusDispatcher::attach(GMainContext *ctx)
+{
+	g_assert(_ctx == NULL); // just to be sane
+
+	_ctx = ctx ? ctx : g_main_context_default();
+ 	g_main_context_ref(_ctx);
+	
+	// create the source for dispatching messages
+	_source = g_source_new((GSourceFuncs *) &dispatcher_funcs,
+	                       sizeof(DispatcherSource));
+
+	((DispatcherSource*)_source)->dispatcher = this;
+	g_source_attach (_source, _ctx);
+}
+
+Timeout *Glib::BusDispatcher::add_timeout(Timeout::Internal *wi)
+{
+	Timeout *t = new Glib::BusTimeout(wi, _ctx, _priority);
+
+	debug_log("glib: added timeout %p (%s)", t, t->enabled() ? "on":"off");
+
+	return t;
+}
+
+void Glib::BusDispatcher::rem_timeout(Timeout *t)
+{
+	debug_log("glib: removed timeout %p", t);
+
+	delete t;
+}
+
+Watch *Glib::BusDispatcher::add_watch(Watch::Internal *wi)
+{
+	Watch *w = new Glib::BusWatch(wi, _ctx, _priority);
+
+	debug_log("glib: added watch %p (%s) fd=%d flags=%d",
+		w, w->enabled() ? "on":"off", w->descriptor(), w->flags()
+	);
+	return w;
+}
+
+void Glib::BusDispatcher::rem_watch(Watch *w)
+{
+	debug_log("glib: removed watch %p", w);
+
+	delete w;
+}
+
+void Glib::BusDispatcher::set_priority(int priority)
+{
+	_priority = priority;
+}
diff --git a/src/interface.cpp b/src/interface.cpp
index 15d8596..1fa0618 100644
--- a/src/interface.cpp
+++ b/src/interface.cpp
@@ -27,13 +27,14 @@
 
 #include <dbus-c++/debug.h>
 #include <dbus-c++/interface.h>
+#include <dbus-c++/pendingcall.h>
 
 #include "internalerror.h"
 
 using namespace DBus;
 
 Interface::Interface(const std::string &name)
-  : _name(name)
+: _name(name)
 {}
 
 Interface::~Interface()
@@ -41,129 +42,166 @@ Interface::~Interface()
 
 InterfaceAdaptor *AdaptorBase::find_interface(const std::string &name)
 {
-  InterfaceAdaptorTable::const_iterator ii = _interfaces.find(name);
+	InterfaceAdaptorTable::const_iterator ii = _interfaces.find(name);
 
-  return ii != _interfaces.end() ? ii->second : NULL;
+	return ii != _interfaces.end() ? ii->second : NULL;
 }
 
 InterfaceAdaptor::InterfaceAdaptor(const std::string &name)
-  : Interface(name)
+: Interface(name)
 {
-  debug_log("adding interface %s", name.c_str());
+	debug_log("adding interface %s", name.c_str());
 
-  _interfaces[name] = this;
+	_interfaces[name] = this;
 }
 
 Message InterfaceAdaptor::dispatch_method(const CallMessage &msg)
 {
-  const char *name = msg.member();
-
-  MethodTable::iterator mi = _methods.find(name);
-  if (mi != _methods.end())
-  {
-    return mi->second.call(msg);
-  }
-  else
-  {
-    return ErrorMessage(msg, DBUS_ERROR_UNKNOWN_METHOD, name);
-  }
+	const char *name = msg.member();
+
+	MethodTable::iterator mi = _methods.find(name);
+	if (mi != _methods.end())
+	{
+		return mi->second.call(msg);
+	}
+	else
+	{
+		return ErrorMessage(msg, DBUS_ERROR_UNKNOWN_METHOD, name);
+	}
 }
 
 void InterfaceAdaptor::emit_signal(const SignalMessage &sig)
 {
-  SignalMessage &sig2 = const_cast<SignalMessage &>(sig);
+	SignalMessage &sig2 = const_cast<SignalMessage &>(sig);
 
-  if (sig2.interface() == NULL)
-    sig2.interface(name().c_str());
+	if (sig2.interface() == NULL)
+		sig2.interface(name().c_str());
 
-  _emit_signal(sig2);
+	_emit_signal(sig2);
 }
 
 Variant *InterfaceAdaptor::get_property(const std::string &name)
 {
-  PropertyTable::iterator pti = _properties.find(name);
+	PropertyTable::iterator pti = _properties.find(name);
 
-  if (pti != _properties.end())
-  {
-    if (!pti->second.read)
-      throw ErrorAccessDenied("property is not readable");
+	if (pti != _properties.end())
+	{
+		if (!pti->second.read)
+			throw ErrorAccessDenied("property is not readable");
 
-    return &(pti->second.value);
-  }
-  return NULL;
+		return &(pti->second.value);
+	}
+	return NULL;
 }
 
 void InterfaceAdaptor::set_property(const std::string &name, Variant &value)
 {
-  PropertyTable::iterator pti = _properties.find(name);
+	PropertyTable::iterator pti = _properties.find(name);
 
-  if (pti != _properties.end())
-  {
-    if (!pti->second.write)
-      throw ErrorAccessDenied("property is not writeable");
+	if (pti != _properties.end())
+	{
+		if (!pti->second.write)
+			throw ErrorAccessDenied("property is not writeable");
 
-    Signature sig = value.signature();
+		Signature sig = value.signature();
 
-    if (pti->second.sig != sig)
-      throw ErrorInvalidSignature("property expects a different type");
+		if (pti->second.sig != sig)
+			throw ErrorInvalidSignature("property expects a different type");
 
-    pti->second.value = value;
-    return;
-  }
-  throw ErrorFailed("requested property not found");
+		pti->second.value = value;
+		return;
+	}
+	throw ErrorFailed("requested property not found");
+}
+
+PropertyDict *InterfaceAdaptor::get_all_properties()
+{
+	PropertyTable::iterator pti;
+	PropertyDict *dict = new PropertyDict();
+
+	for (pti = _properties.begin(); pti != _properties.end(); ++pti)
+	{
+		// Skip unreadable properties
+		if (!pti->second.read)
+			continue;
+
+		Variant v = pti->second.value;
+		// Skip uninitialized properties
+		if (v.signature().empty())
+			continue;
+
+		std::string key = pti->first;
+		(*dict)[key] = v;
+	}
+	return dict;
 }
 
 InterfaceProxy *ProxyBase::find_interface(const std::string &name)
 {
-  InterfaceProxyTable::const_iterator ii = _interfaces.find(name);
+	InterfaceProxyTable::const_iterator ii = _interfaces.find(name);
 
-  return ii != _interfaces.end() ? ii->second : NULL;
+	return ii != _interfaces.end() ? ii->second : NULL;
 }
 
 InterfaceProxy::InterfaceProxy(const std::string &name)
-  : Interface(name)
+: Interface(name)
 {
-  debug_log("adding interface %s", name.c_str());
+	debug_log("adding interface %s", name.c_str());
 
-  _interfaces[name] = this;
+	_interfaces[name] = this;
 }
 
 bool InterfaceProxy::dispatch_signal(const SignalMessage &msg)
 {
-  const char *name = msg.member();
-
-  SignalTable::iterator si = _signals.find(name);
-  if (si != _signals.end())
-  {
-    si->second.call(msg);
-    // Here we always return false because there might be
-    // another InterfaceProxy listening for the same signal.
-    // This way we instruct libdbus-1 to go on dispatching
-    // the signal.
-    return false;
-  }
-  else
-  {
-    return false;
-  }
+	const char *name = msg.member();
+
+	SignalTable::iterator si = _signals.find(name);
+	if (si != _signals.end())
+	{
+		si->second.call(msg);
+		// Here we always return false because there might be
+		// another InterfaceProxy listening for the same signal.
+		// This way we instruct libdbus-1 to go on dispatching
+		// the signal.
+		return false;
+	}
+	else	
+	{
+		return false;
+	}
 }
 
 Message InterfaceProxy::invoke_method(const CallMessage &call)
 {
-  CallMessage &call2 = const_cast<CallMessage &>(call);
+	CallMessage &call2 = const_cast<CallMessage &>(call);
 
-  if (call.interface() == NULL)
-    call2.interface(name().c_str());
+	if (call.interface() == NULL)
+		call2.interface(name().c_str());
 
-  return _invoke_method(call2);
+	return _invoke_method(call2);
 }
 
 bool InterfaceProxy::invoke_method_noreply(const CallMessage &call)
 {
-  CallMessage &call2 = const_cast<CallMessage &>(call);
+	CallMessage &call2 = const_cast<CallMessage &>(call);
 
-  if (call.interface() == NULL)
-    call2.interface(name().c_str());
+	if (call.interface() == NULL)
+		call2.interface(name().c_str());
 
-  return _invoke_method_noreply(call2);
+	return _invoke_method_noreply(call2);
+}
+
+PendingCall *InterfaceProxy::invoke_method_async(const CallMessage &call, int timeout)
+{
+	CallMessage &call2 = const_cast<CallMessage &>(call);
+
+	if (call.interface() == NULL)
+		call2.interface(name().c_str());
+
+	return _invoke_method_async(call2, timeout);
+}
+
+void InterfaceProxy::remove_pending_call(PendingCall *pending)
+{
+	_remove_pending_call(pending);
 }
diff --git a/src/internalerror.h b/src/internalerror.h
index 7122a60..36fe20c 100644
--- a/src/internalerror.h
+++ b/src/internalerror.h
@@ -33,44 +33,43 @@
 
 #include <dbus/dbus.h>
 
-namespace DBus
-{
+namespace DBus {
 
 struct DXXAPI InternalError
 {
-  DBusError	error;
-
-  InternalError()
-  {
-    dbus_error_init(&error);
-  }
+	DBusError	error;
 
-  explicit InternalError(DBusError *e)
-  {
-    dbus_error_init(&error);
-    dbus_move_error(e, &error);
-  }
+	InternalError()
+	{
+		dbus_error_init(&error);
+	}
 
-  InternalError(const InternalError &ie)
-  {
-    dbus_error_init(&error);
-    dbus_move_error(const_cast<DBusError *>(&(ie.error)), &error);
-  }
+	explicit InternalError(DBusError *e)
+	{
+		dbus_error_init(&error);
+		dbus_move_error(e, &error);
+	}
 
-  ~InternalError()
-  {
-    dbus_error_free(&error);
-  }
+	InternalError(const InternalError &ie)
+	{
+		dbus_error_init(&error);
+		dbus_move_error(const_cast<DBusError *>(&(ie.error)), &error);
+	}
+	
+	~InternalError()
+	{
+		dbus_error_free(&error);
+	}
 
-  operator DBusError *()
-  {
-    return &error;
-  }
+	operator DBusError *()
+	{
+		return &error;
+	}
 
-  operator bool()
-  {
-    return dbus_error_is_set(&error);
-  }
+	operator bool()
+	{
+		return dbus_error_is_set(&error);
+	}
 };
 
 } /* namespace DBus */
diff --git a/src/introspection.cpp b/src/introspection.cpp
index 0b19ba9..f6f6bcc 100644
--- a/src/introspection.cpp
+++ b/src/introspection.cpp
@@ -38,156 +38,157 @@ using namespace DBus;
 static const char *introspectable_name = "org.freedesktop.DBus.Introspectable";
 
 IntrospectableAdaptor::IntrospectableAdaptor()
-  : InterfaceAdaptor(introspectable_name)
+: InterfaceAdaptor(introspectable_name)
 {
-  register_method(IntrospectableAdaptor, Introspect, Introspect);
+	register_method(IntrospectableAdaptor, Introspect, Introspect);
 }
 
 Message IntrospectableAdaptor::Introspect(const CallMessage &call)
 {
-  debug_log("requested introspection data");
+	debug_log("requested introspection data");
 
-  std::ostringstream xml;
+	std::ostringstream xml;
 
-  xml << DBUS_INTROSPECT_1_0_XML_DOCTYPE_DECL_NODE;
+	xml << DBUS_INTROSPECT_1_0_XML_DOCTYPE_DECL_NODE;
 
-  const std::string path = object()->path();
+	const std::string path = object()->path();
 
-  xml << "<node name=\"" << path << "\">";
+	xml << "<node name=\"" << path << "\">";
 
-  InterfaceAdaptorTable::const_iterator iti;
+	InterfaceAdaptorTable::const_iterator iti;
 
-  for (iti = _interfaces.begin(); iti != _interfaces.end(); ++iti)
-  {
-    debug_log("introspecting interface %s", iti->first.c_str());
+	for (iti = _interfaces.begin(); iti != _interfaces.end(); ++iti)
+	{
+		debug_log("introspecting interface %s", iti->first.c_str());
 
-    IntrospectedInterface *const intro = iti->second->introspect();
-    if (intro)
-    {
-      xml << "\n\t<interface name=\"" << intro->name << "\">";
+		const IntrospectedInterface *intro = iti->second->introspect();
+		if (intro)
+		{
+			xml << "\n\t<interface name=\"" << intro->name << "\">";
 
-      for (const IntrospectedProperty *p = intro->properties; p->name; ++p)
-      {
-        std::string access;
+			for (const IntrospectedProperty *p = intro->properties; p->name; ++p)
+			{
+				std::string access;
 
-        if (p->read)  access += "read";
-        if (p->write) access += "write";
+				if (p->read)  access += "read";
+				if (p->write) access += "write";
 
-        xml << "\n\t\t<property name=\"" << p->name << "\""
-            << " type=\"" << p->type << "\""
-            << " access=\"" << access << "\"/>";
-      }
+				xml << "\n\t\t<property name=\"" << p->name << "\""
+				    << " type=\"" << p->type << "\""
+				    << " access=\"" << access << "\"/>";
+			}
 
-      for (const IntrospectedMethod *m = intro->methods; m->args; ++m)
-      {
-        xml << "\n\t\t<method name=\"" << m->name << "\">";
+			for (const IntrospectedMethod *m = intro->methods; m->args; ++m)
+			{
+				xml << "\n\t\t<method name=\"" << m->name << "\">";
 
-        for (const IntrospectedArgument *a = m->args; a->type; ++a)
-        {
-          xml << "\n\t\t\t<arg direction=\"" << (a->in ? "in" : "out") << "\""
-              << " type=\"" << a->type << "\"";
+				for (const IntrospectedArgument *a = m->args; a->type; ++a)
+				{
+					xml << "\n\t\t\t<arg direction=\"" << (a->in ? "in" : "out") << "\""
+					    << " type=\"" << a->type << "\"";
 
-          if (a->name) xml << " name=\"" << a->name << "\"";
+					if (a->name) xml << " name=\"" << a->name << "\"";
 
-          xml << "/>";
-        }
+					xml << "/>";
+				}
 
-        xml << "\n\t\t</method>";
-      }
+				xml << "\n\t\t</method>";
+			}
 
-      for (const IntrospectedMethod *m = intro->signals; m->args; ++m)
-      {
-        xml << "\n\t\t<signal name=\"" << m->name << "\">";
+			for (const IntrospectedMethod *m = intro->signals; m->args; ++m)
+			{
+				xml << "\n\t\t<signal name=\"" << m->name << "\">";
 
-        for (const IntrospectedArgument *a = m->args; a->type; ++a)
-        {
-          xml << "<arg type=\"" << a->type << "\"";
+				for (const IntrospectedArgument *a = m->args; a->type; ++a)
+				{
+					xml << "<arg type=\"" << a->type << "\"";
 
-          if (a->name) xml << " name=\"" << a->name << "\"";
+					if (a->name) xml << " name=\"" << a->name << "\"";
 
-          xml << "/>";
-        }
-        xml << "\n\t\t</signal>";
-      }
+					xml << "/>";
+				}
+				xml << "\n\t\t</signal>";
+			}
 
-      xml << "\n\t</interface>";
-    }
-  }
+			xml << "\n\t</interface>";
+		}
+	}
 
-  const ObjectPathList nodes = ObjectAdaptor::child_nodes_from_prefix(path + '/');
-  ObjectPathList::const_iterator oni;
+	const std::string prefix(path == "/" ? path : path + '/');
+	const ObjectPathList nodes = ObjectAdaptor::child_nodes_from_prefix(prefix);
+	ObjectPathList::const_iterator oni;
 
-  for (oni = nodes.begin(); oni != nodes.end(); ++oni)
-  {
-    xml << "\n\t<node name=\"" << (*oni) << "\"/>";
-  }
+	for (oni = nodes.begin(); oni != nodes.end(); ++oni) 
+	{
+		xml << "\n\t<node name=\"" << (*oni) << "\"/>";
+	}
 
-  /* broken
-  const ObjectAdaptorPList children = ObjectAdaptor::from_path_prefix(path + '/');
+	/* broken
+	const ObjectAdaptorPList children = ObjectAdaptor::from_path_prefix(path + '/');
 
-  ObjectAdaptorPList::const_iterator oci;
+	ObjectAdaptorPList::const_iterator oci;
 
-  for (oci = children.begin(); oci != children.end(); ++oci)
-  {
-  	std::string name = (*oci)->path().substr(path.length()+1);
-  	name.substr(name.find('/'));
+	for (oci = children.begin(); oci != children.end(); ++oci) 
+	{
+		std::string name = (*oci)->path().substr(path.length()+1);
+		name.substr(name.find('/'));
 
-  	xml << "<node name=\"" << name << "\"/>";
-  }
-  */
+		xml << "<node name=\"" << name << "\"/>";
+	}
+	*/
 
-  xml << "\n</node>";
+	xml << "\n</node>";
 
-  ReturnMessage reply(call);
-  MessageIter wi = reply.writer();
-  wi.append_string(xml.str().c_str());
-  return reply;
+	ReturnMessage reply(call);
+	MessageIter wi = reply.writer();
+	wi.append_string(xml.str().c_str());
+	return reply;
 }
 
-IntrospectedInterface *IntrospectableAdaptor::introspect() const
+const IntrospectedInterface *IntrospectableAdaptor::introspect() const
 {
-  static IntrospectedArgument Introspect_args[] =
-  {
-    { "data", "s", false },
-    { 0, 0, 0 }
-  };
-  static IntrospectedMethod Introspectable_methods[] =
-  {
-    { "Introspect", Introspect_args },
-    { 0, 0 }
-  };
-  static IntrospectedMethod Introspectable_signals[] =
-  {
-    { 0, 0 }
-  };
-  static IntrospectedProperty Introspectable_properties[] =
-  {
-    { 0, 0, 0, 0 }
-  };
-  static IntrospectedInterface Introspectable_interface =
-  {
-    introspectable_name,
-    Introspectable_methods,
-    Introspectable_signals,
-    Introspectable_properties
-  };
-  return &Introspectable_interface;
+	static IntrospectedArgument Introspect_args[] =
+	{
+		{ "data", "s", false },
+		{ 0, 0, 0 }
+	};
+	static IntrospectedMethod Introspectable_methods[] =
+	{
+		{ "Introspect", Introspect_args },
+		{ 0, 0 }
+	};
+	static IntrospectedMethod Introspectable_signals[] =
+	{
+		{ 0, 0 }
+	};
+	static IntrospectedProperty Introspectable_properties[] =
+	{
+		{ 0, 0, 0, 0 }
+	};
+	static IntrospectedInterface Introspectable_interface =
+	{
+		introspectable_name,
+		Introspectable_methods,
+		Introspectable_signals,
+		Introspectable_properties
+	};
+	return &Introspectable_interface;
 }
 
 IntrospectableProxy::IntrospectableProxy()
-  : InterfaceProxy(introspectable_name)
+: InterfaceProxy(introspectable_name)
 {}
 
 std::string IntrospectableProxy::Introspect()
 {
-  DBus::CallMessage call;
+	DBus::CallMessage call;
 
-  call.member("Introspect");
+	call.member("Introspect");
 
-  DBus::Message ret = invoke_method(call);
+	DBus::Message ret = invoke_method(call);
 
-  DBus::MessageIter ri = ret.reader();
-  const char *str = ri.get_string();
+	DBus::MessageIter ri = ret.reader();
+	const char *str = ri.get_string();
 
-  return str;
+	return str;
 }
diff --git a/src/message.cpp b/src/message.cpp
index 3f0cac4..d7ee196 100644
--- a/src/message.cpp
+++ b/src/message.cpp
@@ -38,449 +38,499 @@ using namespace DBus;
 /*
 */
 
+MessageIter::MessageIter()
+: _pvt(new Private), _msg(NULL) {}
+
+MessageIter::MessageIter(Message &msg)
+: _pvt(new Private), _msg(&msg) {}
+
+MessageIter::MessageIter(const MessageIter &iter)
+: _pvt(new Private(*iter._pvt)), _msg(iter._msg) {}
+
+MessageIter::~MessageIter()
+{
+	delete _pvt;
+	_pvt = NULL;
+	_msg = NULL;
+}
+
+MessageIter &MessageIter::operator =(const MessageIter &iter)
+{
+	if (this != &iter)
+	{
+		*_pvt = *iter._pvt;
+		_msg = iter._msg;
+	}
+	return *this;
+}
+
 int MessageIter::type()
 {
-  return dbus_message_iter_get_arg_type((DBusMessageIter *)&_iter);
+	return dbus_message_iter_get_arg_type(&_pvt->iter);
 }
 
 bool MessageIter::at_end()
 {
-  return type() == DBUS_TYPE_INVALID;
+	return type() == DBUS_TYPE_INVALID;
 }
 
 bool MessageIter::has_next()
 {
-  return dbus_message_iter_has_next((DBusMessageIter *)&_iter);
+	return dbus_message_iter_has_next(&_pvt->iter);
 }
 
 MessageIter &MessageIter::operator ++()
 {
-  dbus_message_iter_next((DBusMessageIter *)&_iter);
-  return (*this);
+	dbus_message_iter_next(&_pvt->iter);
+	return (*this);
 }
 
 MessageIter MessageIter::operator ++(int)
 {
-  MessageIter copy(*this);
-  ++(*this);
-  return copy;
+	MessageIter copy(*this);
+	++(*this);
+	return copy;
 }
 
 bool MessageIter::append_basic(int type_id, void *value)
 {
-  return dbus_message_iter_append_basic((DBusMessageIter *)&_iter, type_id, value);
+	return dbus_message_iter_append_basic(&_pvt->iter, type_id, value);
 }
 
 void MessageIter::get_basic(int type_id, void *ptr)
 {
-  if (type() != type_id)
-    throw ErrorInvalidArgs("type mismatch");
+	if (type() != type_id)
+		throw ErrorInvalidArgs("type mismatch");
 
-  dbus_message_iter_get_basic((DBusMessageIter *)_iter, ptr);
+	dbus_message_iter_get_basic(&_pvt->iter, ptr);
 }
 
 bool MessageIter::append_byte(unsigned char b)
 {
-  return append_basic(DBUS_TYPE_BYTE, &b);
+	return append_basic(DBUS_TYPE_BYTE, &b);
 }
 
 unsigned char MessageIter::get_byte()
 {
-  unsigned char b;
-  get_basic(DBUS_TYPE_BYTE, &b);
-  return b;
+ 	unsigned char b;
+	get_basic(DBUS_TYPE_BYTE, &b);
+ 	return b;
 }
 
 bool MessageIter::append_bool(bool b)
 {
-  dbus_bool_t db = b;
-  return append_basic(DBUS_TYPE_BOOLEAN, &db);
+	dbus_bool_t db = b ? TRUE : FALSE;
+	return append_basic(DBUS_TYPE_BOOLEAN, &db);
 }
 
 bool MessageIter::get_bool()
 {
-  dbus_bool_t db;
-  get_basic(DBUS_TYPE_BOOLEAN, &db);
-  return (bool)db;
+ 	dbus_bool_t db;
+	get_basic(DBUS_TYPE_BOOLEAN, &db);
+	return db ? true : false;
 }
 
 bool MessageIter::append_int16(signed short i)
 {
-  return append_basic(DBUS_TYPE_INT16, &i);
+	return append_basic(DBUS_TYPE_INT16, &i);
 }
 
 signed short MessageIter::get_int16()
 {
-  signed short i;
-  get_basic(DBUS_TYPE_INT16, &i);
-  return i;
+ 	signed short i;
+	get_basic(DBUS_TYPE_INT16, &i);
+ 	return i;
 }
 
 bool MessageIter::append_uint16(unsigned short u)
 {
-  return append_basic(DBUS_TYPE_UINT16, &u);
+	return append_basic(DBUS_TYPE_UINT16, &u);
 }
 
 unsigned short MessageIter::get_uint16()
 {
-  unsigned short u;
-  get_basic(DBUS_TYPE_UINT16, &u);
-  return u;
+	unsigned short u;
+	get_basic(DBUS_TYPE_UINT16, &u);
+ 	return u;
 }
 
 bool MessageIter::append_int32(signed int i)
 {
-  return append_basic(DBUS_TYPE_INT32, &i);
+	return append_basic(DBUS_TYPE_INT32, &i);
 }
 
 signed int MessageIter::get_int32()
 {
-  signed int i;
-  get_basic(DBUS_TYPE_INT32, &i);
-  return i;
+ 	signed int i;
+	get_basic(DBUS_TYPE_INT32, &i);
+ 	return i;
 }
 
 bool MessageIter::append_uint32(unsigned int u)
 {
-  return append_basic(DBUS_TYPE_UINT32, &u);
+	return append_basic(DBUS_TYPE_UINT32, &u);
 }
 
 unsigned int MessageIter::get_uint32()
 {
-  unsigned int u;
-  get_basic(DBUS_TYPE_UINT32, &u);
-  return u;
+	unsigned int u;
+	get_basic(DBUS_TYPE_UINT32, &u);
+ 	return u;
 }
 
 signed long long MessageIter::get_int64()
 {
-  signed long long i;
-  get_basic(DBUS_TYPE_INT64, &i);
-  return i;
+	signed long long i;
+	get_basic(DBUS_TYPE_INT64, &i);
+	return i;
 }
 
 bool MessageIter::append_int64(signed long long i)
 {
-  return append_basic(DBUS_TYPE_INT64, &i);
+	return append_basic(DBUS_TYPE_INT64, &i);
 }
 
 unsigned long long MessageIter::get_uint64()
 {
-  unsigned long long u;
-  get_basic(DBUS_TYPE_UINT64, &u);
-  return u;
+	unsigned long long u;
+	get_basic(DBUS_TYPE_UINT64, &u);
+	return u;
 }
 
 bool MessageIter::append_uint64(unsigned long long u)
 {
-  return append_basic(DBUS_TYPE_UINT64, &u);
+	return append_basic(DBUS_TYPE_UINT64, &u);
 }
 
 double MessageIter::get_double()
 {
-  double d;
-  get_basic(DBUS_TYPE_DOUBLE, &d);
-  return d;
+	double d;
+	get_basic(DBUS_TYPE_DOUBLE, &d);
+	return d;
 }
 
 bool MessageIter::append_double(double d)
 {
-  return append_basic(DBUS_TYPE_DOUBLE, &d);
+	return append_basic(DBUS_TYPE_DOUBLE, &d);
 }
 
 bool MessageIter::append_string(const char *chars)
 {
-  return append_basic(DBUS_TYPE_STRING, &chars);
+	return append_basic(DBUS_TYPE_STRING, &chars);
 }
 
 const char *MessageIter::get_string()
 {
-  char *chars;
-  get_basic(DBUS_TYPE_STRING, &chars);
-  return chars;
+	char *chars;
+	get_basic(DBUS_TYPE_STRING, &chars);
+ 	return chars;
 }
 
 bool MessageIter::append_path(const char *chars)
 {
-  return append_basic(DBUS_TYPE_OBJECT_PATH, &chars);
+	return append_basic(DBUS_TYPE_OBJECT_PATH, &chars);
 }
 
 const char *MessageIter::get_path()
 {
-  char *chars;
-  get_basic(DBUS_TYPE_OBJECT_PATH, &chars);
-  return chars;
+	char *chars;
+	get_basic(DBUS_TYPE_OBJECT_PATH, &chars);
+ 	return chars;
 }
 
 bool MessageIter::append_signature(const char *chars)
 {
-  return append_basic(DBUS_TYPE_SIGNATURE, &chars);
+	return append_basic(DBUS_TYPE_SIGNATURE, &chars);
 }
 
 const char *MessageIter::get_signature()
 {
-  char *chars;
-  get_basic(DBUS_TYPE_SIGNATURE, &chars);
-  return chars;
+	char *chars;
+	get_basic(DBUS_TYPE_SIGNATURE, &chars);
+ 	return chars;
+}
+
+bool MessageIter::append_fd(int fd)
+{
+	return append_basic(DBUS_TYPE_UNIX_FD, &fd);
+}
+
+int MessageIter::get_fd()
+{
+	int fd;
+	get_basic(DBUS_TYPE_UNIX_FD, &fd);
+	return fd;
 }
 
 MessageIter MessageIter::recurse()
 {
-  MessageIter iter(msg());
-  dbus_message_iter_recurse((DBusMessageIter *)&_iter, (DBusMessageIter *) & (iter._iter));
-  return iter;
+	MessageIter iter(msg());
+	dbus_message_iter_recurse(&_pvt->iter, &iter._pvt->iter);
+	return iter;
 }
 
 char *MessageIter::signature() const
 {
-  return dbus_message_iter_get_signature((DBusMessageIter *)&_iter);
+	return dbus_message_iter_get_signature(&_pvt->iter);
 }
 
 bool MessageIter::append_array(char type, const void *ptr, size_t length)
 {
-  return dbus_message_iter_append_fixed_array((DBusMessageIter *)&_iter, type, &ptr, length);
+	return dbus_message_iter_append_fixed_array(&_pvt->iter, type, &ptr, length);
 }
 
 int MessageIter::array_type()
 {
-  return dbus_message_iter_get_element_type((DBusMessageIter *)&_iter);
+	return dbus_message_iter_get_element_type(&_pvt->iter);
 }
 
 int MessageIter::get_array(void *ptr)
 {
-  int length;
-  dbus_message_iter_get_fixed_array((DBusMessageIter *)&_iter, ptr, &length);
-  return length;
+	int length;
+	dbus_message_iter_get_fixed_array(&_pvt->iter, ptr, &length);
+	return length;
 }
 
 bool MessageIter::is_array()
 {
-  return dbus_message_iter_get_arg_type((DBusMessageIter *)&_iter) == DBUS_TYPE_ARRAY;
+	return dbus_message_iter_get_arg_type(&_pvt->iter) == DBUS_TYPE_ARRAY;
 }
 
 bool MessageIter::is_dict()
 {
-  return is_array() && dbus_message_iter_get_element_type((DBusMessageIter *)_iter) == DBUS_TYPE_DICT_ENTRY;
+	return is_array() && dbus_message_iter_get_element_type(&_pvt->iter) == DBUS_TYPE_DICT_ENTRY;
 }
 
 MessageIter MessageIter::new_array(const char *sig)
 {
-  MessageIter arr(msg());
-  dbus_message_iter_open_container(
-    (DBusMessageIter *)&_iter, DBUS_TYPE_ARRAY, sig, (DBusMessageIter *) & (arr._iter)
-  );
-  return arr;
+	MessageIter arr(msg());
+	dbus_message_iter_open_container(
+		&_pvt->iter, DBUS_TYPE_ARRAY, sig, &arr._pvt->iter
+	);
+	return arr;
 }
 
 MessageIter MessageIter::new_variant(const char *sig)
 {
-  MessageIter var(msg());
-  dbus_message_iter_open_container(
-    (DBusMessageIter *)_iter, DBUS_TYPE_VARIANT, sig, (DBusMessageIter *) & (var._iter)
-  );
-  return var;
+	MessageIter var(msg());
+	dbus_message_iter_open_container(
+		&_pvt->iter, DBUS_TYPE_VARIANT, sig, &var._pvt->iter
+	);
+	return var;
 }
 
 MessageIter MessageIter::new_struct()
 {
-  MessageIter stu(msg());
-  dbus_message_iter_open_container(
-    (DBusMessageIter *)_iter, DBUS_TYPE_STRUCT, NULL, (DBusMessageIter *) & (stu._iter)
-  );
-  return stu;
+	MessageIter stu(msg());
+	dbus_message_iter_open_container(
+		&_pvt->iter, DBUS_TYPE_STRUCT, NULL, &stu._pvt->iter
+	);
+	return stu;
 }
 
 MessageIter MessageIter::new_dict_entry()
 {
-  MessageIter ent(msg());
-  dbus_message_iter_open_container(
-    (DBusMessageIter *)_iter, DBUS_TYPE_DICT_ENTRY, NULL, (DBusMessageIter *) & (ent._iter)
-  );
-  return ent;
+	MessageIter ent(msg());
+	dbus_message_iter_open_container(
+		&_pvt->iter, DBUS_TYPE_DICT_ENTRY, NULL, &ent._pvt->iter
+	);
+	return ent;
 }
 
 void MessageIter::close_container(MessageIter &container)
 {
-  dbus_message_iter_close_container((DBusMessageIter *)&_iter, (DBusMessageIter *) & (container._iter));
+	dbus_message_iter_close_container(&_pvt->iter, &container._pvt->iter);
 }
 
 static bool is_basic_type(int typecode)
 {
-  switch (typecode)
-  {
-  case 'y':
-  case 'b':
-  case 'n':
-  case 'q':
-  case 'i':
-  case 'u':
-  case 'x':
-  case 't':
-  case 'd':
-  case 's':
-  case 'o':
-  case 'g':
-    return true;
-  default:
-    return false;
-  }
+	switch (typecode)
+	{
+		case DBUS_TYPE_BYTE:
+		case DBUS_TYPE_BOOLEAN:
+		case DBUS_TYPE_INT16:
+		case DBUS_TYPE_UINT16:
+		case DBUS_TYPE_INT32:
+		case DBUS_TYPE_UINT32:
+		case DBUS_TYPE_INT64:
+		case DBUS_TYPE_UINT64:
+		case DBUS_TYPE_DOUBLE:
+		case DBUS_TYPE_STRING:
+		case DBUS_TYPE_OBJECT_PATH:
+		case DBUS_TYPE_SIGNATURE:
+		case DBUS_TYPE_UNIX_FD:
+			return true;
+		default:
+			return false;
+	}
 }
 
 void MessageIter::copy_data(MessageIter &to)
 {
-  for (MessageIter &from = *this; !from.at_end(); ++from)
-  {
-    if (is_basic_type(from.type()))
-    {
-      debug_log("copying basic type: %c", from.type());
-
-      unsigned char value[8];
-      from.get_basic(from.type(), &value);
-      to.append_basic(from.type(), &value);
-    }
-    else
-    {
-      MessageIter from_container = from.recurse();
-      char *sig = from_container.signature();
-
-      debug_log("copying compound type: %c[%s]", from.type(), sig);
-
-      MessageIter to_container(to.msg());
-      dbus_message_iter_open_container
-      (
-        (DBusMessageIter *) & (to._iter),
-        from.type(),
-        from.type() == DBUS_TYPE_VARIANT ? NULL : sig,
-        (DBusMessageIter *) & (to_container._iter)
-      );
-
-      from_container.copy_data(to_container);
-      to.close_container(to_container);
-      free(sig);
-    }
-  }
+	for (MessageIter &from = *this; !from.at_end(); ++from)
+	{
+		if (is_basic_type(from.type()))
+		{
+			debug_log("copying basic type: %c", from.type());
+
+			unsigned char value[8];
+			from.get_basic(from.type(), &value);
+			to.append_basic(from.type(), &value);
+		}
+		else
+		{
+			MessageIter from_container = from.recurse();
+			char *sig = from_container.signature();
+
+			debug_log("copying compound type: %c[%s]", from.type(), sig);
+
+			MessageIter to_container (to.msg());
+			dbus_message_iter_open_container
+			(
+				&to._pvt->iter,
+				from.type(),
+				from.type() == DBUS_TYPE_DICT_ENTRY ||
+				from.type() == DBUS_TYPE_STRUCT ? NULL : sig,
+				&to_container._pvt->iter
+			);
+
+			from_container.copy_data(to_container);
+			to.close_container(to_container);
+			free(sig);
+		}
+	}
 }
 
 /*
 */
 
 Message::Message()
-  : _pvt(new Private)
+: _pvt(new Private)
 {
 }
 
 Message::Message(Message::Private *p, bool incref)
-  : _pvt(p)
+: _pvt(p)
 {
-  if (_pvt->msg && incref) dbus_message_ref(_pvt->msg);
+	if (_pvt->msg && incref) dbus_message_ref(_pvt->msg);
 }
 
 Message::Message(const Message &m)
-  : _pvt(m._pvt)
+: _pvt(m._pvt)
 {
-  dbus_message_ref(_pvt->msg);
+	if (_pvt->msg)
+		dbus_message_ref(_pvt->msg);
 }
 
 Message::~Message()
 {
-  dbus_message_unref(_pvt->msg);
+	if (_pvt->msg)
+		dbus_message_unref(_pvt->msg);
 }
 
 Message &Message::operator = (const Message &m)
 {
-  if (&m != this)
-  {
-    dbus_message_unref(_pvt->msg);
-    _pvt = m._pvt;
-    dbus_message_ref(_pvt->msg);
-  }
-  return *this;
+	if (&m != this)
+	{
+		if (_pvt->msg)
+			dbus_message_unref(_pvt->msg);
+		_pvt = m._pvt;
+		if (_pvt->msg)
+			dbus_message_ref(_pvt->msg);
+	}
+	return *this;
 }
 
 Message Message::copy()
 {
-  Private *pvt = new Private(dbus_message_copy(_pvt->msg));
-  return Message(pvt);
+	Private *pvt = new Private(_pvt->msg ? dbus_message_copy(_pvt->msg) : NULL);
+	return Message(pvt);
 }
 
 bool Message::append(int first_type, ...)
 {
-  va_list vl;
-  va_start(vl, first_type);
+	va_list vl;
+	va_start(vl, first_type);
 
-  bool b = dbus_message_append_args_valist(_pvt->msg, first_type, vl);
+	bool b = dbus_message_append_args_valist(_pvt->msg, first_type, vl);
 
-  va_end(vl);
-  return b;
+	va_end(vl);
+	return b;
 }
 
 void Message::terminate()
 {
-  dbus_message_append_args(_pvt->msg, DBUS_TYPE_INVALID);
+	dbus_message_append_args(_pvt->msg, DBUS_TYPE_INVALID);
 }
 
 int Message::type() const
 {
-  return dbus_message_get_type(_pvt->msg);
+	return dbus_message_get_type(_pvt->msg);
 }
 
 int Message::serial() const
 {
-  return dbus_message_get_serial(_pvt->msg);
+	return dbus_message_get_serial(_pvt->msg);
 }
 
 int Message::reply_serial() const
 {
-  return dbus_message_get_reply_serial(_pvt->msg);
+	return dbus_message_get_reply_serial(_pvt->msg);
 }
 
 bool Message::reply_serial(int s)
 {
-  return dbus_message_set_reply_serial(_pvt->msg, s);
+	return dbus_message_set_reply_serial(_pvt->msg, s);
 }
 
 const char *Message::sender() const
 {
-  return dbus_message_get_sender(_pvt->msg);
+	return dbus_message_get_sender(_pvt->msg);
 }
 
 bool Message::sender(const char *s)
 {
-  return dbus_message_set_sender(_pvt->msg, s);
+	return dbus_message_set_sender(_pvt->msg, s);
 }
 
 const char *Message::destination() const
 {
-  return dbus_message_get_destination(_pvt->msg);
+	return dbus_message_get_destination(_pvt->msg);
 }
 
 bool Message::destination(const char *s)
 {
-  return dbus_message_set_destination(_pvt->msg, s);
+	return dbus_message_set_destination(_pvt->msg, s);
 }
 
 bool Message::is_error() const
 {
-  return type() == DBUS_MESSAGE_TYPE_ERROR;
+	return type() == DBUS_MESSAGE_TYPE_ERROR;
 }
 
 bool Message::is_signal(const char *interface, const char *member) const
 {
-  return dbus_message_is_signal(_pvt->msg, interface, member);
+	return dbus_message_is_signal(_pvt->msg, interface, member);
 }
 
+Tag *Message::tag() const
+{
+	return _pvt->tag;
+}
+
+
 MessageIter Message::writer()
 {
-  MessageIter iter(*this);
-  dbus_message_iter_init_append(_pvt->msg, (DBusMessageIter *) & (iter._iter));
-  return iter;
+	MessageIter iter(*this);
+	dbus_message_iter_init_append(_pvt->msg, &iter._pvt->iter);
+	return iter;
 }
 
 MessageIter Message::reader() const
 {
-  MessageIter iter(const_cast<Message &>(*this));
-  dbus_message_iter_init(_pvt->msg, (DBusMessageIter *) & (iter._iter));
-  return iter;
+	MessageIter iter(const_cast<Message &>(*this));
+	dbus_message_iter_init(_pvt->msg, &iter._pvt->iter);
+	return iter;
 }
 
 /*
@@ -488,27 +538,27 @@ MessageIter Message::reader() const
 
 ErrorMessage::ErrorMessage()
 {
-  _pvt->msg = dbus_message_new(DBUS_MESSAGE_TYPE_ERROR);
+	_pvt->msg = dbus_message_new(DBUS_MESSAGE_TYPE_ERROR);
 }
 
 ErrorMessage::ErrorMessage(const Message &to_reply, const char *name, const char *message)
 {
-  _pvt->msg = dbus_message_new_error(to_reply._pvt->msg, name, message);
+	_pvt->msg = dbus_message_new_error(to_reply._pvt->msg, name, message);
 }
 
 bool ErrorMessage::operator == (const ErrorMessage &m) const
 {
-  return dbus_message_is_error(_pvt->msg, m.name());
+	return dbus_message_is_error(_pvt->msg, m.name());
 }
 
 const char *ErrorMessage::name() const
 {
-  return dbus_message_get_error_name(_pvt->msg);
+	return dbus_message_get_error_name(_pvt->msg);
 }
 
 bool ErrorMessage::name(const char *n)
 {
-  return dbus_message_set_error_name(_pvt->msg, n);
+	return dbus_message_set_error_name(_pvt->msg, n);
 }
 
 /*
@@ -516,55 +566,55 @@ bool ErrorMessage::name(const char *n)
 
 SignalMessage::SignalMessage(const char *name)
 {
-  _pvt->msg = dbus_message_new(DBUS_MESSAGE_TYPE_SIGNAL);
-  member(name);
+	_pvt->msg = dbus_message_new(DBUS_MESSAGE_TYPE_SIGNAL);
+	member(name);
 }
 
 SignalMessage::SignalMessage(const char *path, const char *interface, const char *name)
 {
-  _pvt->msg = dbus_message_new_signal(path, interface, name);
+	_pvt->msg = dbus_message_new_signal(path, interface, name);
 }
 
 bool SignalMessage::operator == (const SignalMessage &m) const
 {
-  return dbus_message_is_signal(_pvt->msg, m.interface(), m.member());
+	return dbus_message_is_signal(_pvt->msg, m.interface(), m.member());
 }
 
 const char *SignalMessage::interface() const
 {
-  return dbus_message_get_interface(_pvt->msg);
+	return dbus_message_get_interface(_pvt->msg);
 }
 
 bool SignalMessage::interface(const char *i)
 {
-  return dbus_message_set_interface(_pvt->msg, i);
+	return dbus_message_set_interface(_pvt->msg, i);
 }
 
 const char *SignalMessage::member() const
 {
-  return dbus_message_get_member(_pvt->msg);
+	return dbus_message_get_member(_pvt->msg);
 }
 
 bool SignalMessage::member(const char *m)
 {
-  return dbus_message_set_member(_pvt->msg, m);
+	return dbus_message_set_member(_pvt->msg, m);
 }
 
 const char *SignalMessage::path() const
 {
-  return dbus_message_get_path(_pvt->msg);
+	return dbus_message_get_path(_pvt->msg);
 }
 
-char **SignalMessage::path_split() const
+char ** SignalMessage::path_split() const
 {
-  char **p;
-  dbus_message_get_path_decomposed(_pvt->msg, &p);	//todo: return as a std::vector ?
-  return p;
+	char ** p;
+	dbus_message_get_path_decomposed(_pvt->msg, &p);	//todo: return as a std::vector ?
+	return p;
 }
 
 bool SignalMessage::path(const char *p)
 {
-  return dbus_message_set_path(_pvt->msg, p);
+	return dbus_message_set_path(_pvt->msg, p);
 }
 
 /*
@@ -572,59 +622,67 @@ bool SignalMessage::path(const char *p)
 
 CallMessage::CallMessage()
 {
-  _pvt->msg = dbus_message_new(DBUS_MESSAGE_TYPE_METHOD_CALL);
+	_pvt->msg = dbus_message_new(DBUS_MESSAGE_TYPE_METHOD_CALL);
 }
 
 CallMessage::CallMessage(const char *dest, const char *path, const char *iface, const char *method)
 {
-  _pvt->msg = dbus_message_new_method_call(dest, path, iface, method);
+	_pvt->msg = dbus_message_new_method_call(dest, path, iface, method);
 }
 
 bool CallMessage::operator == (const CallMessage &m) const
 {
-  return dbus_message_is_method_call(_pvt->msg, m.interface(), m.member());
+	return dbus_message_is_method_call(_pvt->msg, m.interface(), m.member());
 }
 
 const char *CallMessage::interface() const
 {
-  return dbus_message_get_interface(_pvt->msg);
+	return dbus_message_get_interface(_pvt->msg);
 }
 
 bool CallMessage::interface(const char *i)
 {
-  return dbus_message_set_interface(_pvt->msg, i);
+	return dbus_message_set_interface(_pvt->msg, i);
 }
 
 const char *CallMessage::member() const
 {
-  return dbus_message_get_member(_pvt->msg);
+	return dbus_message_get_member(_pvt->msg);
 }
 
 bool CallMessage::member(const char *m)
 {
-  return dbus_message_set_member(_pvt->msg, m);
+	return dbus_message_set_member(_pvt->msg, m);
 }
 
 const char *CallMessage::path() const
 {
-  return dbus_message_get_path(_pvt->msg);
+	return dbus_message_get_path(_pvt->msg);
 }
 
-char **CallMessage::path_split() const
+char ** CallMessage::path_split() const
 {
-  char **p;
-  dbus_message_get_path_decomposed(_pvt->msg, &p);
-  return p;
+	char ** p;
+	dbus_message_get_path_decomposed(_pvt->msg, &p);
+	return p;
 }
 
 bool CallMessage::path(const char *p)
 {
-  return dbus_message_set_path(_pvt->msg, p);
+	return dbus_message_set_path(_pvt->msg, p);
 }
 
 const char *CallMessage::signature() const
 {
-  return dbus_message_get_signature(_pvt->msg);
+	return dbus_message_get_signature(_pvt->msg);
+}
+
+/*
+ */
+
+TagMessage::TagMessage(Tag *tag)
+{
+	_pvt->tag = tag;
 }
 
 /*
@@ -632,11 +690,10 @@ const char *CallMessage::signature() const
 
 ReturnMessage::ReturnMessage(const CallMessage &callee)
 {
-  _pvt = new Private(dbus_message_new_method_return(callee._pvt->msg));
+	_pvt = new Private(dbus_message_new_method_return(callee._pvt->msg));
 }
 
 const char *ReturnMessage::signature() const
 {
-  return dbus_message_get_signature(_pvt->msg);
+	return dbus_message_get_signature(_pvt->msg);
 }
-
diff --git a/src/message_p.h b/src/message_p.h
index 9e9f107..926b7f9 100644
--- a/src/message_p.h
+++ b/src/message_p.h
@@ -34,18 +34,22 @@
 
 #include <dbus/dbus.h>
 
-namespace DBus
-{
+namespace DBus {
+
+struct DXXAPILOCAL MessageIter::Private {
+	DBusMessageIter iter;
+};
 
 struct DXXAPILOCAL Message::Private
 {
-  DBusMessage *msg;
+	DBusMessage *msg;
+        Tag *tag;
 
-  Private() : msg(0)
-  {}
+	Private() : msg(0), tag(0)
+	{}
 
-  Private(DBusMessage *m) : msg(m)
-  {}
+	Private(DBusMessage *m) : msg(m), tag(0)
+	{}
 };
 
 } /* namespace DBus */
diff --git a/src/object.cpp b/src/object.cpp
index 96e20ba..40f7cac 100644
--- a/src/object.cpp
+++ b/src/object.cpp
@@ -40,7 +40,7 @@
 using namespace DBus;
 
 Object::Object(Connection &conn, const Path &path, const char *service)
-  : _conn(conn), _path(path), _service(service ? service : ""), _default_timeout(-1)
+: _conn(conn), _path(path), _service(service ? service : "")
 {
 }
 
@@ -48,55 +48,47 @@ Object::~Object()
 {
 }
 
-void Object::set_timeout(int new_timeout)
-{
-  debug_log("%s: %d millies", __PRETTY_FUNCTION__, new_timeout);
-  if (new_timeout < 0 && new_timeout != -1)
-    throw ErrorInvalidArgs("Bad timeout, cannot set it");
-  _default_timeout = new_timeout;
-}
-
 struct ObjectAdaptor::Private
 {
-  static void unregister_function_stub(DBusConnection *, void *);
-  static DBusHandlerResult message_function_stub(DBusConnection *, DBusMessage *, void *);
+	static void unregister_function_stub(DBusConnection *, void *);
+	static DBusHandlerResult message_function_stub(DBusConnection *, DBusMessage *, void *);
 };
 
 static DBusObjectPathVTable _vtable =
 {
-  ObjectAdaptor::Private::unregister_function_stub,
-  ObjectAdaptor::Private::message_function_stub,
-  NULL, NULL, NULL, NULL
+	ObjectAdaptor::Private::unregister_function_stub,
+	ObjectAdaptor::Private::message_function_stub,
+	NULL, NULL, NULL, NULL
 };
 
 void ObjectAdaptor::Private::unregister_function_stub(DBusConnection *conn, void *data)
 {
-  //TODO: what do we have to do here ?
+ 	//TODO: what do we have to do here ?
 }
 
 DBusHandlerResult ObjectAdaptor::Private::message_function_stub(DBusConnection *, DBusMessage *dmsg, void *data)
 {
-  ObjectAdaptor *o = static_cast<ObjectAdaptor *>(data);
-
-  if (o)
-  {
-    Message msg(new Message::Private(dmsg));
-
-    debug_log("in object %s", o->path().c_str());
-    debug_log(" got message #%d from %s to %s",
-              msg.serial(),
-              msg.sender(),
-              msg.destination()
-             );
-
-    return o->handle_message(msg)
-           ? DBUS_HANDLER_RESULT_HANDLED
-           : DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-  }
-  else
-  {
-    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-  }
+	ObjectAdaptor *o = static_cast<ObjectAdaptor *>(data);
+
+	if (o)
+	{
+		Message msg(new Message::Private(dmsg));
+
+		debug_log("in object %s", o->path().c_str());
+		debug_log(" got message #%d from %s to %s",
+			msg.serial(),
+			msg.sender(),
+			msg.destination()
+		);
+
+		return o->handle_message(msg)
+			? DBUS_HANDLER_RESULT_HANDLED
+			: DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+	}
+	else
+	{
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+	}
 }
 
 typedef std::map<Path, ObjectAdaptor *> ObjectAdaptorTable;
@@ -104,282 +96,408 @@ static ObjectAdaptorTable _adaptor_table;
 
 ObjectAdaptor *ObjectAdaptor::from_path(const Path &path)
 {
-  ObjectAdaptorTable::iterator ati = _adaptor_table.find(path);
+	ObjectAdaptorTable::iterator ati = _adaptor_table.find(path);
 
-  if (ati != _adaptor_table.end())
-    return ati->second;
+	if (ati != _adaptor_table.end())
+		return ati->second;
 
-  return NULL;
+	return NULL;
 }
 
 ObjectAdaptorPList ObjectAdaptor::from_path_prefix(const std::string &prefix)
 {
-  ObjectAdaptorPList ali;
+	ObjectAdaptorPList ali;
 
-  ObjectAdaptorTable::iterator ati = _adaptor_table.begin();
+	ObjectAdaptorTable::iterator ati = _adaptor_table.begin();
 
-  size_t plen = prefix.length();
+	size_t plen = prefix.length();
 
-  while (ati != _adaptor_table.end())
-  {
-    if (!strncmp(ati->second->path().c_str(), prefix.c_str(), plen))
-      ali.push_back(ati->second);
+	while (ati != _adaptor_table.end())
+	{
+		if (!strncmp(ati->second->path().c_str(), prefix.c_str(), plen))
+			ali.push_back(ati->second);
 
-    ++ati;
-  }
+		++ati;
+	}
 
-  return ali;
+	return ali;
 }
 
 ObjectPathList ObjectAdaptor::child_nodes_from_prefix(const std::string &prefix)
 {
-  ObjectPathList ali;
+	ObjectPathList ali;
 
-  ObjectAdaptorTable::iterator ati = _adaptor_table.begin();
+	ObjectAdaptorTable::iterator ati = _adaptor_table.begin();
 
-  size_t plen = prefix.length();
+	size_t plen = prefix.length();
 
-  while (ati != _adaptor_table.end())
-  {
-    if (!strncmp(ati->second->path().c_str(), prefix.c_str(), plen))
-    {
-      std::string p = ati->second->path().substr(plen);
-      p = p.substr(0, p.find('/'));
-      ali.push_back(p);
-    }
-    ++ati;
-  }
+	while (ati != _adaptor_table.end())
+	{
+	  if (ati->second->path() != "/" &&  // Root node is never a child.
+	      !strncmp(ati->second->path().c_str(), prefix.c_str(), plen))
+		{
+				std::string p = ati->second->path().substr(plen);
+				p = p.substr(0,p.find('/'));
+				ali.push_back(p);
+		}
+		++ati;
+	}
 
-  ali.sort();
-  ali.unique();
+	ali.sort();
+	ali.unique();
 
-  return ali;
+	return ali;
 }
 
 ObjectAdaptor::ObjectAdaptor(Connection &conn, const Path &path)
-  : Object(conn, path, conn.unique_name())
+: Object(conn, path, conn.unique_name()), _eflag(USE_EXCEPTIONS)
 {
-  register_obj();
+	register_obj();
 }
 
-ObjectAdaptor::~ObjectAdaptor()
+ObjectAdaptor::ObjectAdaptor(Connection &conn, const Path &path, registration_time rtime)
+: Object(conn, path, conn.unique_name()), _eflag(USE_EXCEPTIONS)
 {
-  unregister_obj(false);
+	if (rtime == REGISTER_NOW)
+		register_obj();
 }
 
-void ObjectAdaptor::register_obj()
+ObjectAdaptor::ObjectAdaptor(Connection &conn, const Path &path, registration_time rtime,
+				exceptions_flag eflag)
+: Object(conn, path, conn.unique_name()), _eflag(eflag)
 {
-  debug_log("registering local object %s", path().c_str());
-
-  if (!dbus_connection_register_object_path(conn()._pvt->conn, path().c_str(), &_vtable, this))
-  {
-    throw ErrorNoMemory("unable to register object path");
-  }
+	if (rtime == REGISTER_NOW)
+		register_obj();
+}
 
-  _adaptor_table[path()] = this;
+ObjectAdaptor::~ObjectAdaptor()
+{
+	unregister_obj();
 }
 
-void ObjectAdaptor::unregister_obj(bool)
+void ObjectAdaptor::register_obj()
 {
-  _adaptor_table.erase(path());
+	debug_log("registering local object %s", path().c_str());
+
+        if (conn()._pvt->conn == NULL)
+        {
+                throw ErrorInvalidArgs("NULL connection");
+        }
+        else if (path().c_str() == NULL)
+        {
+                throw ErrorInvalidArgs("NULL path");
+        }
+        else if (path().c_str()[0] != '/')
+        {
+                std::string message = "Path must start with '/': " + path();
+                throw ErrorInvalidArgs(message.c_str());
+        }
+
+	DBusError error = DBUS_ERROR_INIT;
+	if (!dbus_connection_try_register_object_path(conn()._pvt->conn, path().c_str(), &_vtable, this, &error))
+	{
+		if (dbus_error_has_name(&error, DBUS_ERROR_OBJECT_PATH_IN_USE))
+		{
+			dbus_error_free(&error);
+			throw ErrorObjectPathInUse("unable to register object path");
+		}
+		else
+		{
+			dbus_error_free(&error);
+			throw ErrorNoMemory("unable to register object path");
+		}
+	}
+
+	_adaptor_table[path()] = this;
+}
 
-  debug_log("unregistering local object %s", path().c_str());
+void ObjectAdaptor::unregister_obj()
+{
+	if (!is_registered())
+		return;
+
+	_adaptor_table.erase(path());
+
+	debug_log("unregistering local object %s", path().c_str());
+
+        if (conn()._pvt->conn == NULL)
+        {
+                throw ErrorInvalidArgs("NULL connection");
+        }
+        else if (path().c_str() == NULL)
+        {
+                throw ErrorInvalidArgs("NULL path");
+        }
+        else if (path().c_str()[0] != '/')
+        {
+                std::string message = "Path must start with '/': " + path();
+                throw ErrorInvalidArgs(message.c_str());
+        }
+
+	dbus_connection_unregister_object_path(conn()._pvt->conn, path().c_str());
+}
 
-  dbus_connection_unregister_object_path(conn()._pvt->conn, path().c_str());
+bool ObjectAdaptor::is_registered()
+{
+	return _adaptor_table.find(path()) != _adaptor_table.end();
 }
 
 void ObjectAdaptor::_emit_signal(SignalMessage &sig)
 {
-  sig.path(path().c_str());
+	sig.path(path().c_str());
 
-  conn().send(sig);
+	conn().send(sig);
 }
 
 struct ReturnLaterError
 {
-  const Tag *tag;
+	const Tag *tag;
 };
 
 bool ObjectAdaptor::handle_message(const Message &msg)
 {
-  switch (msg.type())
-  {
-  case DBUS_MESSAGE_TYPE_METHOD_CALL:
-  {
-    const CallMessage &cmsg = reinterpret_cast<const CallMessage &>(msg);
-    const char *member      = cmsg.member();
-    const char *interface   = cmsg.interface();
-
-    debug_log(" invoking method %s.%s", interface, member);
-
-    InterfaceAdaptor *ii = find_interface(interface);
-    if (ii)
-    {
-      try
-      {
-        Message ret = ii->dispatch_method(cmsg);
-        conn().send(ret);
-      }
-      catch (Error &e)
-      {
-        ErrorMessage em(cmsg, e.name(), e.message());
-        conn().send(em);
-      }
-      catch (ReturnLaterError &rle)
-      {
-        _continuations[rle.tag] = new Continuation(conn(), cmsg, rle.tag);
-      }
-      return true;
-    }
-    else
-    {
-      return false;
-    }
-  }
-  default:
-  {
-    return false;
-  }
-  }
+	switch (msg.type())
+	{
+		case DBUS_MESSAGE_TYPE_METHOD_CALL:
+		{
+			const CallMessage &cmsg = reinterpret_cast<const CallMessage &>(msg);
+			const char *member      = cmsg.member();
+			const char *interface   = cmsg.interface();
+
+			debug_log(" invoking method %s.%s", interface, member);
+
+			InterfaceAdaptor *ii = find_interface(interface);
+			if (ii)
+			{
+				if (_eflag == AVOID_EXCEPTIONS) {
+					Message ret = ii->dispatch_method(cmsg);
+					Tag *tag = ret.tag();
+					if (tag) {
+						_continuations[tag] =
+						    new Continuation(conn(), cmsg, tag);
+					} else {
+						conn().send(ret);
+					}
+					return true;
+				}
+				// TODO(jglasgow@google.com): make this code
+				// conditional based on compile time option to
+				// support exceptions.
+				try
+				{
+					Message ret = ii->dispatch_method(cmsg);
+					conn().send(ret);
+				}
+				catch(Error &e)
+				{
+					ErrorMessage em(cmsg, e.name(), e.message());
+					conn().send(em);
+				}
+				catch(ReturnLaterError &rle)
+				{
+					_continuations[rle.tag] = new Continuation(conn(), cmsg, rle.tag);
+				}
+				return true;
+			}
+			else
+			{
+				return false;
+			}
+		}
+		default:
+		{
+			return false;
+		}
+	}
 }
 
 void ObjectAdaptor::return_later(const Tag *tag)
 {
-  ReturnLaterError rle = { tag };
-  throw rle;
+	ReturnLaterError rle = { tag };
+	throw rle;
 }
 
 void ObjectAdaptor::return_now(Continuation *ret)
 {
-  ret->_conn.send(ret->_return);
+	ret->_conn.send(ret->_return);
 
-  ContinuationMap::iterator di = _continuations.find(ret->_tag);
+	ContinuationMap::iterator di = _continuations.find(ret->_tag);
 
-  delete di->second;
+	delete di->second;
 
-  _continuations.erase(di);
+	_continuations.erase(di);
 }
 
 void ObjectAdaptor::return_error(Continuation *ret, const Error error)
 {
-  ret->_conn.send(ErrorMessage(ret->_call, error.name(), error.message()));
+	ret->_conn.send(ErrorMessage(ret->_call, error.name(), error.message()));
 
-  ContinuationMap::iterator di = _continuations.find(ret->_tag);
+	ContinuationMap::iterator di = _continuations.find(ret->_tag);
 
-  delete di->second;
+	delete di->second;
 
-  _continuations.erase(di);
+	_continuations.erase(di);
 }
 
 ObjectAdaptor::Continuation *ObjectAdaptor::find_continuation(const Tag *tag)
 {
-  ContinuationMap::iterator di = _continuations.find(tag);
+	ContinuationMap::iterator di = _continuations.find(tag);
 
-  return di != _continuations.end() ? di->second : NULL;
+	return di != _continuations.end() ? di->second : NULL;
 }
 
 ObjectAdaptor::Continuation::Continuation(Connection &conn, const CallMessage &call, const Tag *tag)
-  : _conn(conn), _call(call), _return(_call), _tag(tag)
+: _conn(conn), _call(call), _return(_call), _tag(tag)
 {
-  _writer = _return.writer(); //todo: verify
+	_writer = _return.writer(); //todo: verify
 }
 
 /*
 */
 
 ObjectProxy::ObjectProxy(Connection &conn, const Path &path, const char *service)
-  : Object(conn, path, service)
+: Object(conn, path, service)
 {
-  register_obj();
+	register_obj();
 }
 
+// TODO(ers@google.com): unregister_obj() makes a synchronous
+// dbus method call, which can result in a deadlock if the
+// ObjectProxy is deleted while in a callback from a signal
+// or a pending call reply.
 ObjectProxy::~ObjectProxy()
 {
-  unregister_obj(false);
+	cancel_pending_calls();
+	unregister_obj();
+}
+
+void ObjectProxy::cancel_pending_calls()
+{
+	PendingCallList::const_iterator pi = _pending_calls.begin();
+	while (pi != _pending_calls.end())
+	{
+		(*pi)->cancel();
+		delete *pi;
+		++pi;
+	}
+	_pending_calls.clear();
+}
+
+void ObjectProxy::_remove_pending_call(PendingCall *pending)
+{
+	PendingCallList::iterator pi = _pending_calls.begin();
+	while (pi != _pending_calls.end())
+	{
+		if (*pi == pending)
+		{
+			_pending_calls.erase(pi);
+			break;
+		}
+		++pi;
+	}
+	delete pending;
 }
 
 void ObjectProxy::register_obj()
 {
-  debug_log("registering remote object %s", path().c_str());
+	debug_log("registering remote object %s", path().c_str());
 
-  _filtered = new Callback<ObjectProxy, bool, const Message &>(this, &ObjectProxy::handle_message);
+	_filtered = new Callback<ObjectProxy, bool, const Message &>(this, &ObjectProxy::handle_message);
 
-  conn().add_filter(_filtered);
+	conn().add_filter(_filtered);
 
-  InterfaceProxyTable::const_iterator ii = _interfaces.begin();
-  while (ii != _interfaces.end())
-  {
-    std::string im = "type='signal',interface='" + ii->first + "',path='" + path() + "'";
-    conn().add_match(im.c_str());
-    ++ii;
-  }
+	InterfaceProxyTable::const_iterator ii = _interfaces.begin();
+	while (ii != _interfaces.end())
+	{
+		std::string im = "type='signal',interface='"+ii->first+"',path='"+path()+"'";
+		conn().add_match(im.c_str());
+		++ii;
+	}
 }
 
-void ObjectProxy::unregister_obj(bool throw_on_error)
+void ObjectProxy::unregister_obj()
 {
-  debug_log("unregistering remote object %s", path().c_str());
+	debug_log("unregistering remote object %s", path().c_str());
+
+	InterfaceProxyTable::const_iterator ii = _interfaces.begin();
+	while (ii != _interfaces.end())
+	{
+		std::string im = "type='signal',interface='"+ii->first+"',path='"+path()+"'";
+		conn().remove_match(im.c_str());
+		++ii;
+	}
+	conn().remove_filter(_filtered);
+}
 
-  InterfaceProxyTable::const_iterator ii = _interfaces.begin();
-  while (ii != _interfaces.end())
-  {
-    std::string im = "type='signal',interface='" + ii->first + "',path='" + path() + "'";
-    conn().remove_match(im.c_str(), throw_on_error);
-    ++ii;
-  }
-  conn().remove_filter(_filtered);
+bool ObjectProxy::is_registered()
+{
+	return true;
 }
 
 Message ObjectProxy::_invoke_method(CallMessage &call)
 {
-  if (call.path() == NULL)
-    call.path(path().c_str());
+	if (call.path() == NULL)
+		call.path(path().c_str());
 
-  if (call.destination() == NULL)
-    call.destination(service().c_str());
+	if (call.destination() == NULL)
+		call.destination(service().c_str());
 
-  return conn().send_blocking(call, get_timeout());
+	return conn().send_blocking(call);
 }
 
 bool ObjectProxy::_invoke_method_noreply(CallMessage &call)
 {
-  if (call.path() == NULL)
-    call.path(path().c_str());
+	if (call.path() == NULL)
+		call.path(path().c_str());
+
+	if (call.destination() == NULL)
+		call.destination(service().c_str());
+
+	return conn().send(call);
+}
+
+PendingCall *ObjectProxy::_invoke_method_async(CallMessage &call, int timeout)
+{
+	if (call.path() == NULL)
+		call.path(path().c_str());
 
-  if (call.destination() == NULL)
-    call.destination(service().c_str());
+	if (call.destination() == NULL)
+		call.destination(service().c_str());
 
-  return conn().send(call);
+	PendingCall *pending = conn().send_async(call, timeout);
+	_pending_calls.push_back(pending);
+	return pending;
 }
 
 bool ObjectProxy::handle_message(const Message &msg)
 {
-  switch (msg.type())
-  {
-  case DBUS_MESSAGE_TYPE_SIGNAL:
-  {
-    const SignalMessage &smsg = reinterpret_cast<const SignalMessage &>(msg);
-    const char *interface	= smsg.interface();
-    const char *member	= smsg.member();
-    const char *objpath	= smsg.path();
-
-    if (objpath != path()) return false;
-
-    debug_log("filtered signal %s(in %s) from %s to object %s",
-              member, interface, msg.sender(), objpath);
-
-    InterfaceProxy *ii = find_interface(interface);
-    if (ii)
-    {
-      return ii->dispatch_signal(smsg);
-    }
-    else
-    {
-      return false;
-    }
-  }
-  default:
-  {
-    return false;
-  }
-  }
+	switch (msg.type())
+	{
+		case DBUS_MESSAGE_TYPE_SIGNAL:
+		{
+			const SignalMessage &smsg = reinterpret_cast<const SignalMessage &>(msg);
+			const char *interface	= smsg.interface();
+			const char *member	= smsg.member();
+			const char *objpath	= smsg.path();
+
+			if (objpath != path()) return false;
+
+			debug_log("filtered signal %s(in %s) from %s to object %s",
+				member, interface, msg.sender(), objpath);
+
+			InterfaceProxy *ii = find_interface(interface);
+			if (ii)
+			{
+				return ii->dispatch_signal(smsg);
+			}
+			else
+			{
+				return false;
+			}
+		}
+		default:
+		{
+			return false;
+		}
+	}
 }
diff --git a/src/pendingcall.cpp b/src/pendingcall.cpp
index d67f486..e566c8b 100644
--- a/src/pendingcall.cpp
+++ b/src/pendingcall.cpp
@@ -36,107 +36,109 @@
 using namespace DBus;
 
 PendingCall::Private::Private(DBusPendingCall *dpc)
-  : call(dpc), dataslot(-1)
+: call(dpc), dataslot(-1)
 {
-  if (!dbus_pending_call_allocate_data_slot(&dataslot))
-  {
-    throw ErrorNoMemory("Unable to allocate data slot");
-  }
+	if (!dbus_pending_call_allocate_data_slot(&dataslot))
+	{
+		throw ErrorNoMemory("Unable to allocate data slot");
+	}
 }
 
 PendingCall::Private::~Private()
 {
-  if (dataslot != -1)
-  {
-    dbus_pending_call_allocate_data_slot(&dataslot);
-  }
+	if (dataslot != -1)
+	{
+		dbus_pending_call_free_data_slot(&dataslot);
+	}
 }
 
 void PendingCall::Private::notify_stub(DBusPendingCall *dpc, void *data)
 {
-  PendingCall::Private *pvt = static_cast<PendingCall::Private *>(data);
-
-  PendingCall pc(pvt);
-  pvt->slot(pc);
+	PendingCall *pc = static_cast<PendingCall*>(data);
+	pc->_pvt->reply_handler(pc);
 }
 
 PendingCall::PendingCall(PendingCall::Private *p)
-  : _pvt(p)
+: _pvt(p)
 {
-  if (!dbus_pending_call_set_notify(_pvt->call, Private::notify_stub, p, NULL))
-  {
-    throw ErrorNoMemory("Unable to initialize pending call");
-  }
+	if (!dbus_pending_call_set_notify(_pvt->call, Private::notify_stub, this, NULL))
+	{
+		throw ErrorNoMemory("Unable to initialize pending call");
+	}
 }
 
 PendingCall::PendingCall(const PendingCall &c)
-  : _pvt(c._pvt)
+: _pvt(c._pvt)
 {
-  dbus_pending_call_ref(_pvt->call);
+	dbus_pending_call_ref(_pvt->call);
 }
 
 PendingCall::~PendingCall()
 {
-  dbus_pending_call_unref(_pvt->call);
+	dbus_pending_call_unref(_pvt->call);
 }
 
 PendingCall &PendingCall::operator = (const PendingCall &c)
 {
-  if (&c != this)
-  {
-    dbus_pending_call_unref(_pvt->call);
-    _pvt = c._pvt;
-    dbus_pending_call_ref(_pvt->call);
-  }
-  return *this;
+	if (&c != this)
+	{
+		dbus_pending_call_unref(_pvt->call);
+		_pvt = c._pvt;
+		dbus_pending_call_ref(_pvt->call);
+	}
+	return *this;
 }
 
 bool PendingCall::completed()
 {
-  return dbus_pending_call_get_completed(_pvt->call);
+	return dbus_pending_call_get_completed(_pvt->call);
 }
 
 void PendingCall::cancel()
 {
-  dbus_pending_call_cancel(_pvt->call);
+	dbus_pending_call_cancel(_pvt->call);
 }
 
 void PendingCall::block()
 {
-  dbus_pending_call_block(_pvt->call);
+	dbus_pending_call_block(_pvt->call);
 }
 
 void PendingCall::data(void *p)
 {
-  if (!dbus_pending_call_set_data(_pvt->call, _pvt->dataslot, p, NULL))
-  {
-    throw ErrorNoMemory("Unable to initialize data slot");
-  }
+	if (!dbus_pending_call_set_data(_pvt->call, _pvt->dataslot, p, NULL))
+	{
+		throw ErrorNoMemory("Unable to initialize data slot");
+	}
 }
 
 void *PendingCall::data()
 {
-  return dbus_pending_call_get_data(_pvt->call, _pvt->dataslot);
+	return dbus_pending_call_get_data(_pvt->call, _pvt->dataslot);
 }
 
-Slot<void, PendingCall &>& PendingCall::slot()
+AsyncReplyHandler& PendingCall::reply_handler()
 {
-  return _pvt->slot;
+	return _pvt->reply_handler;
 }
 
-Message PendingCall::steal_reply()
+void PendingCall::reply_handler(const AsyncReplyHandler& handler)
 {
-  DBusMessage *dmsg = dbus_pending_call_steal_reply(_pvt->call);
-  if (!dmsg)
-  {
-    dbus_bool_t callComplete = dbus_pending_call_get_completed(_pvt->call);
-
-    if (callComplete)
-      throw ErrorNoReply("No reply available");
-    else
-      throw ErrorNoReply("Call not complete");
-  }
-
-  return Message(new Message::Private(dmsg));
+	_pvt->reply_handler = handler;
 }
 
+Message PendingCall::steal_reply()
+{
+	DBusMessage *dmsg = dbus_pending_call_steal_reply(_pvt->call);
+	if (!dmsg)
+	{
+		dbus_bool_t callComplete = dbus_pending_call_get_completed(_pvt->call);
+
+		if (callComplete)
+			throw ErrorNoReply("No reply available");
+		else
+			throw ErrorNoReply("Call not complete");
+	}
+
+	return Message(new Message::Private(dmsg));
+}
diff --git a/src/pendingcall_p.h b/src/pendingcall_p.h
index 03c55e6..e0e3133 100644
--- a/src/pendingcall_p.h
+++ b/src/pendingcall_p.h
@@ -34,20 +34,19 @@
 
 #include <dbus/dbus.h>
 
-namespace DBus
-{
+namespace DBus {
 
 struct DXXAPILOCAL PendingCall::Private
 {
-  DBusPendingCall *call;
-  int dataslot;
-  Slot<void, PendingCall &> slot;
-
-  Private(DBusPendingCall *);
+	DBusPendingCall *call;
+	int dataslot;
+	AsyncReplyHandler reply_handler;
+	
+	Private(DBusPendingCall *);
 
-  ~Private();
+	~Private();
 
-  static void notify_stub(DBusPendingCall *dpc, void *data);
+	static void notify_stub(DBusPendingCall *dpc, void *data);
 };
 
 } /* namespace DBus */
diff --git a/src/property.cpp b/src/property.cpp
index 763a12e..52a6804 100644
--- a/src/property.cpp
+++ b/src/property.cpp
@@ -35,121 +35,158 @@ using namespace DBus;
 static const char *properties_name = "org.freedesktop.DBus.Properties";
 
 PropertiesAdaptor::PropertiesAdaptor()
-  : InterfaceAdaptor(properties_name)
+: InterfaceAdaptor(properties_name)
 {
-  register_method(PropertiesAdaptor, Get, Get);
-  register_method(PropertiesAdaptor, Set, Set);
+	register_method(PropertiesAdaptor, Get, Get);
+	register_method(PropertiesAdaptor, Set, Set);
+	register_method(PropertiesAdaptor, GetAll, GetAll);
 }
 
 Message PropertiesAdaptor::Get(const CallMessage &call)
 {
-  MessageIter ri = call.reader();
+	MessageIter ri = call.reader();
 
-  std::string iface_name;
-  std::string property_name;
+	std::string iface_name;
+	std::string property_name;
 
-  ri >> iface_name >> property_name;
+	ri >> iface_name >> property_name;
 
-  debug_log("requesting property %s on interface %s", property_name.c_str(), iface_name.c_str());
+	debug_log("requesting property %s on interface %s", property_name.c_str(), iface_name.c_str());
 
-  InterfaceAdaptor *interface = (InterfaceAdaptor *) find_interface(iface_name);
+	InterfaceAdaptor *interface = (InterfaceAdaptor *) find_interface(iface_name);
 
-  if (!interface)
-    throw ErrorFailed("requested interface not found");
+	if (!interface)
+		throw ErrorFailed("requested interface not found");
 
-  Variant *value = interface->get_property(property_name);
+	Variant *value = interface->get_property(property_name);
 
-  if (!value)
-    throw ErrorFailed("requested property not found");
+	if (!value)
+		throw ErrorFailed("requested property not found");
 
-  on_get_property(*interface, property_name, *value);
+        if (value->signature().empty())
+		throw ErrorFailed("requested property has not been initialized");
 
-  ReturnMessage reply(call);
+	on_get_property(*interface, property_name, *value);
 
-  MessageIter wi = reply.writer();
+	ReturnMessage reply(call);
 
-  wi << *value;
-  return reply;
+	MessageIter wi = reply.writer();
+
+	wi << *value;
+	return reply;
 }
 
 Message PropertiesAdaptor::Set(const CallMessage &call)
 {
-  MessageIter ri = call.reader();
+	MessageIter ri = call.reader();
 
-  std::string iface_name;
-  std::string property_name;
-  Variant value;
+	std::string iface_name;
+	std::string property_name;
+	Variant value;
 
-  ri >> iface_name >> property_name >> value;
+	ri >> iface_name >> property_name >> value;
 
-  InterfaceAdaptor *interface = (InterfaceAdaptor *) find_interface(iface_name);
+	InterfaceAdaptor *interface = (InterfaceAdaptor *) find_interface(iface_name);
 
-  if (!interface)
-    throw ErrorFailed("requested interface not found");
+	if (!interface)
+		throw ErrorFailed("requested interface not found");
 
-  on_set_property(*interface, property_name, value);
+	on_set_property(*interface, property_name, value);
 
-  interface->set_property(property_name, value);
+	interface->set_property(property_name, value);
 
-  ReturnMessage reply(call);
+	ReturnMessage reply(call);
 
-  return reply;
+	return reply;
 }
 
-IntrospectedInterface *PropertiesAdaptor::introspect() const
+Message PropertiesAdaptor::GetAll(const CallMessage &call)
 {
-  static IntrospectedArgument Get_args[] =
-  {
-    { "interface_name", "s", true },
-    { "property_name", "s", true },
-    { "value", "v", false },
-    { 0, 0, 0 }
-  };
-  static IntrospectedArgument Set_args[] =
-  {
-    { "interface_name", "s", true },
-    { "property_name", "s", true },
-    { "value", "v", true },
-    { 0, 0, 0 }
-  };
-  static IntrospectedMethod Properties_methods[] =
-  {
-    { "Get", Get_args },
-    { "Set", Set_args },
-    { 0, 0 }
-  };
-  static IntrospectedMethod Properties_signals[] =
-  {
-    { 0, 0 }
-  };
-  static IntrospectedProperty Properties_properties[] =
-  {
-    { 0, 0, 0, 0 }
-  };
-  static IntrospectedInterface Properties_interface =
-  {
-    properties_name,
-    Properties_methods,
-    Properties_signals,
-    Properties_properties
-  };
-  return &Properties_interface;
+	MessageIter ri = call.reader();
+
+	std::string iface_name;
+	std::string property_name;
+	Variant value;
+
+	ri >> iface_name;
+
+	InterfaceAdaptor *interface = (InterfaceAdaptor *) find_interface(iface_name);
+
+	if (!interface)
+		throw ErrorFailed("requested interface not found");
+
+        PropertyDict *properties;
+        properties = interface->get_all_properties();
+
+	ReturnMessage reply(call);
+
+	MessageIter wi = reply.writer();
+
+	wi << *properties;
+	delete properties;
+	return reply;
+}
+
+const IntrospectedInterface *PropertiesAdaptor::introspect() const
+{
+	static IntrospectedArgument Get_args[] =
+	{
+		{ "interface_name", "s", true },
+		{ "property_name", "s", true },
+		{ "value", "v", false },
+		{ 0, 0, 0 }
+	};
+	static IntrospectedArgument Set_args[] =
+	{
+		{ "interface_name", "s", true },
+		{ "property_name", "s", true },
+		{ "value", "v", true },
+		{ 0, 0, 0 }
+	};
+	static IntrospectedArgument GetAll_args[] =
+	{
+		{ "interface_name", "s", true },
+		{ "properties", "a{sv}", false },
+		{ 0, 0, 0 }
+	};
+	static IntrospectedMethod Properties_methods[] =
+	{
+		{ "Get", Get_args },
+		{ "Set", Set_args },
+		{ "GetAll", GetAll_args },
+		{ 0, 0 }
+	};
+	static IntrospectedMethod Properties_signals[] =
+	{
+		{ 0, 0 }
+	};
+	static IntrospectedProperty Properties_properties[] = 
+	{
+		{ 0, 0, 0, 0 }
+	};
+	static IntrospectedInterface Properties_interface =
+	{
+		properties_name,
+		Properties_methods,
+		Properties_signals,
+		Properties_properties
+	};
+	return &Properties_interface;
 }
 
 PropertiesProxy::PropertiesProxy()
-  : InterfaceProxy(properties_name)
+: InterfaceProxy(properties_name)
 {
 }
 
 Variant PropertiesProxy::Get(const std::string &iface, const std::string &property)
 {
 //todo
-  Variant v;
-  return v;
+	Variant v;
+	return v;
 }
 
 void PropertiesProxy::Set(const std::string &iface, const std::string &property, const Variant &value)
 {
 //todo
 }
-
diff --git a/src/server.cpp b/src/server.cpp
index b905291..0c652e5 100644
--- a/src/server.cpp
+++ b/src/server.cpp
@@ -36,7 +36,7 @@
 using namespace DBus;
 
 Server::Private::Private(DBusServer *s)
-  : server(s)
+: server(s)
 {
 }
 
@@ -46,31 +46,31 @@ Server::Private::~Private()
 
 void Server::Private::on_new_conn_cb(DBusServer *server, DBusConnection *conn, void *data)
 {
-  Server *s = static_cast<Server *>(data);
+	Server *s = static_cast<Server *>(data);
 
-  Connection nc(new Connection::Private(conn, s->_pvt.get()));
+	Connection nc (new Connection::Private(conn, s->_pvt.get()));
 
-  s->_pvt->connections.push_back(nc);
+	s->_pvt->connections.push_back(nc);
 
-  s->on_new_connection(nc);
+	s->on_new_connection(nc);
 
-  debug_log("incoming connection 0x%08x", conn);
+	debug_log("incoming connection 0x%08x", conn);
 }
 
 Server::Server(const char *address)
 {
-  InternalError e;
-  DBusServer *server = dbus_server_listen(address, e);
+	InternalError e;
+	DBusServer *server = dbus_server_listen(address, e);
 
-  if (e) throw Error(e);
+	if (e) throw Error(e);
 
-  debug_log("server 0x%08x listening on %s", server, address);
+	debug_log("server 0x%08x listening on %s", server, address);
 
-  _pvt = new Private(server);
+	_pvt = new Private(server);
 
-  dbus_server_set_new_connection_function(_pvt->server, Private::on_new_conn_cb, this, NULL);
+	dbus_server_set_new_connection_function(_pvt->server, Private::on_new_conn_cb, this, NULL);
 
-  setup(default_dispatcher);
+	setup(default_dispatcher);
 }
 /*
 Server::Server(const Server &s)
@@ -81,49 +81,49 @@ Server::Server(const Server &s)
 */
 Server::~Server()
 {
-  dbus_server_unref(_pvt->server);
+	dbus_server_unref(_pvt->server);
 }
 
 Dispatcher *Server::setup(Dispatcher *dispatcher)
 {
-  debug_log("registering stubs for server %p", _pvt->server);
-
-  Dispatcher *prev = _pvt->dispatcher;
-
-  dbus_server_set_watch_functions(
-    _pvt->server,
-    Dispatcher::Private::on_add_watch,
-    Dispatcher::Private::on_rem_watch,
-    Dispatcher::Private::on_toggle_watch,
-    dispatcher,
-    0
-  );
-
-  dbus_server_set_timeout_functions(
-    _pvt->server,
-    Dispatcher::Private::on_add_timeout,
-    Dispatcher::Private::on_rem_timeout,
-    Dispatcher::Private::on_toggle_timeout,
-    dispatcher,
-    0
-  );
-
-  _pvt->dispatcher = dispatcher;
-
-  return prev;
+	debug_log("registering stubs for server %p", _pvt->server);
+
+	Dispatcher *prev = _pvt->dispatcher;
+
+	dbus_server_set_watch_functions(
+		_pvt->server,
+		Dispatcher::Private::on_add_watch,
+		Dispatcher::Private::on_rem_watch,
+		Dispatcher::Private::on_toggle_watch,
+		dispatcher,
+		0
+	);
+
+	dbus_server_set_timeout_functions(
+		_pvt->server,
+		Dispatcher::Private::on_add_timeout,
+		Dispatcher::Private::on_rem_timeout,
+		Dispatcher::Private::on_toggle_timeout,
+		dispatcher,
+		0
+	);
+
+	_pvt->dispatcher = dispatcher;
+
+	return prev;
 }
 
 bool Server::operator == (const Server &s) const
 {
-  return _pvt->server == s._pvt->server;
+	return _pvt->server == s._pvt->server;
 }
 
 bool Server::listening() const
 {
-  return dbus_server_get_is_connected(_pvt->server);
+	return dbus_server_get_is_connected(_pvt->server);
 }
 void Server::disconnect()
 {
-  dbus_server_disconnect(_pvt->server);
+	dbus_server_disconnect(_pvt->server);
 }
 
diff --git a/src/server_p.h b/src/server_p.h
index 2720978..826132d 100644
--- a/src/server_p.h
+++ b/src/server_p.h
@@ -35,22 +35,21 @@
 
 #include <dbus/dbus.h>
 
-namespace DBus
-{
+namespace DBus {
 
-struct DXXAPILOCAL Server::Private
+struct DXXAPILOCAL Server::Private 
 {
-  DBusServer *server;
+	DBusServer *server;
 
-  Dispatcher *dispatcher;
+	Dispatcher *dispatcher;
 
-  ConnectionList connections;
+	ConnectionList connections;
 
-  Private(DBusServer *);
+	Private(DBusServer *);
 
-  ~Private();
+	~Private();
 
-  static void on_new_conn_cb(DBusServer *server, DBusConnection *conn, void *data);
+	static void on_new_conn_cb(DBusServer *server, DBusConnection *conn, void *data);
 };
 
 } /* namespace DBus */
diff --git a/src/types.cpp b/src/types.cpp
index d414a3e..9ccc000 100644
--- a/src/types.cpp
+++ b/src/types.cpp
@@ -34,73 +34,74 @@
 #include "message_p.h"
 #include "internalerror.h"
 
-using namespace DBus;
+namespace DBus {
 
 Variant::Variant()
-  : _msg(CallMessage()) // dummy message used as temporary storage for variant data
+: _msg(CallMessage()) // dummy message used as temporary storage for variant data
 {
 }
 
 Variant::Variant(MessageIter &it)
-  : _msg(CallMessage())
+: _msg(CallMessage())
 {
-  MessageIter vi = it.recurse();
-  MessageIter mi = _msg.writer();
-  vi.copy_data(mi);
+	MessageIter vi = it.recurse();
+	MessageIter mi = _msg.writer();
+	vi.copy_data(mi);
 }
 
 Variant &Variant::operator = (const Variant &v)
 {
-  if (&v != this)
-  {
-    _msg = v._msg;
-  }
-  return *this;
+	if (&v != this)
+	{
+		_msg = v._msg;
+	}
+	return *this;
 }
 
 void Variant::clear()
 {
-  CallMessage empty;
-  _msg = empty;
+	CallMessage empty;
+	_msg = empty;
 }
 
 const Signature Variant::signature() const
 {
-  char *sigbuf = reader().signature();
+	char *sigbuf = reader().signature();
 
-  Signature signature = sigbuf;
+	Signature signature = sigbuf;
 
-  free(sigbuf);
+	free(sigbuf);
 
-  return signature;
+	return signature;
 }
 
 MessageIter &operator << (MessageIter &iter, const Variant &val)
 {
-  const Signature sig = val.signature();
+	const Signature sig = val.signature();
 
-  MessageIter rit = val.reader();
-  MessageIter wit = iter.new_variant(sig.c_str());
+	MessageIter rit = val.reader();
+	MessageIter wit = iter.new_variant(sig.c_str());
 
-  rit.copy_data(wit);
+	rit.copy_data(wit);
 
-  iter.close_container(wit);
+	iter.close_container(wit);
 
-  return iter;
+	return iter;
 }
 
 MessageIter &operator >> (MessageIter &iter, Variant &val)
 {
-  if (iter.type() != DBUS_TYPE_VARIANT)
-    throw ErrorInvalidArgs("variant type expected");
+	if (iter.type() != DBUS_TYPE_VARIANT)
+		throw ErrorInvalidArgs("variant type expected");
 
-  val.clear();
+	val.clear();
 
-  MessageIter vit = iter.recurse();
-  MessageIter mit = val.writer();
+	MessageIter vit = iter.recurse();
+	MessageIter mit = val.writer();
 
-  vit.copy_data(mit);
+	vit.copy_data(mit);
 
-  return ++iter;
+	return ++iter;
 }
 
+} /* namespace DBus */
-- 
2.25.0


